import {
  Point,
  Signature,
  getPublicKey,
  hmac,
  require_lib,
  require_lodash,
  ripemd160,
  sha256,
  sha512_256,
  signSync,
  utils,
  verify
} from "./chunk-NYXX57DY.js";
import {
  StacksMainnet,
  StacksNetwork,
  StacksTestnet,
  createFetchFn
} from "./chunk-XXTALUMN.js";
import {
  __export,
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/@stacks/transactions/node_modules/@stacks/common/dist/esm/errors.js
var ERROR_CODES = {
  MISSING_PARAMETER: "missing_parameter",
  REMOTE_SERVICE_ERROR: "remote_service_error",
  INVALID_STATE: "invalid_state",
  NO_SESSION_DATA: "no_session_data",
  DOES_NOT_EXIST: "does_not_exist",
  FAILED_DECRYPTION_ERROR: "failed_decryption_error",
  INVALID_DID_ERROR: "invalid_did_error",
  NOT_ENOUGH_FUNDS_ERROR: "not_enough_error",
  INVALID_AMOUNT_ERROR: "invalid_amount_error",
  LOGIN_FAILED_ERROR: "login_failed",
  SIGNATURE_VERIFICATION_ERROR: "signature_verification_failure",
  CONFLICT_ERROR: "conflict_error",
  NOT_ENOUGH_PROOF_ERROR: "not_enough_proof_error",
  BAD_PATH_ERROR: "bad_path_error",
  VALIDATION_ERROR: "validation_error",
  PAYLOAD_TOO_LARGE_ERROR: "payload_too_large_error",
  PRECONDITION_FAILED_ERROR: "precondition_failed_error",
  UNKNOWN: "unknown"
};
Object.freeze(ERROR_CODES);

// node_modules/@stacks/transactions/node_modules/@stacks/common/dist/esm/logger.js
var levels = ["debug", "info", "warn", "error", "none"];
var levelToInt = {};
var intToLevel = {};
for (let index = 0; index < levels.length; index++) {
  const level = levels[index];
  levelToInt[level] = index;
  intToLevel[index] = level;
}

// node_modules/@stacks/transactions/node_modules/@stacks/common/dist/esm/utils.js
function intToBytes(value, signed, byteLength) {
  return bigIntToBytes(intToBigInt(value, signed), byteLength);
}
function intToBigInt(value, signed) {
  let parsedValue = value;
  if (typeof parsedValue === "number") {
    if (!Number.isInteger(parsedValue)) {
      throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);
    }
    if (parsedValue > Number.MAX_SAFE_INTEGER) {
      throw new RangeError(`Invalid value. Values of type 'number' must be less than or equal to ${Number.MAX_SAFE_INTEGER}. For larger values, try using a BigInt instead.`);
    }
    return BigInt(parsedValue);
  }
  if (typeof parsedValue === "string") {
    if (parsedValue.toLowerCase().startsWith("0x")) {
      let hex = parsedValue.slice(2);
      hex = hex.padStart(hex.length + hex.length % 2, "0");
      parsedValue = hexToBytes(hex);
    } else {
      try {
        return BigInt(parsedValue);
      } catch (error2) {
        if (error2 instanceof SyntaxError) {
          throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);
        }
      }
    }
  }
  if (typeof parsedValue === "bigint") {
    return parsedValue;
  }
  if (parsedValue instanceof Uint8Array) {
    if (signed) {
      const bn = fromTwos(BigInt(`0x${bytesToHex(parsedValue)}`), BigInt(parsedValue.byteLength * 8));
      return BigInt(bn.toString());
    } else {
      return BigInt(`0x${bytesToHex(parsedValue)}`);
    }
  }
  if (parsedValue != null && typeof parsedValue === "object" && parsedValue.constructor.name === "BN") {
    return BigInt(parsedValue.toString());
  }
  throw new TypeError(`Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array.`);
}
function with0x(value) {
  return value.startsWith("0x") ? value : `0x${value}`;
}
function hexToBigInt(hex) {
  if (typeof hex !== "string")
    throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);
  return BigInt(`0x${hex}`);
}
function intToHex(integer, lengthBytes = 8) {
  const value = typeof integer === "bigint" ? integer : intToBigInt(integer, false);
  return value.toString(16).padStart(lengthBytes * 2, "0");
}
function hexToInt(hex) {
  return parseInt(hex, 16);
}
function bigIntToBytes(value, length = 16) {
  const hex = intToHex(value, length);
  return hexToBytes(hex);
}
function toTwos(value, width) {
  if (value < -(BigInt(1) << width - BigInt(1)) || (BigInt(1) << width - BigInt(1)) - BigInt(1) < value) {
    throw `Unable to represent integer in width: ${width}`;
  }
  if (value >= BigInt(0)) {
    return BigInt(value);
  }
  return value + (BigInt(1) << width);
}
function nthBit(value, n) {
  return value & BigInt(1) << n;
}
function fromTwos(value, width) {
  if (nthBit(value, width - BigInt(1))) {
    return value - (BigInt(1) << width);
  }
  return value;
}
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (const u of uint8a) {
    hex += hexes[u];
  }
  return hex;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);
  }
  hex = hex.startsWith("0x") || hex.startsWith("0X") ? hex.slice(2) : hex;
  const paddedHex = hex.length % 2 ? `0${hex}` : hex;
  const array = new Uint8Array(paddedHex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = paddedHex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function utf8ToBytes(str) {
  return new TextEncoder().encode(str);
}
function bytesToUtf8(arr) {
  return new TextDecoder().decode(arr);
}
function asciiToBytes(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; i++) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii(arr) {
  return String.fromCharCode.apply(null, arr);
}
function isNotOctet(octet) {
  return !Number.isInteger(octet) || octet < 0 || octet > 255;
}
function octetsToBytes(numbers) {
  if (numbers.some(isNotOctet))
    throw new Error("Some values are invalid bytes.");
  return new Uint8Array(numbers);
}
function concatBytes(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function concatArray(elements) {
  return concatBytes(...elements.map((e) => {
    if (typeof e === "number")
      return octetsToBytes([e]);
    if (e instanceof Array)
      return octetsToBytes(e);
    return e;
  }));
}

// node_modules/@stacks/transactions/node_modules/@stacks/common/dist/esm/constants.js
var ChainID;
(function(ChainID3) {
  ChainID3[ChainID3["Testnet"] = 2147483648] = "Testnet";
  ChainID3[ChainID3["Mainnet"] = 1] = "Mainnet";
})(ChainID || (ChainID = {}));
var TransactionVersion;
(function(TransactionVersion3) {
  TransactionVersion3[TransactionVersion3["Mainnet"] = 0] = "Mainnet";
  TransactionVersion3[TransactionVersion3["Testnet"] = 128] = "Testnet";
})(TransactionVersion || (TransactionVersion = {}));
var PeerNetworkID;
(function(PeerNetworkID2) {
  PeerNetworkID2[PeerNetworkID2["Mainnet"] = 385875968] = "Mainnet";
  PeerNetworkID2[PeerNetworkID2["Testnet"] = 4278190080] = "Testnet";
})(PeerNetworkID || (PeerNetworkID = {}));
var PRIVATE_KEY_COMPRESSED_LENGTH = 33;

// node_modules/@stacks/transactions/node_modules/@stacks/common/dist/esm/signatures.js
var COORDINATE_BYTES = 32;
function parseRecoverableSignatureVrs(signature) {
  if (signature.length < COORDINATE_BYTES * 2 * 2 + 1) {
    throw new Error("Invalid signature");
  }
  const recoveryIdHex = signature.slice(0, 2);
  const r = signature.slice(2, 2 + COORDINATE_BYTES * 2);
  const s = signature.slice(2 + COORDINATE_BYTES * 2);
  return {
    recoveryId: hexToInt(recoveryIdHex),
    r,
    s
  };
}
function signatureVrsToRsv(signature) {
  return signature.slice(2) + signature.slice(0, 2);
}
function signatureRsvToVrs(signature) {
  return signature.slice(-2) + signature.slice(0, -2);
}

// node_modules/@stacks/transactions/node_modules/@stacks/common/dist/esm/keys.js
function privateKeyToBytes(privateKey) {
  const privateKeyBuffer = typeof privateKey === "string" ? hexToBytes(privateKey) : privateKey;
  if (privateKeyBuffer.length != 32 && privateKeyBuffer.length != 33) {
    throw new Error(`Improperly formatted private-key. Private-key byte length should be 32 or 33. Length provided: ${privateKeyBuffer.length}`);
  }
  if (privateKeyBuffer.length == 33 && privateKeyBuffer[32] !== 1) {
    throw new Error("Improperly formatted private-key. 33 bytes indicate compressed key, but the last byte must be == 01");
  }
  return privateKeyBuffer;
}

// node_modules/@stacks/transactions/node_modules/@stacks/common/dist/esm/buffer.js
function readUInt16BE(source, offset) {
  return (source[offset + 0] << 8 | source[offset + 1]) >>> 0;
}
function writeUInt16BE(destination, value, offset = 0) {
  destination[offset + 0] = value >>> 8;
  destination[offset + 1] = value >>> 0;
  return destination;
}
function readUInt8(source, offset) {
  return source[offset];
}
function writeUInt8(destination, value, offset = 0) {
  destination[offset] = value;
  return destination;
}
function readUInt32BE(source, offset) {
  return source[offset] * 2 ** 24 + source[offset + 1] * 2 ** 16 + source[offset + 2] * 2 ** 8 + source[offset + 3];
}
function writeUInt32BE(destination, value, offset = 0) {
  destination[offset + 3] = value;
  value >>>= 8;
  destination[offset + 2] = value;
  value >>>= 8;
  destination[offset + 1] = value;
  value >>>= 8;
  destination[offset] = value;
  return destination;
}

// node_modules/@stacks/transactions/dist/esm/constants.js
var ChainID2;
(function(ChainID3) {
  ChainID3[ChainID3["Testnet"] = 2147483648] = "Testnet";
  ChainID3[ChainID3["Mainnet"] = 1] = "Mainnet";
})(ChainID2 || (ChainID2 = {}));
var DEFAULT_CHAIN_ID = ChainID2.Mainnet;
var MAX_STRING_LENGTH_BYTES = 128;
var CLARITY_INT_SIZE = 128;
var CLARITY_INT_BYTE_SIZE = 16;
var COINBASE_BYTES_LENGTH = 32;
var VRF_PROOF_BYTES_LENGTH = 80;
var RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;
var COMPRESSED_PUBKEY_LENGTH_BYTES = 32;
var UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;
var MEMO_MAX_LENGTH_BYTES = 34;
var DEFAULT_CORE_NODE_API_URL = "https://api.mainnet.hiro.so";
var StacksMessageType;
(function(StacksMessageType2) {
  StacksMessageType2[StacksMessageType2["Address"] = 0] = "Address";
  StacksMessageType2[StacksMessageType2["Principal"] = 1] = "Principal";
  StacksMessageType2[StacksMessageType2["LengthPrefixedString"] = 2] = "LengthPrefixedString";
  StacksMessageType2[StacksMessageType2["MemoString"] = 3] = "MemoString";
  StacksMessageType2[StacksMessageType2["AssetInfo"] = 4] = "AssetInfo";
  StacksMessageType2[StacksMessageType2["PostCondition"] = 5] = "PostCondition";
  StacksMessageType2[StacksMessageType2["PublicKey"] = 6] = "PublicKey";
  StacksMessageType2[StacksMessageType2["LengthPrefixedList"] = 7] = "LengthPrefixedList";
  StacksMessageType2[StacksMessageType2["Payload"] = 8] = "Payload";
  StacksMessageType2[StacksMessageType2["MessageSignature"] = 9] = "MessageSignature";
  StacksMessageType2[StacksMessageType2["StructuredDataSignature"] = 10] = "StructuredDataSignature";
  StacksMessageType2[StacksMessageType2["TransactionAuthField"] = 11] = "TransactionAuthField";
})(StacksMessageType || (StacksMessageType = {}));
function whenMessageType(messageType) {
  return (messageTypeMap) => messageTypeMap[messageType];
}
var PayloadType;
(function(PayloadType2) {
  PayloadType2[PayloadType2["TokenTransfer"] = 0] = "TokenTransfer";
  PayloadType2[PayloadType2["SmartContract"] = 1] = "SmartContract";
  PayloadType2[PayloadType2["VersionedSmartContract"] = 6] = "VersionedSmartContract";
  PayloadType2[PayloadType2["ContractCall"] = 2] = "ContractCall";
  PayloadType2[PayloadType2["PoisonMicroblock"] = 3] = "PoisonMicroblock";
  PayloadType2[PayloadType2["Coinbase"] = 4] = "Coinbase";
  PayloadType2[PayloadType2["CoinbaseToAltRecipient"] = 5] = "CoinbaseToAltRecipient";
  PayloadType2[PayloadType2["TenureChange"] = 7] = "TenureChange";
  PayloadType2[PayloadType2["NakamotoCoinbase"] = 8] = "NakamotoCoinbase";
})(PayloadType || (PayloadType = {}));
var ClarityVersion;
(function(ClarityVersion2) {
  ClarityVersion2[ClarityVersion2["Clarity1"] = 1] = "Clarity1";
  ClarityVersion2[ClarityVersion2["Clarity2"] = 2] = "Clarity2";
  ClarityVersion2[ClarityVersion2["Clarity3"] = 3] = "Clarity3";
})(ClarityVersion || (ClarityVersion = {}));
var AnchorMode;
(function(AnchorMode2) {
  AnchorMode2[AnchorMode2["OnChainOnly"] = 1] = "OnChainOnly";
  AnchorMode2[AnchorMode2["OffChainOnly"] = 2] = "OffChainOnly";
  AnchorMode2[AnchorMode2["Any"] = 3] = "Any";
})(AnchorMode || (AnchorMode = {}));
var AnchorModeNames = ["onChainOnly", "offChainOnly", "any"];
var AnchorModeMap = {
  [AnchorModeNames[0]]: AnchorMode.OnChainOnly,
  [AnchorModeNames[1]]: AnchorMode.OffChainOnly,
  [AnchorModeNames[2]]: AnchorMode.Any,
  [AnchorMode.OnChainOnly]: AnchorMode.OnChainOnly,
  [AnchorMode.OffChainOnly]: AnchorMode.OffChainOnly,
  [AnchorMode.Any]: AnchorMode.Any
};
function anchorModeFromNameOrValue(mode) {
  if (mode in AnchorModeMap)
    return AnchorModeMap[mode];
  throw new Error(`Invalid anchor mode "${mode}", must be one of: ${AnchorModeNames.join(", ")}`);
}
var TransactionVersion2;
(function(TransactionVersion3) {
  TransactionVersion3[TransactionVersion3["Mainnet"] = 0] = "Mainnet";
  TransactionVersion3[TransactionVersion3["Testnet"] = 128] = "Testnet";
})(TransactionVersion2 || (TransactionVersion2 = {}));
var DEFAULT_TRANSACTION_VERSION = TransactionVersion2.Mainnet;
var PostConditionMode;
(function(PostConditionMode2) {
  PostConditionMode2[PostConditionMode2["Allow"] = 1] = "Allow";
  PostConditionMode2[PostConditionMode2["Deny"] = 2] = "Deny";
})(PostConditionMode || (PostConditionMode = {}));
var PostConditionType;
(function(PostConditionType2) {
  PostConditionType2[PostConditionType2["STX"] = 0] = "STX";
  PostConditionType2[PostConditionType2["Fungible"] = 1] = "Fungible";
  PostConditionType2[PostConditionType2["NonFungible"] = 2] = "NonFungible";
})(PostConditionType || (PostConditionType = {}));
var AuthType;
(function(AuthType2) {
  AuthType2[AuthType2["Standard"] = 4] = "Standard";
  AuthType2[AuthType2["Sponsored"] = 5] = "Sponsored";
})(AuthType || (AuthType = {}));
var AddressHashMode;
(function(AddressHashMode2) {
  AddressHashMode2[AddressHashMode2["SerializeP2PKH"] = 0] = "SerializeP2PKH";
  AddressHashMode2[AddressHashMode2["SerializeP2SH"] = 1] = "SerializeP2SH";
  AddressHashMode2[AddressHashMode2["SerializeP2WPKH"] = 2] = "SerializeP2WPKH";
  AddressHashMode2[AddressHashMode2["SerializeP2WSH"] = 3] = "SerializeP2WSH";
  AddressHashMode2[AddressHashMode2["SerializeP2SHNonSequential"] = 5] = "SerializeP2SHNonSequential";
  AddressHashMode2[AddressHashMode2["SerializeP2WSHNonSequential"] = 7] = "SerializeP2WSHNonSequential";
})(AddressHashMode || (AddressHashMode = {}));
var AddressVersion;
(function(AddressVersion2) {
  AddressVersion2[AddressVersion2["MainnetSingleSig"] = 22] = "MainnetSingleSig";
  AddressVersion2[AddressVersion2["MainnetMultiSig"] = 20] = "MainnetMultiSig";
  AddressVersion2[AddressVersion2["TestnetSingleSig"] = 26] = "TestnetSingleSig";
  AddressVersion2[AddressVersion2["TestnetMultiSig"] = 21] = "TestnetMultiSig";
})(AddressVersion || (AddressVersion = {}));
var PubKeyEncoding;
(function(PubKeyEncoding2) {
  PubKeyEncoding2[PubKeyEncoding2["Compressed"] = 0] = "Compressed";
  PubKeyEncoding2[PubKeyEncoding2["Uncompressed"] = 1] = "Uncompressed";
})(PubKeyEncoding || (PubKeyEncoding = {}));
var FungibleConditionCode;
(function(FungibleConditionCode2) {
  FungibleConditionCode2[FungibleConditionCode2["Equal"] = 1] = "Equal";
  FungibleConditionCode2[FungibleConditionCode2["Greater"] = 2] = "Greater";
  FungibleConditionCode2[FungibleConditionCode2["GreaterEqual"] = 3] = "GreaterEqual";
  FungibleConditionCode2[FungibleConditionCode2["Less"] = 4] = "Less";
  FungibleConditionCode2[FungibleConditionCode2["LessEqual"] = 5] = "LessEqual";
})(FungibleConditionCode || (FungibleConditionCode = {}));
var NonFungibleConditionCode;
(function(NonFungibleConditionCode2) {
  NonFungibleConditionCode2[NonFungibleConditionCode2["Sends"] = 16] = "Sends";
  NonFungibleConditionCode2[NonFungibleConditionCode2["DoesNotSend"] = 17] = "DoesNotSend";
})(NonFungibleConditionCode || (NonFungibleConditionCode = {}));
var PostConditionPrincipalID;
(function(PostConditionPrincipalID2) {
  PostConditionPrincipalID2[PostConditionPrincipalID2["Origin"] = 1] = "Origin";
  PostConditionPrincipalID2[PostConditionPrincipalID2["Standard"] = 2] = "Standard";
  PostConditionPrincipalID2[PostConditionPrincipalID2["Contract"] = 3] = "Contract";
})(PostConditionPrincipalID || (PostConditionPrincipalID = {}));
var AssetType;
(function(AssetType2) {
  AssetType2[AssetType2["STX"] = 0] = "STX";
  AssetType2[AssetType2["Fungible"] = 1] = "Fungible";
  AssetType2[AssetType2["NonFungible"] = 2] = "NonFungible";
})(AssetType || (AssetType = {}));
var TxRejectedReason;
(function(TxRejectedReason2) {
  TxRejectedReason2["Serialization"] = "Serialization";
  TxRejectedReason2["Deserialization"] = "Deserialization";
  TxRejectedReason2["SignatureValidation"] = "SignatureValidation";
  TxRejectedReason2["FeeTooLow"] = "FeeTooLow";
  TxRejectedReason2["BadNonce"] = "BadNonce";
  TxRejectedReason2["NotEnoughFunds"] = "NotEnoughFunds";
  TxRejectedReason2["NoSuchContract"] = "NoSuchContract";
  TxRejectedReason2["NoSuchPublicFunction"] = "NoSuchPublicFunction";
  TxRejectedReason2["BadFunctionArgument"] = "BadFunctionArgument";
  TxRejectedReason2["ContractAlreadyExists"] = "ContractAlreadyExists";
  TxRejectedReason2["PoisonMicroblocksDoNotConflict"] = "PoisonMicroblocksDoNotConflict";
  TxRejectedReason2["PoisonMicroblockHasUnknownPubKeyHash"] = "PoisonMicroblockHasUnknownPubKeyHash";
  TxRejectedReason2["PoisonMicroblockIsInvalid"] = "PoisonMicroblockIsInvalid";
  TxRejectedReason2["BadAddressVersionByte"] = "BadAddressVersionByte";
  TxRejectedReason2["NoCoinbaseViaMempool"] = "NoCoinbaseViaMempool";
  TxRejectedReason2["ServerFailureNoSuchChainTip"] = "ServerFailureNoSuchChainTip";
  TxRejectedReason2["TooMuchChaining"] = "TooMuchChaining";
  TxRejectedReason2["ConflictingNonceInMempool"] = "ConflictingNonceInMempool";
  TxRejectedReason2["BadTransactionVersion"] = "BadTransactionVersion";
  TxRejectedReason2["TransferRecipientCannotEqualSender"] = "TransferRecipientCannotEqualSender";
  TxRejectedReason2["TransferAmountMustBePositive"] = "TransferAmountMustBePositive";
  TxRejectedReason2["ServerFailureDatabase"] = "ServerFailureDatabase";
  TxRejectedReason2["EstimatorError"] = "EstimatorError";
  TxRejectedReason2["TemporarilyBlacklisted"] = "TemporarilyBlacklisted";
  TxRejectedReason2["ServerFailureOther"] = "ServerFailureOther";
})(TxRejectedReason || (TxRejectedReason = {}));

// node_modules/@stacks/transactions/dist/esm/utils.js
var import_c32check4 = __toESM(require_lib());
var import_lodash = __toESM(require_lodash());

// node_modules/@stacks/transactions/dist/esm/common.js
var import_c32check = __toESM(require_lib());
function createMessageSignature(signature) {
  const length = hexToBytes(signature).byteLength;
  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {
    throw Error("Invalid signature");
  }
  return {
    type: StacksMessageType.MessageSignature,
    data: signature
  };
}
function addressHashModeToVersion(hashMode, txVersion) {
  switch (hashMode) {
    case AddressHashMode.SerializeP2PKH:
      switch (txVersion) {
        case TransactionVersion2.Mainnet:
          return AddressVersion.MainnetSingleSig;
        case TransactionVersion2.Testnet:
          return AddressVersion.TestnetSingleSig;
        default:
          throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
      }
    case AddressHashMode.SerializeP2SH:
    case AddressHashMode.SerializeP2SHNonSequential:
    case AddressHashMode.SerializeP2WPKH:
    case AddressHashMode.SerializeP2WSH:
    case AddressHashMode.SerializeP2WSHNonSequential:
      switch (txVersion) {
        case TransactionVersion2.Mainnet:
          return AddressVersion.MainnetMultiSig;
        case TransactionVersion2.Testnet:
          return AddressVersion.TestnetMultiSig;
        default:
          throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
      }
    default:
      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);
  }
}
function addressFromVersionHash(version, hash) {
  return { type: StacksMessageType.Address, version, hash160: hash };
}
function addressToString(address2) {
  return (0, import_c32check.c32address)(address2.version, address2.hash160);
}

// node_modules/@stacks/transactions/dist/esm/postcondition-types.js
var import_c32check2 = __toESM(require_lib());
function parseAssetInfoString(id) {
  const [assetAddress, assetContractName, assetTokenName] = id.split(/\.|::/);
  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);
  return assetInfo;
}
function createLPString(content, lengthPrefixBytes, maxLengthBytes) {
  const prefixLength = lengthPrefixBytes || 1;
  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;
  if (exceedsMaxLengthBytes(content, maxLength)) {
    throw new Error(`String length exceeds maximum bytes ${maxLength}`);
  }
  return {
    type: StacksMessageType.LengthPrefixedString,
    content,
    lengthPrefixBytes: prefixLength,
    maxLengthBytes: maxLength
  };
}
function createAssetInfo(addressString, contractName, assetName) {
  return {
    type: StacksMessageType.AssetInfo,
    address: createAddress(addressString),
    contractName: createLPString(contractName),
    assetName: createLPString(assetName)
  };
}
function createAddress(c32AddressString) {
  const addressData = (0, import_c32check2.c32addressDecode)(c32AddressString);
  return {
    type: StacksMessageType.Address,
    version: addressData[0],
    hash160: addressData[1]
  };
}
function parsePrincipalString(principalString) {
  if (principalString.includes(".")) {
    const [address2, contractName] = principalString.split(".");
    return createContractPrincipal(address2, contractName);
  } else {
    return createStandardPrincipal(principalString);
  }
}
function createContractPrincipal(addressString, contractName) {
  const addr = createAddress(addressString);
  const name = createLPString(contractName);
  return {
    type: StacksMessageType.Principal,
    prefix: PostConditionPrincipalID.Contract,
    address: addr,
    contractName: name
  };
}
function createStandardPrincipal(addressString) {
  const addr = createAddress(addressString);
  return {
    type: StacksMessageType.Principal,
    prefix: PostConditionPrincipalID.Standard,
    address: addr
  };
}

// node_modules/@stacks/transactions/dist/esm/clarity/constants.js
var ClarityType;
(function(ClarityType2) {
  ClarityType2[ClarityType2["Int"] = 0] = "Int";
  ClarityType2[ClarityType2["UInt"] = 1] = "UInt";
  ClarityType2[ClarityType2["Buffer"] = 2] = "Buffer";
  ClarityType2[ClarityType2["BoolTrue"] = 3] = "BoolTrue";
  ClarityType2[ClarityType2["BoolFalse"] = 4] = "BoolFalse";
  ClarityType2[ClarityType2["PrincipalStandard"] = 5] = "PrincipalStandard";
  ClarityType2[ClarityType2["PrincipalContract"] = 6] = "PrincipalContract";
  ClarityType2[ClarityType2["ResponseOk"] = 7] = "ResponseOk";
  ClarityType2[ClarityType2["ResponseErr"] = 8] = "ResponseErr";
  ClarityType2[ClarityType2["OptionalNone"] = 9] = "OptionalNone";
  ClarityType2[ClarityType2["OptionalSome"] = 10] = "OptionalSome";
  ClarityType2[ClarityType2["List"] = 11] = "List";
  ClarityType2[ClarityType2["Tuple"] = 12] = "Tuple";
  ClarityType2[ClarityType2["StringASCII"] = 13] = "StringASCII";
  ClarityType2[ClarityType2["StringUTF8"] = 14] = "StringUTF8";
})(ClarityType || (ClarityType = {}));

// node_modules/@stacks/transactions/dist/esm/clarity/types/principalCV.js
function principalToString(principal3) {
  if (principal3.type === ClarityType.PrincipalStandard) {
    return addressToString(principal3.address);
  } else if (principal3.type === ClarityType.PrincipalContract) {
    const address2 = addressToString(principal3.address);
    return `${address2}.${principal3.contractName.content}`;
  } else {
    throw new Error(`Unexpected principal data: ${JSON.stringify(principal3)}`);
  }
}
function principalCV(principal3) {
  if (principal3.includes(".")) {
    const [address2, contractName] = principal3.split(".");
    return contractPrincipalCV(address2, contractName);
  } else {
    return standardPrincipalCV(principal3);
  }
}
function standardPrincipalCV(addressString) {
  const addr = createAddress(addressString);
  return { type: ClarityType.PrincipalStandard, address: addr };
}
function standardPrincipalCVFromAddress(address2) {
  return { type: ClarityType.PrincipalStandard, address: address2 };
}
function contractPrincipalCV(addressString, contractName) {
  const addr = createAddress(addressString);
  const lengthPrefixedContractName = createLPString(contractName);
  return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);
}
function contractPrincipalCVFromAddress(address2, contractName) {
  if (utf8ToBytes(contractName.content).byteLength >= 128) {
    throw new Error("Contract name must be less than 128 bytes");
  }
  return { type: ClarityType.PrincipalContract, address: address2, contractName };
}
function contractPrincipalCVFromStandard(sp, contractName) {
  const lengthPrefixedContractName = createLPString(contractName);
  return {
    type: ClarityType.PrincipalContract,
    address: sp.address,
    contractName: lengthPrefixedContractName
  };
}

// node_modules/@stacks/transactions/dist/esm/clarity/clarityValue.js
function cvToString(val, encoding = "hex") {
  switch (val.type) {
    case ClarityType.BoolTrue:
      return "true";
    case ClarityType.BoolFalse:
      return "false";
    case ClarityType.Int:
      return val.value.toString();
    case ClarityType.UInt:
      return `u${val.value.toString()}`;
    case ClarityType.Buffer:
      if (encoding === "tryAscii") {
        const str = bytesToAscii(val.buffer);
        if (/[ -~]/.test(str)) {
          return JSON.stringify(str);
        }
      }
      return `0x${bytesToHex(val.buffer)}`;
    case ClarityType.OptionalNone:
      return "none";
    case ClarityType.OptionalSome:
      return `(some ${cvToString(val.value, encoding)})`;
    case ClarityType.ResponseErr:
      return `(err ${cvToString(val.value, encoding)})`;
    case ClarityType.ResponseOk:
      return `(ok ${cvToString(val.value, encoding)})`;
    case ClarityType.PrincipalStandard:
    case ClarityType.PrincipalContract:
      return principalToString(val);
    case ClarityType.List:
      return `(list ${val.list.map((v) => cvToString(v, encoding)).join(" ")})`;
    case ClarityType.Tuple:
      return `(tuple ${Object.keys(val.data).map((key) => `(${key} ${cvToString(val.data[key], encoding)})`).join(" ")})`;
    case ClarityType.StringASCII:
      return `"${val.data}"`;
    case ClarityType.StringUTF8:
      return `u"${val.data}"`;
  }
}
function cvToValue(val, strictJsonCompat = false) {
  switch (val.type) {
    case ClarityType.BoolTrue:
      return true;
    case ClarityType.BoolFalse:
      return false;
    case ClarityType.Int:
    case ClarityType.UInt:
      if (strictJsonCompat) {
        return val.value.toString();
      }
      return val.value;
    case ClarityType.Buffer:
      return `0x${bytesToHex(val.buffer)}`;
    case ClarityType.OptionalNone:
      return null;
    case ClarityType.OptionalSome:
      return cvToJSON(val.value);
    case ClarityType.ResponseErr:
      return cvToJSON(val.value);
    case ClarityType.ResponseOk:
      return cvToJSON(val.value);
    case ClarityType.PrincipalStandard:
    case ClarityType.PrincipalContract:
      return principalToString(val);
    case ClarityType.List:
      return val.list.map((v) => cvToJSON(v));
    case ClarityType.Tuple:
      const result = {};
      Object.keys(val.data).forEach((key) => {
        result[key] = cvToJSON(val.data[key]);
      });
      return result;
    case ClarityType.StringASCII:
      return val.data;
    case ClarityType.StringUTF8:
      return val.data;
  }
}
function cvToJSON(val) {
  switch (val.type) {
    case ClarityType.ResponseErr:
      return { type: getCVTypeString(val), value: cvToValue(val, true), success: false };
    case ClarityType.ResponseOk:
      return { type: getCVTypeString(val), value: cvToValue(val, true), success: true };
    default:
      return { type: getCVTypeString(val), value: cvToValue(val, true) };
  }
}
function getCVTypeString(val) {
  switch (val.type) {
    case ClarityType.BoolTrue:
    case ClarityType.BoolFalse:
      return "bool";
    case ClarityType.Int:
      return "int";
    case ClarityType.UInt:
      return "uint";
    case ClarityType.Buffer:
      return `(buff ${val.buffer.length})`;
    case ClarityType.OptionalNone:
      return "(optional none)";
    case ClarityType.OptionalSome:
      return `(optional ${getCVTypeString(val.value)})`;
    case ClarityType.ResponseErr:
      return `(response UnknownType ${getCVTypeString(val.value)})`;
    case ClarityType.ResponseOk:
      return `(response ${getCVTypeString(val.value)} UnknownType)`;
    case ClarityType.PrincipalStandard:
    case ClarityType.PrincipalContract:
      return "principal";
    case ClarityType.List:
      return `(list ${val.list.length} ${val.list.length ? getCVTypeString(val.list[0]) : "UnknownType"})`;
    case ClarityType.Tuple:
      return `(tuple ${Object.keys(val.data).map((key) => `(${key} ${getCVTypeString(val.data[key])})`).join(" ")})`;
    case ClarityType.StringASCII:
      return `(string-ascii ${asciiToBytes(val.data).length})`;
    case ClarityType.StringUTF8:
      return `(string-utf8 ${utf8ToBytes(val.data).length})`;
  }
}
function isClarityType(input, withType) {
  return input.type === withType;
}

// node_modules/@stacks/transactions/dist/esm/clarity/types/booleanCV.js
var trueCV = () => ({ type: ClarityType.BoolTrue });
var falseCV = () => ({ type: ClarityType.BoolFalse });
var boolCV = (bool2) => bool2 ? trueCV() : falseCV();

// node_modules/@stacks/transactions/dist/esm/clarity/types/intCV.js
var MAX_U128 = BigInt("0xffffffffffffffffffffffffffffffff");
var MIN_U128 = BigInt(0);
var MAX_I128 = BigInt("0x7fffffffffffffffffffffffffffffff");
var MIN_I128 = BigInt("-170141183460469231731687303715884105728");
var intCV = (value) => {
  const bigInt = intToBigInt(value, true);
  if (bigInt > MAX_I128) {
    throw new RangeError(`Cannot construct clarity integer from value greater than ${MAX_I128}`);
  } else if (bigInt < MIN_I128) {
    throw new RangeError(`Cannot construct clarity integer form value less than ${MIN_I128}`);
  }
  return { type: ClarityType.Int, value: bigInt };
};
var uintCV = (value) => {
  const bigInt = intToBigInt(value, false);
  if (bigInt < MIN_U128) {
    throw new RangeError("Cannot construct unsigned clarity integer from negative value");
  } else if (bigInt > MAX_U128) {
    throw new RangeError(`Cannot construct unsigned clarity integer greater than ${MAX_U128}`);
  }
  return { type: ClarityType.UInt, value: bigInt };
};

// node_modules/@stacks/transactions/dist/esm/clarity/types/bufferCV.js
var bufferCV = (buffer2) => {
  if (buffer2.byteLength > 1048576) {
    throw new Error("Cannot construct clarity buffer that is greater than 1MB");
  }
  return { type: ClarityType.Buffer, buffer: buffer2 };
};
var bufferCVFromString = (str) => bufferCV(utf8ToBytes(str));

// node_modules/@stacks/transactions/dist/esm/clarity/types/optionalCV.js
function noneCV() {
  return { type: ClarityType.OptionalNone };
}
function someCV(value) {
  return { type: ClarityType.OptionalSome, value };
}
function optionalCVOf(value) {
  if (value) {
    return someCV(value);
  } else {
    return noneCV();
  }
}

// node_modules/@stacks/transactions/dist/esm/clarity/types/responseCV.js
function responseErrorCV(value) {
  return { type: ClarityType.ResponseErr, value };
}
function responseOkCV(value) {
  return { type: ClarityType.ResponseOk, value };
}

// node_modules/@stacks/transactions/dist/esm/clarity/types/listCV.js
function listCV(values) {
  return { type: ClarityType.List, list: values };
}

// node_modules/@stacks/transactions/dist/esm/clarity/types/tupleCV.js
function tupleCV(data) {
  for (const key in data) {
    if (!isClarityName(key)) {
      throw new Error(`"${key}" is not a valid Clarity name`);
    }
  }
  return { type: ClarityType.Tuple, data };
}

// node_modules/@stacks/transactions/dist/esm/clarity/types/stringCV.js
var stringAsciiCV = (data) => {
  return { type: ClarityType.StringASCII, data };
};
var stringUtf8CV = (data) => {
  return { type: ClarityType.StringUTF8, data };
};
var stringCV = (data, encoding) => {
  switch (encoding) {
    case "ascii":
      return stringAsciiCV(data);
    case "utf8":
      return stringUtf8CV(data);
  }
};

// node_modules/@stacks/transactions/dist/esm/keys.js
var import_c32check3 = __toESM(require_lib());
utils.hmacSha256Sync = (key, ...msgs) => {
  const h = hmac.create(sha256, key);
  msgs.forEach((msg) => h.update(msg));
  return h.digest();
};
function getAddressFromPrivateKey(privateKey, transactionVersion = TransactionVersion2.Mainnet) {
  const pubKey = pubKeyfromPrivKey(privateKey);
  return getAddressFromPublicKey(pubKey.data, transactionVersion);
}
function getAddressFromPublicKey(publicKey, transactionVersion = TransactionVersion2.Mainnet) {
  publicKey = typeof publicKey === "string" ? publicKey : bytesToHex(publicKey);
  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);
  const addr = addressFromVersionHash(addrVer, hashP2PKH(hexToBytes(publicKey)));
  const addrString = addressToString(addr);
  return addrString;
}
function createStacksPublicKey(key) {
  return {
    type: StacksMessageType.PublicKey,
    data: hexToBytes(key)
  };
}
function publicKeyFromSignatureVrs(messageHash, messageSignature, pubKeyEncoding = PubKeyEncoding.Compressed) {
  const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);
  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));
  const point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);
  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;
  return point.toHex(compressed);
}
function publicKeyFromSignatureRsv(messageHash, messageSignature, pubKeyEncoding = PubKeyEncoding.Compressed) {
  return publicKeyFromSignatureVrs(messageHash, { ...messageSignature, data: signatureRsvToVrs(messageSignature.data) }, pubKeyEncoding);
}
function publicKeyFromBytes(data) {
  return { type: StacksMessageType.PublicKey, data };
}
function isCompressed(key) {
  return !bytesToHex(key.data).startsWith("04");
}
function publicKeyToString(key) {
  return bytesToHex(key.data);
}
function serializePublicKey(key) {
  return key.data.slice();
}
function pubKeyfromPrivKey(privateKey) {
  const privKey = createStacksPrivateKey(privateKey);
  const publicKey = getPublicKey(privKey.data.slice(0, 32), privKey.compressed);
  return createStacksPublicKey(bytesToHex(publicKey));
}
function compressPublicKey(publicKey) {
  const hex = typeof publicKey === "string" ? publicKey : bytesToHex(publicKey);
  const compressed = Point.fromHex(hex).toHex(true);
  return createStacksPublicKey(compressed);
}
function uncompressPublicKey(publicKey) {
  const hex = typeof publicKey === "string" ? publicKey : bytesToHex(publicKey);
  const compressed = Point.fromHex(hex).toHex(false);
  return createStacksPublicKey(compressed);
}
function deserializePublicKey(bytesReader) {
  const fieldId = bytesReader.readUInt8();
  const keyLength = fieldId === 4 ? UNCOMPRESSED_PUBKEY_LENGTH_BYTES : COMPRESSED_PUBKEY_LENGTH_BYTES;
  return publicKeyFromBytes(concatArray([fieldId, bytesReader.readBytes(keyLength)]));
}
function createStacksPrivateKey(key) {
  const data = privateKeyToBytes(key);
  const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;
  return { data, compressed };
}
function makeRandomPrivKey() {
  return createStacksPrivateKey(utils.randomPrivateKey());
}
function signWithKey(privateKey, messageHash) {
  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {
    canonical: true,
    recovered: true
  });
  if (recoveryId == null) {
    throw new Error("No signature recoveryId received");
  }
  const recoveryIdHex = intToHex(recoveryId, 1);
  const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex();
  return createMessageSignature(recoverableSignatureString);
}
function signMessageHashRsv({ messageHash, privateKey }) {
  const messageSignature = signWithKey(privateKey, messageHash);
  return { ...messageSignature, data: signatureVrsToRsv(messageSignature.data) };
}
function getPublicKey2(privateKey) {
  return pubKeyfromPrivKey(privateKey.data);
}
function privateKeyToString(privateKey) {
  return bytesToHex(privateKey.data);
}
function publicKeyToAddress(version, publicKey) {
  return (0, import_c32check3.c32address)(version, bytesToHex(hash160(publicKey.data)));
}

// node_modules/@stacks/transactions/dist/esm/payload.js
function isTokenTransferPayload(p) {
  return p.payloadType === PayloadType.TokenTransfer;
}
function isContractCallPayload(p) {
  return p.payloadType === PayloadType.ContractCall;
}
function isSmartContractPayload(p) {
  return p.payloadType === PayloadType.SmartContract;
}
function isPoisonPayload(p) {
  return p.payloadType === PayloadType.PoisonMicroblock;
}
function isCoinbasePayload(p) {
  return p.payloadType === PayloadType.Coinbase;
}
function createTokenTransferPayload(recipient, amount, memo) {
  if (typeof recipient === "string") {
    recipient = principalCV(recipient);
  }
  if (typeof memo === "string") {
    memo = createMemoString(memo);
  }
  return {
    type: StacksMessageType.Payload,
    payloadType: PayloadType.TokenTransfer,
    recipient,
    amount: intToBigInt(amount, false),
    memo: memo ?? createMemoString("")
  };
}
function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {
  if (typeof contractAddress === "string") {
    contractAddress = createAddress(contractAddress);
  }
  if (typeof contractName === "string") {
    contractName = createLPString(contractName);
  }
  if (typeof functionName === "string") {
    functionName = createLPString(functionName);
  }
  return {
    type: StacksMessageType.Payload,
    payloadType: PayloadType.ContractCall,
    contractAddress,
    contractName,
    functionName,
    functionArgs
  };
}
function createSmartContractPayload(contractName, codeBody, clarityVersion) {
  if (typeof contractName === "string") {
    contractName = createLPString(contractName);
  }
  if (typeof codeBody === "string") {
    codeBody = codeBodyString(codeBody);
  }
  if (typeof clarityVersion === "number") {
    return {
      type: StacksMessageType.Payload,
      payloadType: PayloadType.VersionedSmartContract,
      clarityVersion,
      contractName,
      codeBody
    };
  }
  return {
    type: StacksMessageType.Payload,
    payloadType: PayloadType.SmartContract,
    contractName,
    codeBody
  };
}
function createPoisonPayload() {
  return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };
}
function createCoinbasePayload(coinbaseBytes, altRecipient) {
  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {
    throw Error(`Coinbase buffer size must be ${COINBASE_BYTES_LENGTH} bytes`);
  }
  if (altRecipient != void 0) {
    return {
      type: StacksMessageType.Payload,
      payloadType: PayloadType.CoinbaseToAltRecipient,
      coinbaseBytes,
      recipient: altRecipient
    };
  }
  return {
    type: StacksMessageType.Payload,
    payloadType: PayloadType.Coinbase,
    coinbaseBytes
  };
}
function createNakamotoCoinbasePayload(coinbaseBytes, recipient, vrfProof) {
  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {
    throw Error(`Coinbase buffer size must be ${COINBASE_BYTES_LENGTH} bytes`);
  }
  if (vrfProof.byteLength != VRF_PROOF_BYTES_LENGTH) {
    throw Error(`VRF proof buffer size must be ${VRF_PROOF_BYTES_LENGTH} bytes`);
  }
  return {
    type: StacksMessageType.Payload,
    payloadType: PayloadType.NakamotoCoinbase,
    coinbaseBytes,
    recipient: recipient.type === ClarityType.OptionalSome ? recipient.value : void 0,
    vrfProof
  };
}
var TenureChangeCause;
(function(TenureChangeCause2) {
  TenureChangeCause2[TenureChangeCause2["BlockFound"] = 0] = "BlockFound";
  TenureChangeCause2[TenureChangeCause2["Extended"] = 1] = "Extended";
})(TenureChangeCause || (TenureChangeCause = {}));
function createTenureChangePayload(tenureHash, previousTenureHash, burnViewHash, previousTenureEnd, previousTenureBlocks, cause, publicKeyHash) {
  return {
    type: StacksMessageType.Payload,
    payloadType: PayloadType.TenureChange,
    tenureHash,
    previousTenureHash,
    burnViewHash,
    previousTenureEnd,
    previousTenureBlocks,
    cause,
    publicKeyHash
  };
}
function serializePayload(payload) {
  const bytesArray = [];
  bytesArray.push(payload.payloadType);
  switch (payload.payloadType) {
    case PayloadType.TokenTransfer:
      bytesArray.push(serializeCV(payload.recipient));
      bytesArray.push(intToBytes(payload.amount, false, 8));
      bytesArray.push(serializeStacksMessage(payload.memo));
      break;
    case PayloadType.ContractCall:
      bytesArray.push(serializeStacksMessage(payload.contractAddress));
      bytesArray.push(serializeStacksMessage(payload.contractName));
      bytesArray.push(serializeStacksMessage(payload.functionName));
      const numArgs = new Uint8Array(4);
      writeUInt32BE(numArgs, payload.functionArgs.length, 0);
      bytesArray.push(numArgs);
      payload.functionArgs.forEach((arg) => {
        bytesArray.push(serializeCV(arg));
      });
      break;
    case PayloadType.SmartContract:
      bytesArray.push(serializeStacksMessage(payload.contractName));
      bytesArray.push(serializeStacksMessage(payload.codeBody));
      break;
    case PayloadType.VersionedSmartContract:
      bytesArray.push(payload.clarityVersion);
      bytesArray.push(serializeStacksMessage(payload.contractName));
      bytesArray.push(serializeStacksMessage(payload.codeBody));
      break;
    case PayloadType.PoisonMicroblock:
      break;
    case PayloadType.Coinbase:
      bytesArray.push(payload.coinbaseBytes);
      break;
    case PayloadType.CoinbaseToAltRecipient:
      bytesArray.push(payload.coinbaseBytes);
      bytesArray.push(serializeCV(payload.recipient));
      break;
    case PayloadType.NakamotoCoinbase:
      bytesArray.push(payload.coinbaseBytes);
      bytesArray.push(serializeCV(payload.recipient ? someCV(payload.recipient) : noneCV()));
      bytesArray.push(payload.vrfProof);
      break;
    case PayloadType.TenureChange:
      bytesArray.push(hexToBytes(payload.tenureHash));
      bytesArray.push(hexToBytes(payload.previousTenureHash));
      bytesArray.push(hexToBytes(payload.burnViewHash));
      bytesArray.push(hexToBytes(payload.previousTenureEnd));
      bytesArray.push(writeUInt32BE(new Uint8Array(4), payload.previousTenureBlocks));
      bytesArray.push(writeUInt8(new Uint8Array(1), payload.cause));
      bytesArray.push(hexToBytes(payload.publicKeyHash));
      break;
  }
  return concatArray(bytesArray);
}
function deserializePayload(bytesReader) {
  const payloadType = bytesReader.readUInt8Enum(PayloadType, (n) => {
    throw new Error(`Cannot recognize PayloadType: ${n}`);
  });
  switch (payloadType) {
    case PayloadType.TokenTransfer:
      const recipient = deserializeCV(bytesReader);
      const amount = intToBigInt(bytesReader.readBytes(8), false);
      const memo = deserializeMemoString(bytesReader);
      return createTokenTransferPayload(recipient, amount, memo);
    case PayloadType.ContractCall:
      const contractAddress = deserializeAddress(bytesReader);
      const contractCallName = deserializeLPString(bytesReader);
      const functionName = deserializeLPString(bytesReader);
      const functionArgs = [];
      const numberOfArgs = bytesReader.readUInt32BE();
      for (let i = 0; i < numberOfArgs; i++) {
        const clarityValue = deserializeCV(bytesReader);
        functionArgs.push(clarityValue);
      }
      return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);
    case PayloadType.SmartContract:
      const smartContractName = deserializeLPString(bytesReader);
      const codeBody = deserializeLPString(bytesReader, 4, 1e5);
      return createSmartContractPayload(smartContractName, codeBody);
    case PayloadType.VersionedSmartContract: {
      const clarityVersion = bytesReader.readUInt8Enum(ClarityVersion, (n) => {
        throw new Error(`Cannot recognize ClarityVersion: ${n}`);
      });
      const smartContractName2 = deserializeLPString(bytesReader);
      const codeBody2 = deserializeLPString(bytesReader, 4, 1e5);
      return createSmartContractPayload(smartContractName2, codeBody2, clarityVersion);
    }
    case PayloadType.PoisonMicroblock:
      return createPoisonPayload();
    case PayloadType.Coinbase: {
      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);
      return createCoinbasePayload(coinbaseBytes);
    }
    case PayloadType.CoinbaseToAltRecipient: {
      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);
      const altRecipient = deserializeCV(bytesReader);
      return createCoinbasePayload(coinbaseBytes, altRecipient);
    }
    case PayloadType.NakamotoCoinbase: {
      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);
      const recipient2 = deserializeCV(bytesReader);
      const vrfProof = bytesReader.readBytes(VRF_PROOF_BYTES_LENGTH);
      return createNakamotoCoinbasePayload(coinbaseBytes, recipient2, vrfProof);
    }
    case PayloadType.TenureChange:
      const tenureHash = bytesToHex(bytesReader.readBytes(20));
      const previousTenureHash = bytesToHex(bytesReader.readBytes(20));
      const burnViewHash = bytesToHex(bytesReader.readBytes(20));
      const previousTenureEnd = bytesToHex(bytesReader.readBytes(32));
      const previousTenureBlocks = bytesReader.readUInt32BE();
      const cause = bytesReader.readUInt8Enum(TenureChangeCause, (n) => {
        throw new Error(`Cannot recognize TenureChangeCause: ${n}`);
      });
      const publicKeyHash = bytesToHex(bytesReader.readBytes(20));
      return createTenureChangePayload(tenureHash, previousTenureHash, burnViewHash, previousTenureEnd, previousTenureBlocks, cause, publicKeyHash);
  }
}

// node_modules/@stacks/transactions/dist/esm/errors.js
var TransactionError = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = this.constructor.name;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var SerializationError = class extends TransactionError {
  constructor(message) {
    super(message);
  }
};
var DeserializationError = class extends TransactionError {
  constructor(message) {
    super(message);
  }
};
var NoEstimateAvailableError = class extends TransactionError {
  constructor(message) {
    super(message);
  }
};
var NotImplementedError = class extends TransactionError {
  constructor(message) {
    super(message);
  }
};
var SigningError = class extends TransactionError {
  constructor(message) {
    super(message);
  }
};
var VerificationError = class extends TransactionError {
  constructor(message) {
    super(message);
  }
};

// node_modules/@stacks/transactions/dist/esm/signature.js
var AuthFieldType;
(function(AuthFieldType2) {
  AuthFieldType2[AuthFieldType2["PublicKeyCompressed"] = 0] = "PublicKeyCompressed";
  AuthFieldType2[AuthFieldType2["PublicKeyUncompressed"] = 1] = "PublicKeyUncompressed";
  AuthFieldType2[AuthFieldType2["SignatureCompressed"] = 2] = "SignatureCompressed";
  AuthFieldType2[AuthFieldType2["SignatureUncompressed"] = 3] = "SignatureUncompressed";
})(AuthFieldType || (AuthFieldType = {}));
function deserializeMessageSignature(bytesReader) {
  return createMessageSignature(bytesToHex(bytesReader.readBytes(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)));
}
function createTransactionAuthField(pubKeyEncoding, contents) {
  return {
    pubKeyEncoding,
    type: StacksMessageType.TransactionAuthField,
    contents
  };
}
function deserializeTransactionAuthField(bytesReader) {
  const authFieldType = bytesReader.readUInt8Enum(AuthFieldType, (n) => {
    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);
  });
  switch (authFieldType) {
    case AuthFieldType.PublicKeyCompressed:
      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bytesReader));
    case AuthFieldType.PublicKeyUncompressed:
      return createTransactionAuthField(PubKeyEncoding.Uncompressed, uncompressPublicKey(deserializePublicKey(bytesReader).data));
    case AuthFieldType.SignatureCompressed:
      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bytesReader));
    case AuthFieldType.SignatureUncompressed:
      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bytesReader));
    default:
      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);
  }
}
function serializeMessageSignature(messageSignature) {
  return hexToBytes(messageSignature.data);
}
function serializeTransactionAuthField(field) {
  const bytesArray = [];
  switch (field.contents.type) {
    case StacksMessageType.PublicKey:
      bytesArray.push(field.pubKeyEncoding === PubKeyEncoding.Compressed ? AuthFieldType.PublicKeyCompressed : AuthFieldType.PublicKeyUncompressed);
      bytesArray.push(serializePublicKey(compressPublicKey(field.contents.data)));
      break;
    case StacksMessageType.MessageSignature:
      bytesArray.push(field.pubKeyEncoding === PubKeyEncoding.Compressed ? AuthFieldType.SignatureCompressed : AuthFieldType.SignatureUncompressed);
      bytesArray.push(serializeMessageSignature(field.contents));
      break;
  }
  return concatArray(bytesArray);
}

// node_modules/@stacks/transactions/dist/esm/types.js
function serializeStacksMessage(message) {
  switch (message.type) {
    case StacksMessageType.Address:
      return serializeAddress(message);
    case StacksMessageType.Principal:
      return serializePrincipal(message);
    case StacksMessageType.LengthPrefixedString:
      return serializeLPString(message);
    case StacksMessageType.MemoString:
      return serializeMemoString(message);
    case StacksMessageType.AssetInfo:
      return serializeAssetInfo(message);
    case StacksMessageType.PostCondition:
      return serializePostCondition(message);
    case StacksMessageType.PublicKey:
      return serializePublicKey(message);
    case StacksMessageType.LengthPrefixedList:
      return serializeLPList(message);
    case StacksMessageType.Payload:
      return serializePayload(message);
    case StacksMessageType.TransactionAuthField:
      return serializeTransactionAuthField(message);
    case StacksMessageType.MessageSignature:
      return serializeMessageSignature(message);
  }
}
function deserializeStacksMessage(bytesReader, type, listType) {
  switch (type) {
    case StacksMessageType.Address:
      return deserializeAddress(bytesReader);
    case StacksMessageType.Principal:
      return deserializePrincipal(bytesReader);
    case StacksMessageType.LengthPrefixedString:
      return deserializeLPString(bytesReader);
    case StacksMessageType.MemoString:
      return deserializeMemoString(bytesReader);
    case StacksMessageType.AssetInfo:
      return deserializeAssetInfo(bytesReader);
    case StacksMessageType.PostCondition:
      return deserializePostCondition(bytesReader);
    case StacksMessageType.PublicKey:
      return deserializePublicKey(bytesReader);
    case StacksMessageType.Payload:
      return deserializePayload(bytesReader);
    case StacksMessageType.LengthPrefixedList:
      if (!listType) {
        throw new DeserializationError("No List Type specified");
      }
      return deserializeLPList(bytesReader, listType);
    case StacksMessageType.MessageSignature:
      return deserializeMessageSignature(bytesReader);
    default:
      throw new Error("Could not recognize StacksMessageType");
  }
}
function createEmptyAddress() {
  return {
    type: StacksMessageType.Address,
    version: AddressVersion.MainnetSingleSig,
    hash160: "0".repeat(40)
  };
}
function addressFromHashMode(hashMode, txVersion, data) {
  const version = addressHashModeToVersion(hashMode, txVersion);
  return addressFromVersionHash(version, data);
}
function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {
  if (publicKeys.length === 0) {
    throw Error("Invalid number of public keys");
  }
  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {
    if (publicKeys.length !== 1 || numSigs !== 1) {
      throw Error("Invalid number of public keys or signatures");
    }
  }
  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH || hashMode === AddressHashMode.SerializeP2WSHNonSequential) {
    if (!publicKeys.every(isCompressed)) {
      throw Error("Public keys must be compressed for segwit");
    }
  }
  switch (hashMode) {
    case AddressHashMode.SerializeP2PKH:
      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));
    case AddressHashMode.SerializeP2WPKH:
      return addressFromVersionHash(version, hashP2WPKH(publicKeys[0].data));
    case AddressHashMode.SerializeP2SH:
    case AddressHashMode.SerializeP2SHNonSequential:
      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));
    case AddressHashMode.SerializeP2WSH:
    case AddressHashMode.SerializeP2WSHNonSequential:
      return addressFromVersionHash(version, hashP2WSH(numSigs, publicKeys.map(serializePublicKey)));
  }
}
function serializeAddress(address2) {
  const bytesArray = [];
  bytesArray.push(hexToBytes(intToHex(address2.version, 1)));
  bytesArray.push(hexToBytes(address2.hash160));
  return concatArray(bytesArray);
}
function deserializeAddress(bytesReader) {
  const version = hexToInt(bytesToHex(bytesReader.readBytes(1)));
  const data = bytesToHex(bytesReader.readBytes(20));
  return { type: StacksMessageType.Address, version, hash160: data };
}
function serializePrincipal(principal3) {
  const bytesArray = [];
  bytesArray.push(principal3.prefix);
  bytesArray.push(serializeAddress(principal3.address));
  if (principal3.prefix === PostConditionPrincipalID.Contract) {
    bytesArray.push(serializeLPString(principal3.contractName));
  }
  return concatArray(bytesArray);
}
function deserializePrincipal(bytesReader) {
  const prefix = bytesReader.readUInt8Enum(PostConditionPrincipalID, (n) => {
    throw new DeserializationError(`Unexpected Principal payload type: ${n}`);
  });
  const address2 = deserializeAddress(bytesReader);
  if (prefix === PostConditionPrincipalID.Standard) {
    return { type: StacksMessageType.Principal, prefix, address: address2 };
  }
  const contractName = deserializeLPString(bytesReader);
  return {
    type: StacksMessageType.Principal,
    prefix,
    address: address2,
    contractName
  };
}
function serializeLPString(lps) {
  const bytesArray = [];
  const contentBytes = utf8ToBytes(lps.content);
  const length = contentBytes.byteLength;
  bytesArray.push(hexToBytes(intToHex(length, lps.lengthPrefixBytes)));
  bytesArray.push(contentBytes);
  return concatArray(bytesArray);
}
function deserializeLPString(bytesReader, prefixBytes, maxLength) {
  prefixBytes = prefixBytes ? prefixBytes : 1;
  const length = hexToInt(bytesToHex(bytesReader.readBytes(prefixBytes)));
  const content = bytesToUtf8(bytesReader.readBytes(length));
  return createLPString(content, prefixBytes, maxLength ?? 128);
}
function codeBodyString(content) {
  return createLPString(content, 4, 1e5);
}
function createMemoString(content) {
  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {
    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES} bytes`);
  }
  return { type: StacksMessageType.MemoString, content };
}
function serializeMemoString(memoString) {
  const bytesArray = [];
  const contentBytes = utf8ToBytes(memoString.content);
  const paddedContent = rightPadHexToLength(bytesToHex(contentBytes), MEMO_MAX_LENGTH_BYTES * 2);
  bytesArray.push(hexToBytes(paddedContent));
  return concatArray(bytesArray);
}
function deserializeMemoString(bytesReader) {
  let content = bytesToUtf8(bytesReader.readBytes(MEMO_MAX_LENGTH_BYTES));
  content = content.replace(/\u0000*$/, "");
  return { type: StacksMessageType.MemoString, content };
}
function serializeAssetInfo(info) {
  const bytesArray = [];
  bytesArray.push(serializeAddress(info.address));
  bytesArray.push(serializeLPString(info.contractName));
  bytesArray.push(serializeLPString(info.assetName));
  return concatArray(bytesArray);
}
function deserializeAssetInfo(bytesReader) {
  return {
    type: StacksMessageType.AssetInfo,
    address: deserializeAddress(bytesReader),
    contractName: deserializeLPString(bytesReader),
    assetName: deserializeLPString(bytesReader)
  };
}
function createLPList(values, lengthPrefixBytes) {
  return {
    type: StacksMessageType.LengthPrefixedList,
    lengthPrefixBytes: lengthPrefixBytes || 4,
    values
  };
}
function serializeLPList(lpList) {
  const list2 = lpList.values;
  const bytesArray = [];
  bytesArray.push(hexToBytes(intToHex(list2.length, lpList.lengthPrefixBytes)));
  for (const l of list2) {
    bytesArray.push(serializeStacksMessage(l));
  }
  return concatArray(bytesArray);
}
function deserializeLPList(bytesReader, type, lengthPrefixBytes) {
  const length = hexToInt(bytesToHex(bytesReader.readBytes(lengthPrefixBytes || 4)));
  const l = [];
  for (let index = 0; index < length; index++) {
    switch (type) {
      case StacksMessageType.Address:
        l.push(deserializeAddress(bytesReader));
        break;
      case StacksMessageType.LengthPrefixedString:
        l.push(deserializeLPString(bytesReader));
        break;
      case StacksMessageType.MemoString:
        l.push(deserializeMemoString(bytesReader));
        break;
      case StacksMessageType.AssetInfo:
        l.push(deserializeAssetInfo(bytesReader));
        break;
      case StacksMessageType.PostCondition:
        l.push(deserializePostCondition(bytesReader));
        break;
      case StacksMessageType.PublicKey:
        l.push(deserializePublicKey(bytesReader));
        break;
      case StacksMessageType.TransactionAuthField:
        l.push(deserializeTransactionAuthField(bytesReader));
        break;
    }
  }
  return createLPList(l, lengthPrefixBytes);
}
function serializePostCondition(postCondition) {
  const bytesArray = [];
  bytesArray.push(postCondition.conditionType);
  bytesArray.push(serializePrincipal(postCondition.principal));
  if (postCondition.conditionType === PostConditionType.Fungible || postCondition.conditionType === PostConditionType.NonFungible) {
    bytesArray.push(serializeAssetInfo(postCondition.assetInfo));
  }
  if (postCondition.conditionType === PostConditionType.NonFungible) {
    bytesArray.push(serializeCV(postCondition.assetName));
  }
  bytesArray.push(postCondition.conditionCode);
  if (postCondition.conditionType === PostConditionType.STX || postCondition.conditionType === PostConditionType.Fungible) {
    if (postCondition.amount > BigInt("0xffffffffffffffff"))
      throw new SerializationError("The post-condition amount may not be larger than 8 bytes");
    bytesArray.push(intToBytes(postCondition.amount, false, 8));
  }
  return concatArray(bytesArray);
}
function deserializePostCondition(bytesReader) {
  const postConditionType = bytesReader.readUInt8Enum(PostConditionType, (n) => {
    throw new DeserializationError(`Could not read ${n} as PostConditionType`);
  });
  const principal3 = deserializePrincipal(bytesReader);
  let conditionCode;
  let assetInfo;
  let amount;
  switch (postConditionType) {
    case PostConditionType.STX:
      conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, (n) => {
        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);
      });
      amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
      return {
        type: StacksMessageType.PostCondition,
        conditionType: PostConditionType.STX,
        principal: principal3,
        conditionCode,
        amount
      };
    case PostConditionType.Fungible:
      assetInfo = deserializeAssetInfo(bytesReader);
      conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, (n) => {
        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);
      });
      amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
      return {
        type: StacksMessageType.PostCondition,
        conditionType: PostConditionType.Fungible,
        principal: principal3,
        conditionCode,
        amount,
        assetInfo
      };
    case PostConditionType.NonFungible:
      assetInfo = deserializeAssetInfo(bytesReader);
      const assetName = deserializeCV(bytesReader);
      conditionCode = bytesReader.readUInt8Enum(NonFungibleConditionCode, (n) => {
        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);
      });
      return {
        type: StacksMessageType.PostCondition,
        conditionType: PostConditionType.NonFungible,
        principal: principal3,
        conditionCode,
        assetInfo,
        assetName
      };
  }
}

// node_modules/@stacks/transactions/dist/esm/clarity/serialize.js
function bytesWithTypeID(typeId, bytes) {
  return concatArray([typeId, bytes]);
}
function serializeBoolCV(value) {
  return new Uint8Array([value.type]);
}
function serializeOptionalCV(cv) {
  if (cv.type === ClarityType.OptionalNone) {
    return new Uint8Array([cv.type]);
  } else {
    return bytesWithTypeID(cv.type, serializeCV(cv.value));
  }
}
function serializeBufferCV(cv) {
  const length = new Uint8Array(4);
  writeUInt32BE(length, cv.buffer.length, 0);
  return bytesWithTypeID(cv.type, concatBytes(length, cv.buffer));
}
function serializeIntCV(cv) {
  const bytes = bigIntToBytes(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);
  return bytesWithTypeID(cv.type, bytes);
}
function serializeUIntCV(cv) {
  const bytes = bigIntToBytes(cv.value, CLARITY_INT_BYTE_SIZE);
  return bytesWithTypeID(cv.type, bytes);
}
function serializeStandardPrincipalCV(cv) {
  return bytesWithTypeID(cv.type, serializeAddress(cv.address));
}
function serializeContractPrincipalCV(cv) {
  return bytesWithTypeID(cv.type, concatBytes(serializeAddress(cv.address), serializeLPString(cv.contractName)));
}
function serializeResponseCV(cv) {
  return bytesWithTypeID(cv.type, serializeCV(cv.value));
}
function serializeListCV(cv) {
  const bytesArray = [];
  const length = new Uint8Array(4);
  writeUInt32BE(length, cv.list.length, 0);
  bytesArray.push(length);
  for (const value of cv.list) {
    const serializedValue = serializeCV(value);
    bytesArray.push(serializedValue);
  }
  return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeTupleCV(cv) {
  const bytesArray = [];
  const length = new Uint8Array(4);
  writeUInt32BE(length, Object.keys(cv.data).length, 0);
  bytesArray.push(length);
  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => a.localeCompare(b));
  for (const key of lexicographicOrder) {
    const nameWithLength = createLPString(key);
    bytesArray.push(serializeLPString(nameWithLength));
    const serializedValue = serializeCV(cv.data[key]);
    bytesArray.push(serializedValue);
  }
  return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeStringCV(cv, encoding) {
  const bytesArray = [];
  const str = encoding == "ascii" ? asciiToBytes(cv.data) : utf8ToBytes(cv.data);
  const len = new Uint8Array(4);
  writeUInt32BE(len, str.length, 0);
  bytesArray.push(len);
  bytesArray.push(str);
  return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeStringAsciiCV(cv) {
  return serializeStringCV(cv, "ascii");
}
function serializeStringUtf8CV(cv) {
  return serializeStringCV(cv, "utf8");
}
function serializeCV(value) {
  switch (value.type) {
    case ClarityType.BoolTrue:
    case ClarityType.BoolFalse:
      return serializeBoolCV(value);
    case ClarityType.OptionalNone:
    case ClarityType.OptionalSome:
      return serializeOptionalCV(value);
    case ClarityType.Buffer:
      return serializeBufferCV(value);
    case ClarityType.UInt:
      return serializeUIntCV(value);
    case ClarityType.Int:
      return serializeIntCV(value);
    case ClarityType.PrincipalStandard:
      return serializeStandardPrincipalCV(value);
    case ClarityType.PrincipalContract:
      return serializeContractPrincipalCV(value);
    case ClarityType.ResponseOk:
    case ClarityType.ResponseErr:
      return serializeResponseCV(value);
    case ClarityType.List:
      return serializeListCV(value);
    case ClarityType.Tuple:
      return serializeTupleCV(value);
    case ClarityType.StringASCII:
      return serializeStringAsciiCV(value);
    case ClarityType.StringUTF8:
      return serializeStringUtf8CV(value);
    default:
      throw new SerializationError("Unable to serialize. Invalid Clarity Value.");
  }
}

// node_modules/@stacks/transactions/dist/esm/bytesReader.js
function createEnumChecker(enumVariable) {
  const enumValues = Object.values(enumVariable).filter((v) => typeof v === "number");
  const enumValueSet = new Set(enumValues);
  return (value) => enumValueSet.has(value);
}
var enumCheckFunctions = /* @__PURE__ */ new Map();
function isEnum(enumVariable, value) {
  const checker = enumCheckFunctions.get(enumVariable);
  if (checker !== void 0) {
    return checker(value);
  }
  const newChecker = createEnumChecker(enumVariable);
  enumCheckFunctions.set(enumVariable, newChecker);
  return isEnum(enumVariable, value);
}
var BytesReader = class {
  constructor(arr) {
    this.consumed = 0;
    this.source = arr;
  }
  readBytes(length) {
    const view = this.source.subarray(this.consumed, this.consumed + length);
    this.consumed += length;
    return view;
  }
  readUInt32BE() {
    return readUInt32BE(this.readBytes(4), 0);
  }
  readUInt8() {
    return readUInt8(this.readBytes(1), 0);
  }
  readUInt16BE() {
    return readUInt16BE(this.readBytes(2), 0);
  }
  readBigUIntLE(length) {
    const bytes = this.readBytes(length).slice().reverse();
    const hex = bytesToHex(bytes);
    return BigInt(`0x${hex}`);
  }
  readBigUIntBE(length) {
    const bytes = this.readBytes(length);
    const hex = bytesToHex(bytes);
    return BigInt(`0x${hex}`);
  }
  get readOffset() {
    return this.consumed;
  }
  set readOffset(val) {
    this.consumed = val;
  }
  get internalBytes() {
    return this.source;
  }
  readUInt8Enum(enumVariable, invalidEnumErrorFormatter) {
    const num = this.readUInt8();
    if (isEnum(enumVariable, num)) {
      return num;
    }
    throw invalidEnumErrorFormatter(num);
  }
};

// node_modules/@stacks/transactions/dist/esm/clarity/deserialize.js
function deserializeCV(serializedClarityValue) {
  let bytesReader;
  if (typeof serializedClarityValue === "string") {
    const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === "0x";
    bytesReader = new BytesReader(hexToBytes(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue));
  } else if (serializedClarityValue instanceof Uint8Array) {
    bytesReader = new BytesReader(serializedClarityValue);
  } else {
    bytesReader = serializedClarityValue;
  }
  const type = bytesReader.readUInt8Enum(ClarityType, (n) => {
    throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);
  });
  switch (type) {
    case ClarityType.Int:
      return intCV(bytesReader.readBytes(16));
    case ClarityType.UInt:
      return uintCV(bytesReader.readBytes(16));
    case ClarityType.Buffer:
      const bufferLength = bytesReader.readUInt32BE();
      return bufferCV(bytesReader.readBytes(bufferLength));
    case ClarityType.BoolTrue:
      return trueCV();
    case ClarityType.BoolFalse:
      return falseCV();
    case ClarityType.PrincipalStandard:
      const sAddress = deserializeAddress(bytesReader);
      return standardPrincipalCVFromAddress(sAddress);
    case ClarityType.PrincipalContract:
      const cAddress = deserializeAddress(bytesReader);
      const contractName = deserializeLPString(bytesReader);
      return contractPrincipalCVFromAddress(cAddress, contractName);
    case ClarityType.ResponseOk:
      return responseOkCV(deserializeCV(bytesReader));
    case ClarityType.ResponseErr:
      return responseErrorCV(deserializeCV(bytesReader));
    case ClarityType.OptionalNone:
      return noneCV();
    case ClarityType.OptionalSome:
      return someCV(deserializeCV(bytesReader));
    case ClarityType.List:
      const listLength = bytesReader.readUInt32BE();
      const listContents = [];
      for (let i = 0; i < listLength; i++) {
        listContents.push(deserializeCV(bytesReader));
      }
      return listCV(listContents);
    case ClarityType.Tuple:
      const tupleLength = bytesReader.readUInt32BE();
      const tupleContents = {};
      for (let i = 0; i < tupleLength; i++) {
        const clarityName = deserializeLPString(bytesReader).content;
        if (clarityName === void 0) {
          throw new DeserializationError('"content" is undefined');
        }
        tupleContents[clarityName] = deserializeCV(bytesReader);
      }
      return tupleCV(tupleContents);
    case ClarityType.StringASCII:
      const asciiStrLen = bytesReader.readUInt32BE();
      const asciiStr = bytesToAscii(bytesReader.readBytes(asciiStrLen));
      return stringAsciiCV(asciiStr);
    case ClarityType.StringUTF8:
      const utf8StrLen = bytesReader.readUInt32BE();
      const utf8Str = bytesToUtf8(bytesReader.readBytes(utf8StrLen));
      return stringUtf8CV(utf8Str);
    default:
      throw new DeserializationError("Unable to deserialize Clarity Value from Uint8Array. Could not find valid Clarity Type.");
  }
}

// node_modules/@stacks/transactions/dist/esm/utils.js
var randomBytes = (bytesLength) => utils.randomBytes(bytesLength);
var leftPadHex = (hexString) => hexString.length % 2 == 0 ? hexString : `0${hexString}`;
var leftPadHexToLength = (hexString, length) => hexString.padStart(length, "0");
var rightPadHexToLength = (hexString, length) => hexString.padEnd(length, "0");
var exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? utf8ToBytes(string).length > maxLengthBytes : false;
function cloneDeep(obj) {
  return (0, import_lodash.default)(obj);
}
function omit(obj, prop) {
  const clone = cloneDeep(obj);
  delete clone[prop];
  return clone;
}
var hash160 = (input) => {
  return ripemd160(sha256(input));
};
var txidFromData = (data) => {
  return bytesToHex(sha512_256(data));
};
var txidFromBytes = txidFromData;
var hashP2PKH = (input) => {
  return bytesToHex(hash160(input));
};
var hashP2WPKH = (input) => {
  const keyHash = hash160(input);
  const redeemScript = concatBytes(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);
  const redeemScriptHash = hash160(redeemScript);
  return bytesToHex(redeemScriptHash);
};
var hashP2SH = (numSigs, pubKeys) => {
  if (numSigs > 15 || pubKeys.length > 15) {
    throw Error("P2SH multisig address can only contain up to 15 public keys");
  }
  const bytesArray = [];
  bytesArray.push(80 + numSigs);
  pubKeys.forEach((pubKey) => {
    bytesArray.push(pubKey.length);
    bytesArray.push(pubKey);
  });
  bytesArray.push(80 + pubKeys.length);
  bytesArray.push(174);
  const redeemScript = concatArray(bytesArray);
  const redeemScriptHash = hash160(redeemScript);
  return bytesToHex(redeemScriptHash);
};
var hashP2WSH = (numSigs, pubKeys) => {
  if (numSigs > 15 || pubKeys.length > 15) {
    throw Error("P2WSH multisig address can only contain up to 15 public keys");
  }
  const scriptArray = [];
  scriptArray.push(80 + numSigs);
  pubKeys.forEach((pubKey) => {
    scriptArray.push(pubKey.length);
    scriptArray.push(pubKey);
  });
  scriptArray.push(80 + pubKeys.length);
  scriptArray.push(174);
  const script = concatArray(scriptArray);
  const digest = sha256(script);
  const bytesArray = [];
  bytesArray.push(0);
  bytesArray.push(digest.length);
  bytesArray.push(digest);
  const redeemScript = concatArray(bytesArray);
  const redeemScriptHash = hash160(redeemScript);
  return bytesToHex(redeemScriptHash);
};
function isClarityName(name) {
  const regex2 = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;
  return regex2.test(name) && name.length < 128;
}
function cvToHex(cv) {
  const serialized = serializeCV(cv);
  return `0x${bytesToHex(serialized)}`;
}
function hexToCV(hex) {
  return deserializeCV(hex);
}
var parseReadOnlyResponse = (response) => {
  if (response.okay)
    return hexToCV(response.result);
  throw new Error(response.cause);
};
var validateStacksAddress = (stacksAddress) => {
  try {
    (0, import_c32check4.c32addressDecode)(stacksAddress);
    return true;
  } catch (e) {
    return false;
  }
};
var validateTxId = (txid) => {
  if (txid === "success")
    return true;
  const value = with0x(txid).toLowerCase();
  if (value.length !== 66)
    return false;
  return with0x(BigInt(value).toString(16).padStart(64, "0")) === value;
};

// node_modules/@stacks/transactions/dist/esm/authorization.js
function emptyMessageSignature() {
  return {
    type: StacksMessageType.MessageSignature,
    data: bytesToHex(new Uint8Array(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES))
  };
}
function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {
  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;
  const keyEncoding = isCompressed(createStacksPublicKey(pubKey)) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;
  return {
    hashMode,
    signer,
    nonce: intToBigInt(nonce, false),
    fee: intToBigInt(fee, false),
    keyEncoding,
    signature: emptyMessageSignature()
  };
}
function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {
  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);
  const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;
  return {
    hashMode,
    signer,
    nonce: intToBigInt(nonce, false),
    fee: intToBigInt(fee, false),
    fields: [],
    signaturesRequired: numSigs
  };
}
function isSingleSig(condition) {
  return "signature" in condition;
}
function isSequentialMultiSig(hashMode) {
  return hashMode === AddressHashMode.SerializeP2SH || hashMode === AddressHashMode.SerializeP2WSH;
}
function isNonSequentialMultiSig(hashMode) {
  return hashMode === AddressHashMode.SerializeP2SHNonSequential || hashMode === AddressHashMode.SerializeP2WSHNonSequential;
}
function clearCondition(condition) {
  const cloned = cloneDeep(condition);
  cloned.nonce = 0;
  cloned.fee = 0;
  if (isSingleSig(cloned)) {
    cloned.signature = emptyMessageSignature();
  } else {
    cloned.fields = [];
  }
  return {
    ...cloned,
    nonce: BigInt(0),
    fee: BigInt(0)
  };
}
function serializeSingleSigSpendingCondition(condition) {
  const bytesArray = [
    condition.hashMode,
    hexToBytes(condition.signer),
    intToBytes(condition.nonce, false, 8),
    intToBytes(condition.fee, false, 8),
    condition.keyEncoding,
    serializeMessageSignature(condition.signature)
  ];
  return concatArray(bytesArray);
}
function serializeMultiSigSpendingCondition(condition) {
  const bytesArray = [
    condition.hashMode,
    hexToBytes(condition.signer),
    intToBytes(condition.nonce, false, 8),
    intToBytes(condition.fee, false, 8)
  ];
  const fields = createLPList(condition.fields);
  bytesArray.push(serializeLPList(fields));
  const numSigs = new Uint8Array(2);
  writeUInt16BE(numSigs, condition.signaturesRequired, 0);
  bytesArray.push(numSigs);
  return concatArray(bytesArray);
}
function deserializeSingleSigSpendingCondition(hashMode, bytesReader) {
  const signer = bytesToHex(bytesReader.readBytes(20));
  const nonce = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
  const fee = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
  const keyEncoding = bytesReader.readUInt8Enum(PubKeyEncoding, (n) => {
    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);
  });
  if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {
    throw new DeserializationError("Failed to parse singlesig spending condition: incomaptible hash mode and key encoding");
  }
  const signature = deserializeMessageSignature(bytesReader);
  return {
    hashMode,
    signer,
    nonce,
    fee,
    keyEncoding,
    signature
  };
}
function deserializeMultiSigSpendingCondition(hashMode, bytesReader) {
  const signer = bytesToHex(bytesReader.readBytes(20));
  const nonce = BigInt("0x" + bytesToHex(bytesReader.readBytes(8)));
  const fee = BigInt("0x" + bytesToHex(bytesReader.readBytes(8)));
  const fields = deserializeLPList(bytesReader, StacksMessageType.TransactionAuthField).values;
  let haveUncompressed = false;
  let numSigs = 0;
  for (const field of fields) {
    switch (field.contents.type) {
      case StacksMessageType.PublicKey:
        if (!isCompressed(field.contents))
          haveUncompressed = true;
        break;
      case StacksMessageType.MessageSignature:
        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed)
          haveUncompressed = true;
        numSigs += 1;
        if (numSigs === 65536)
          throw new VerificationError("Failed to parse multisig spending condition: too many signatures");
        break;
    }
  }
  const signaturesRequired = bytesReader.readUInt16BE();
  if (haveUncompressed && (hashMode === AddressHashMode.SerializeP2WSH || hashMode === AddressHashMode.SerializeP2WSHNonSequential)) {
    throw new VerificationError("Uncompressed keys are not allowed in this hash mode");
  }
  return {
    hashMode,
    signer,
    nonce,
    fee,
    fields,
    signaturesRequired
  };
}
function serializeSpendingCondition(condition) {
  if (isSingleSig(condition)) {
    return serializeSingleSigSpendingCondition(condition);
  }
  return serializeMultiSigSpendingCondition(condition);
}
function deserializeSpendingCondition(bytesReader) {
  const hashMode = bytesReader.readUInt8Enum(AddressHashMode, (n) => {
    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);
  });
  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {
    return deserializeSingleSigSpendingCondition(hashMode, bytesReader);
  } else {
    return deserializeMultiSigSpendingCondition(hashMode, bytesReader);
  }
}
function makeSigHashPreSign(curSigHash, authType, fee, nonce) {
  const hashLength = 32 + 1 + 8 + 8;
  const sigHash = curSigHash + bytesToHex(new Uint8Array([authType])) + bytesToHex(intToBytes(fee, false, 8)) + bytesToHex(intToBytes(nonce, false, 8));
  if (hexToBytes(sigHash).byteLength !== hashLength) {
    throw Error("Invalid signature hash length");
  }
  return txidFromData(hexToBytes(sigHash));
}
function makeSigHashPostSign(curSigHash, pubKey, signature) {
  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;
  const pubKeyEncoding = isCompressed(pubKey) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;
  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;
  const sigHashBytes = hexToBytes(sigHash);
  if (sigHashBytes.byteLength > hashLength) {
    throw Error("Invalid signature hash length");
  }
  return txidFromData(sigHashBytes);
}
function nextSignature(curSigHash, authType, fee, nonce, privateKey) {
  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);
  const signature = signWithKey(privateKey, sigHashPreSign);
  const publicKey = getPublicKey2(privateKey);
  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
  return {
    nextSig: signature,
    nextSigHash
  };
}
function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {
  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);
  const publicKey = createStacksPublicKey(publicKeyFromSignatureVrs(sigHashPreSign, signature, pubKeyEncoding));
  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
  return {
    pubKey: publicKey,
    nextSigHash
  };
}
function newInitialSigHash() {
  const spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, "", 0, 0);
  spendingCondition.signer = createEmptyAddress().hash160;
  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;
  spendingCondition.signature = emptyMessageSignature();
  return spendingCondition;
}
function verify2(condition, initialSigHash, authType) {
  if (isSingleSig(condition)) {
    return verifySingleSig(condition, initialSigHash, authType);
  } else {
    return verifyMultiSig(condition, initialSigHash, authType);
  }
}
function verifySingleSig(condition, initialSigHash, authType) {
  const { pubKey, nextSigHash } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);
  const addrBytes = addressFromPublicKeys(0, condition.hashMode, 1, [pubKey]).hash160;
  if (addrBytes !== condition.signer)
    throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);
  return nextSigHash;
}
function verifyMultiSig(condition, initialSigHash, authType) {
  const publicKeys = [];
  let curSigHash = initialSigHash;
  let haveUncompressed = false;
  let numSigs = 0;
  for (const field of condition.fields) {
    switch (field.contents.type) {
      case StacksMessageType.PublicKey:
        if (!isCompressed(field.contents))
          haveUncompressed = true;
        publicKeys.push(field.contents);
        break;
      case StacksMessageType.MessageSignature:
        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed)
          haveUncompressed = true;
        const { pubKey, nextSigHash } = nextVerification(curSigHash, authType, condition.fee, condition.nonce, field.pubKeyEncoding, field.contents);
        if (isSequentialMultiSig(condition.hashMode)) {
          curSigHash = nextSigHash;
        }
        publicKeys.push(pubKey);
        numSigs += 1;
        if (numSigs === 65536)
          throw new VerificationError("Too many signatures");
        break;
    }
  }
  if (isSequentialMultiSig(condition.hashMode) && numSigs !== condition.signaturesRequired || isNonSequentialMultiSig(condition.hashMode) && numSigs < condition.signaturesRequired)
    throw new VerificationError("Incorrect number of signatures");
  if (haveUncompressed && (condition.hashMode === AddressHashMode.SerializeP2WSH || condition.hashMode === AddressHashMode.SerializeP2WSHNonSequential))
    throw new VerificationError("Uncompressed keys are not allowed in this hash mode");
  const addrBytes = addressFromPublicKeys(0, condition.hashMode, condition.signaturesRequired, publicKeys).hash160;
  if (addrBytes !== condition.signer)
    throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);
  return curSigHash;
}
function createStandardAuth(spendingCondition) {
  return {
    authType: AuthType.Standard,
    spendingCondition
  };
}
function createSponsoredAuth(spendingCondition, sponsorSpendingCondition) {
  return {
    authType: AuthType.Sponsored,
    spendingCondition,
    sponsorSpendingCondition: sponsorSpendingCondition ? sponsorSpendingCondition : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, "0".repeat(66), 0, 0)
  };
}
function intoInitialSighashAuth(auth) {
  if (auth.spendingCondition) {
    switch (auth.authType) {
      case AuthType.Standard:
        return createStandardAuth(clearCondition(auth.spendingCondition));
      case AuthType.Sponsored:
        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());
      default:
        throw new SigningError("Unexpected authorization type for signing");
    }
  }
  throw new Error("Authorization missing SpendingCondition");
}
function verifyOrigin(auth, initialSigHash) {
  switch (auth.authType) {
    case AuthType.Standard:
      return verify2(auth.spendingCondition, initialSigHash, AuthType.Standard);
    case AuthType.Sponsored:
      return verify2(auth.spendingCondition, initialSigHash, AuthType.Standard);
    default:
      throw new SigningError("Invalid origin auth type");
  }
}
function setFee(auth, amount) {
  switch (auth.authType) {
    case AuthType.Standard:
      const spendingCondition = {
        ...auth.spendingCondition,
        fee: intToBigInt(amount, false)
      };
      return { ...auth, spendingCondition };
    case AuthType.Sponsored:
      const sponsorSpendingCondition = {
        ...auth.sponsorSpendingCondition,
        fee: intToBigInt(amount, false)
      };
      return { ...auth, sponsorSpendingCondition };
  }
}
function getFee(auth) {
  switch (auth.authType) {
    case AuthType.Standard:
      return auth.spendingCondition.fee;
    case AuthType.Sponsored:
      return auth.sponsorSpendingCondition.fee;
  }
}
function setNonce(auth, nonce) {
  const spendingCondition = {
    ...auth.spendingCondition,
    nonce: intToBigInt(nonce, false)
  };
  return {
    ...auth,
    spendingCondition
  };
}
function setSponsorNonce(auth, nonce) {
  const sponsorSpendingCondition = {
    ...auth.sponsorSpendingCondition,
    nonce: intToBigInt(nonce, false)
  };
  return {
    ...auth,
    sponsorSpendingCondition
  };
}
function setSponsor(auth, sponsorSpendingCondition) {
  const sc = {
    ...sponsorSpendingCondition,
    nonce: intToBigInt(sponsorSpendingCondition.nonce, false),
    fee: intToBigInt(sponsorSpendingCondition.fee, false)
  };
  return {
    ...auth,
    sponsorSpendingCondition: sc
  };
}
function serializeAuthorization(auth) {
  const bytesArray = [];
  bytesArray.push(auth.authType);
  switch (auth.authType) {
    case AuthType.Standard:
      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));
      break;
    case AuthType.Sponsored:
      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));
      bytesArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));
      break;
  }
  return concatArray(bytesArray);
}
function deserializeAuthorization(bytesReader) {
  const authType = bytesReader.readUInt8Enum(AuthType, (n) => {
    throw new DeserializationError(`Could not parse ${n} as AuthType`);
  });
  let spendingCondition;
  switch (authType) {
    case AuthType.Standard:
      spendingCondition = deserializeSpendingCondition(bytesReader);
      return createStandardAuth(spendingCondition);
    case AuthType.Sponsored:
      spendingCondition = deserializeSpendingCondition(bytesReader);
      const sponsorSpendingCondition = deserializeSpendingCondition(bytesReader);
      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);
  }
}

// node_modules/@stacks/transactions/dist/esm/builders.js
var import_c32check5 = __toESM(require_lib());

// node_modules/@stacks/transactions/dist/esm/contract-abi.js
var ClarityAbiTypeId;
(function(ClarityAbiTypeId2) {
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeUInt128"] = 1] = "ClarityAbiTypeUInt128";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeInt128"] = 2] = "ClarityAbiTypeInt128";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeBool"] = 3] = "ClarityAbiTypeBool";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypePrincipal"] = 4] = "ClarityAbiTypePrincipal";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeNone"] = 5] = "ClarityAbiTypeNone";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeBuffer"] = 6] = "ClarityAbiTypeBuffer";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeResponse"] = 7] = "ClarityAbiTypeResponse";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeOptional"] = 8] = "ClarityAbiTypeOptional";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeTuple"] = 9] = "ClarityAbiTypeTuple";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeList"] = 10] = "ClarityAbiTypeList";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeStringAscii"] = 11] = "ClarityAbiTypeStringAscii";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeStringUtf8"] = 12] = "ClarityAbiTypeStringUtf8";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeTraitReference"] = 13] = "ClarityAbiTypeTraitReference";
})(ClarityAbiTypeId || (ClarityAbiTypeId = {}));
var isClarityAbiPrimitive = (val) => typeof val === "string";
var isClarityAbiBuffer = (val) => val.buffer !== void 0;
var isClarityAbiStringAscii = (val) => val["string-ascii"] !== void 0;
var isClarityAbiStringUtf8 = (val) => val["string-utf8"] !== void 0;
var isClarityAbiResponse = (val) => val.response !== void 0;
var isClarityAbiOptional = (val) => val.optional !== void 0;
var isClarityAbiTuple = (val) => val.tuple !== void 0;
var isClarityAbiList = (val) => val.list !== void 0;
function getTypeUnion(val) {
  if (isClarityAbiPrimitive(val)) {
    if (val === "uint128") {
      return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };
    } else if (val === "int128") {
      return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };
    } else if (val === "bool") {
      return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };
    } else if (val === "principal") {
      return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };
    } else if (val === "trait_reference") {
      return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };
    } else if (val === "none") {
      return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };
    } else {
      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);
    }
  } else if (isClarityAbiBuffer(val)) {
    return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };
  } else if (isClarityAbiResponse(val)) {
    return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };
  } else if (isClarityAbiOptional(val)) {
    return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };
  } else if (isClarityAbiTuple(val)) {
    return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };
  } else if (isClarityAbiList(val)) {
    return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };
  } else if (isClarityAbiStringAscii(val)) {
    return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };
  } else if (isClarityAbiStringUtf8(val)) {
    return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };
  } else {
    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);
  }
}
function encodeAbiClarityValue(value, type) {
  const union = type.id ? type : getTypeUnion(type);
  switch (union.id) {
    case ClarityAbiTypeId.ClarityAbiTypeUInt128:
      return uintCV(value);
    case ClarityAbiTypeId.ClarityAbiTypeInt128:
      return intCV(value);
    case ClarityAbiTypeId.ClarityAbiTypeBool:
      if (value === "false" || value === "0")
        return falseCV();
      else if (value === "true" || value === "1")
        return trueCV();
      else
        throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(value)}`);
    case ClarityAbiTypeId.ClarityAbiTypePrincipal:
      if (value.includes(".")) {
        const [addr2, name2] = value.split(".");
        return contractPrincipalCV(addr2, name2);
      } else {
        return standardPrincipalCV(value);
      }
    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:
      const [addr, name] = value.split(".");
      return contractPrincipalCV(addr, name);
    case ClarityAbiTypeId.ClarityAbiTypeNone:
      return noneCV();
    case ClarityAbiTypeId.ClarityAbiTypeBuffer:
      return bufferCV(hexToBytes(value));
    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:
      return stringAsciiCV(value);
    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:
      return stringUtf8CV(value);
    case ClarityAbiTypeId.ClarityAbiTypeOptional:
      return someCV(encodeAbiClarityValue(value, union.type.optional));
    case ClarityAbiTypeId.ClarityAbiTypeResponse:
    case ClarityAbiTypeId.ClarityAbiTypeTuple:
    case ClarityAbiTypeId.ClarityAbiTypeList:
      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
    default:
      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);
  }
}
function encodeClarityValue(type, value) {
  const union = type.id ? type : getTypeUnion(type);
  if (union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer) {
    return bufferCV(utf8ToBytes(value));
  }
  return encodeAbiClarityValue(value, union);
}
function getTypeString(val) {
  if (isClarityAbiPrimitive(val)) {
    if (val === "int128") {
      return "int";
    } else if (val === "uint128") {
      return "uint";
    }
    return val;
  } else if (isClarityAbiBuffer(val)) {
    return `(buff ${val.buffer.length})`;
  } else if (isClarityAbiStringAscii(val)) {
    return `(string-ascii ${val["string-ascii"].length})`;
  } else if (isClarityAbiStringUtf8(val)) {
    return `(string-utf8 ${val["string-utf8"].length})`;
  } else if (isClarityAbiResponse(val)) {
    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;
  } else if (isClarityAbiOptional(val)) {
    return `(optional ${getTypeString(val.optional)})`;
  } else if (isClarityAbiTuple(val)) {
    return `(tuple ${val.tuple.map((t) => `(${t.name} ${getTypeString(t.type)})`).join(" ")})`;
  } else if (isClarityAbiList(val)) {
    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;
  } else {
    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);
  }
}
function abiFunctionToString(func) {
  const access = func.access === "read_only" ? "read-only" : func.access;
  return `(define-${access} (${func.name} ${func.args.map((arg) => `(${arg.name} ${getTypeString(arg.type)})`).join(" ")}))`;
}
function matchType(cv, abiType) {
  const union = getTypeUnion(abiType);
  switch (cv.type) {
    case ClarityType.BoolTrue:
    case ClarityType.BoolFalse:
      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;
    case ClarityType.Int:
      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;
    case ClarityType.UInt:
      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;
    case ClarityType.Buffer:
      return union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer && union.type.buffer.length >= cv.buffer.length;
    case ClarityType.StringASCII:
      return union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii && union.type["string-ascii"].length >= cv.data.length;
    case ClarityType.StringUTF8:
      return union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 && union.type["string-utf8"].length >= cv.data.length;
    case ClarityType.OptionalNone:
      return union.id === ClarityAbiTypeId.ClarityAbiTypeNone || union.id === ClarityAbiTypeId.ClarityAbiTypeOptional;
    case ClarityType.OptionalSome:
      return union.id === ClarityAbiTypeId.ClarityAbiTypeOptional && matchType(cv.value, union.type.optional);
    case ClarityType.ResponseErr:
      return union.id === ClarityAbiTypeId.ClarityAbiTypeResponse && matchType(cv.value, union.type.response.error);
    case ClarityType.ResponseOk:
      return union.id === ClarityAbiTypeId.ClarityAbiTypeResponse && matchType(cv.value, union.type.response.ok);
    case ClarityType.PrincipalContract:
      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal || union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference;
    case ClarityType.PrincipalStandard:
      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;
    case ClarityType.List:
      return union.id == ClarityAbiTypeId.ClarityAbiTypeList && union.type.list.length >= cv.list.length && cv.list.every((val) => matchType(val, union.type.list.type));
    case ClarityType.Tuple:
      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {
        const tuple2 = cloneDeep(cv.data);
        for (let i = 0; i < union.type.tuple.length; i++) {
          const abiTupleEntry = union.type.tuple[i];
          const key = abiTupleEntry.name;
          const val = tuple2[key];
          if (val) {
            if (!matchType(val, abiTupleEntry.type)) {
              return false;
            }
            delete tuple2[key];
          } else {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    default:
      return false;
  }
}
function validateContractCall(payload, abi) {
  const filtered = abi.functions.filter((fn) => fn.name === payload.functionName.content);
  if (filtered.length === 1) {
    const abiFunc = filtered[0];
    const abiArgs = abiFunc.args;
    if (payload.functionArgs.length !== abiArgs.length) {
      throw new Error(`Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`);
    }
    for (let i = 0; i < payload.functionArgs.length; i++) {
      const payloadArg = payload.functionArgs[i];
      const abiArg = abiArgs[i];
      if (!matchType(payloadArg, abiArg.type)) {
        const argNum = i + 1;
        throw new Error(`Clarity function \`${payload.functionName.content}\` expects argument ${argNum} to be of type ${getTypeString(abiArg.type)}, not ${getCVTypeString(payloadArg)}`);
      }
    }
    return true;
  } else if (filtered.length === 0) {
    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);
  } else {
    throw new Error(`Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`);
  }
}
function parseToCV(input, type) {
  const typeString = getTypeString(type);
  if (isClarityAbiPrimitive(type)) {
    if (type === "uint128") {
      return uintCV(input);
    } else if (type === "int128") {
      return intCV(input);
    } else if (type === "bool") {
      if (input.toLowerCase() === "true") {
        return trueCV();
      } else if (input.toLowerCase() === "false") {
        return falseCV();
      } else {
        throw new Error(`Invalid bool value: ${input}`);
      }
    } else if (type === "principal") {
      if (input.includes(".")) {
        const [address2, contractName] = input.split(".");
        return contractPrincipalCV(address2, contractName);
      } else {
        return standardPrincipalCV(input);
      }
    } else {
      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
  } else if (isClarityAbiBuffer(type)) {
    const inputLength = utf8ToBytes(input).byteLength;
    if (inputLength > type.buffer.length) {
      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);
    }
    return bufferCVFromString(input);
  } else if (isClarityAbiResponse(type)) {
    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
  } else if (isClarityAbiOptional(type)) {
    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
  } else if (isClarityAbiTuple(type)) {
    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
  } else if (isClarityAbiList(type)) {
    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
  } else {
    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
  }
}

// node_modules/@stacks/transactions/dist/esm/postcondition.js
function createSTXPostCondition(principal3, conditionCode, amount) {
  if (typeof principal3 === "string") {
    principal3 = parsePrincipalString(principal3);
  }
  return {
    type: StacksMessageType.PostCondition,
    conditionType: PostConditionType.STX,
    principal: principal3,
    conditionCode,
    amount: intToBigInt(amount, false)
  };
}
function createFungiblePostCondition(principal3, conditionCode, amount, assetInfo) {
  if (typeof principal3 === "string") {
    principal3 = parsePrincipalString(principal3);
  }
  if (typeof assetInfo === "string") {
    assetInfo = parseAssetInfoString(assetInfo);
  }
  return {
    type: StacksMessageType.PostCondition,
    conditionType: PostConditionType.Fungible,
    principal: principal3,
    conditionCode,
    amount: intToBigInt(amount, false),
    assetInfo
  };
}
function createNonFungiblePostCondition(principal3, conditionCode, assetInfo, assetName) {
  if (typeof principal3 === "string") {
    principal3 = parsePrincipalString(principal3);
  }
  if (typeof assetInfo === "string") {
    assetInfo = parseAssetInfoString(assetInfo);
  }
  return {
    type: StacksMessageType.PostCondition,
    conditionType: PostConditionType.NonFungible,
    principal: principal3,
    conditionCode,
    assetInfo,
    assetName
  };
}

// node_modules/@stacks/transactions/dist/esm/signer.js
var TransactionSigner = class {
  constructor(transaction) {
    this.transaction = transaction;
    this.sigHash = transaction.signBegin();
    this.originDone = false;
    this.checkOversign = true;
    this.checkOverlap = true;
    const spendingCondition = transaction.auth.spendingCondition;
    if (spendingCondition && !isSingleSig(spendingCondition)) {
      if (spendingCondition.fields.filter((field) => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {
        throw new Error("SpendingCondition has more signatures than are expected");
      }
      spendingCondition.fields.forEach((field) => {
        if (field.contents.type !== StacksMessageType.MessageSignature)
          return;
        const signature = field.contents;
        const nextVerify = nextVerification(this.sigHash, transaction.auth.authType, spendingCondition.fee, spendingCondition.nonce, PubKeyEncoding.Compressed, signature);
        if (!isNonSequentialMultiSig(spendingCondition.hashMode)) {
          this.sigHash = nextVerify.nextSigHash;
        }
      });
    }
  }
  static createSponsorSigner(transaction, spendingCondition) {
    if (transaction.auth.authType != AuthType.Sponsored) {
      throw new SigningError("Cannot add sponsor to non-sponsored transaction");
    }
    const tx = cloneDeep(transaction);
    tx.setSponsor(spendingCondition);
    const originSigHash = tx.verifyOrigin();
    const signer = new this(tx);
    signer.originDone = true;
    signer.sigHash = originSigHash;
    signer.checkOversign = true;
    signer.checkOverlap = true;
    return signer;
  }
  signOrigin(privateKey) {
    if (this.checkOverlap && this.originDone) {
      throw new SigningError("Cannot sign origin after sponsor key");
    }
    if (this.transaction.auth === void 0) {
      throw new SigningError('"transaction.auth" is undefined');
    }
    if (this.transaction.auth.spendingCondition === void 0) {
      throw new SigningError('"transaction.auth.spendingCondition" is undefined');
    }
    const spendingCondition = this.transaction.auth.spendingCondition;
    if (spendingCondition.hashMode === AddressHashMode.SerializeP2SH || spendingCondition.hashMode === AddressHashMode.SerializeP2WSH) {
      if (this.checkOversign && spendingCondition.fields.filter((field) => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {
        throw new Error("Origin would have too many signatures");
      }
    }
    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);
    if (isSingleSig(this.transaction.auth.spendingCondition) || isSequentialMultiSig(this.transaction.auth.spendingCondition.hashMode)) {
      this.sigHash = nextSighash;
    }
  }
  appendOrigin(publicKey) {
    if (this.checkOverlap && this.originDone) {
      throw Error("Cannot append public key to origin after sponsor key");
    }
    if (this.transaction.auth === void 0) {
      throw new Error('"transaction.auth" is undefined');
    }
    if (this.transaction.auth.spendingCondition === void 0) {
      throw new Error('"transaction.auth.spendingCondition" is undefined');
    }
    this.transaction.appendPubkey(publicKey);
  }
  signSponsor(privateKey) {
    if (this.transaction.auth === void 0) {
      throw new SigningError('"transaction.auth" is undefined');
    }
    if (this.transaction.auth.authType !== AuthType.Sponsored) {
      throw new SigningError('"transaction.auth.authType" is not AuthType.Sponsored');
    }
    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);
    this.sigHash = nextSighash;
    this.originDone = true;
  }
  getTxInComplete() {
    return cloneDeep(this.transaction);
  }
  resume(transaction) {
    this.transaction = cloneDeep(transaction);
    this.sigHash = transaction.signBegin();
  }
};

// node_modules/@stacks/transactions/dist/esm/transaction.js
var StacksTransaction = class {
  constructor(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {
    this.version = version;
    this.auth = auth;
    if ("amount" in payload) {
      this.payload = {
        ...payload,
        amount: intToBigInt(payload.amount, false)
      };
    } else {
      this.payload = payload;
    }
    this.chainId = chainId ?? DEFAULT_CHAIN_ID;
    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;
    this.postConditions = postConditions ?? createLPList([]);
    if (anchorMode) {
      this.anchorMode = anchorModeFromNameOrValue(anchorMode);
    } else {
      switch (payload.payloadType) {
        case PayloadType.Coinbase:
        case PayloadType.CoinbaseToAltRecipient:
        case PayloadType.NakamotoCoinbase:
        case PayloadType.PoisonMicroblock:
        case PayloadType.TenureChange:
          this.anchorMode = AnchorMode.OnChainOnly;
          break;
        case PayloadType.ContractCall:
        case PayloadType.SmartContract:
        case PayloadType.VersionedSmartContract:
        case PayloadType.TokenTransfer:
          this.anchorMode = AnchorMode.Any;
          break;
      }
    }
  }
  signBegin() {
    const tx = cloneDeep(this);
    tx.auth = intoInitialSighashAuth(tx.auth);
    return tx.txid();
  }
  verifyBegin() {
    const tx = cloneDeep(this);
    tx.auth = intoInitialSighashAuth(tx.auth);
    return tx.txid();
  }
  verifyOrigin() {
    return verifyOrigin(this.auth, this.verifyBegin());
  }
  signNextOrigin(sigHash, privateKey) {
    if (this.auth.spendingCondition === void 0) {
      throw new Error('"auth.spendingCondition" is undefined');
    }
    if (this.auth.authType === void 0) {
      throw new Error('"auth.authType" is undefined');
    }
    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);
  }
  signNextSponsor(sigHash, privateKey) {
    if (this.auth.authType === AuthType.Sponsored) {
      return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);
    } else {
      throw new Error('"auth.sponsorSpendingCondition" is undefined');
    }
  }
  appendPubkey(publicKey) {
    const cond = this.auth.spendingCondition;
    if (cond && !isSingleSig(cond)) {
      const compressed = isCompressed(publicKey);
      cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, publicKey));
    } else {
      throw new Error(`Can't append public key to a singlesig condition`);
    }
  }
  signAndAppend(condition, curSigHash, authType, privateKey) {
    const { nextSig, nextSigHash } = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey);
    if (isSingleSig(condition)) {
      condition.signature = nextSig;
    } else {
      condition.fields.push(createTransactionAuthField(privateKey.data.byteLength === PRIVATE_KEY_COMPRESSED_LENGTH ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, nextSig));
    }
    return nextSigHash;
  }
  txid() {
    const serialized = this.serialize();
    return txidFromData(serialized);
  }
  setSponsor(sponsorSpendingCondition) {
    if (this.auth.authType != AuthType.Sponsored) {
      throw new SigningError("Cannot sponsor sign a non-sponsored transaction");
    }
    this.auth = setSponsor(this.auth, sponsorSpendingCondition);
  }
  setFee(amount) {
    this.auth = setFee(this.auth, amount);
  }
  setNonce(nonce) {
    this.auth = setNonce(this.auth, nonce);
  }
  setSponsorNonce(nonce) {
    if (this.auth.authType != AuthType.Sponsored) {
      throw new SigningError("Cannot sponsor sign a non-sponsored transaction");
    }
    this.auth = setSponsorNonce(this.auth, nonce);
  }
  serialize() {
    if (this.version === void 0) {
      throw new SerializationError('"version" is undefined');
    }
    if (this.chainId === void 0) {
      throw new SerializationError('"chainId" is undefined');
    }
    if (this.auth === void 0) {
      throw new SerializationError('"auth" is undefined');
    }
    if (this.anchorMode === void 0) {
      throw new SerializationError('"anchorMode" is undefined');
    }
    if (this.payload === void 0) {
      throw new SerializationError('"payload" is undefined');
    }
    const bytesArray = [];
    bytesArray.push(this.version);
    const chainIdBytes = new Uint8Array(4);
    writeUInt32BE(chainIdBytes, this.chainId, 0);
    bytesArray.push(chainIdBytes);
    bytesArray.push(serializeAuthorization(this.auth));
    bytesArray.push(this.anchorMode);
    bytesArray.push(this.postConditionMode);
    bytesArray.push(serializeLPList(this.postConditions));
    bytesArray.push(serializePayload(this.payload));
    return concatArray(bytesArray);
  }
};
function deserializeTransaction(tx) {
  let bytesReader;
  if (typeof tx === "string") {
    if (tx.slice(0, 2).toLowerCase() === "0x") {
      bytesReader = new BytesReader(hexToBytes(tx.slice(2)));
    } else {
      bytesReader = new BytesReader(hexToBytes(tx));
    }
  } else if (tx instanceof Uint8Array) {
    bytesReader = new BytesReader(tx);
  } else {
    bytesReader = tx;
  }
  const version = bytesReader.readUInt8Enum(TransactionVersion2, (n) => {
    throw new Error(`Could not parse ${n} as TransactionVersion`);
  });
  const chainId = bytesReader.readUInt32BE();
  const auth = deserializeAuthorization(bytesReader);
  const anchorMode = bytesReader.readUInt8Enum(AnchorMode, (n) => {
    throw new Error(`Could not parse ${n} as AnchorMode`);
  });
  const postConditionMode = bytesReader.readUInt8Enum(PostConditionMode, (n) => {
    throw new Error(`Could not parse ${n} as PostConditionMode`);
  });
  const postConditions = deserializeLPList(bytesReader, StacksMessageType.PostCondition);
  const payload = deserializePayload(bytesReader);
  return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);
}

// node_modules/@stacks/transactions/dist/esm/builders.js
async function _getNonceApi(address2, network) {
  const url = `${network.coreApiUrl}/extended/v1/address/${address2}/nonces`;
  const response = await network.fetchFn(url);
  const result = await response.json();
  return BigInt(result.possible_next_nonce);
}
async function getNonce(address2, network) {
  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());
  const url = derivedNetwork.getAccountApiUrl(address2);
  try {
    return await _getNonceApi(address2, derivedNetwork);
  } catch (e) {
  }
  const response = await derivedNetwork.fetchFn(url);
  if (!response.ok) {
    let msg = "";
    try {
      msg = await response.text();
    } catch (error2) {
    }
    throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
  }
  const responseText = await response.text();
  const result = JSON.parse(responseText);
  return BigInt(result.nonce);
}
async function estimateTransfer(transaction, network) {
  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {
    throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);
  }
  return estimateTransferUnsafe(transaction, network);
}
async function estimateTransferUnsafe(transaction, network) {
  const requestHeaders = {
    Accept: "application/text"
  };
  const fetchOptions = {
    method: "GET",
    headers: requestHeaders
  };
  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
  const url = derivedNetwork.getTransferFeeEstimateApiUrl();
  const response = await derivedNetwork.fetchFn(url, fetchOptions);
  if (!response.ok) {
    let msg = "";
    try {
      msg = await response.text();
    } catch (error2) {
    }
    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
  }
  const feeRateResult = await response.text();
  const txBytes = BigInt(transaction.serialize().byteLength);
  const feeRate = BigInt(feeRateResult);
  return feeRate * txBytes;
}
async function estimateTransaction(transactionPayload, estimatedLen, network) {
  var _a;
  const options = {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      transaction_payload: bytesToHex(serializePayload(transactionPayload)),
      ...estimatedLen ? { estimated_len: estimatedLen } : {}
    })
  };
  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());
  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();
  const response = await derivedNetwork.fetchFn(url, options);
  if (!response.ok) {
    const body = await response.text().then((str) => {
      try {
        return JSON.parse(str);
      } catch (error2) {
        return str;
      }
    });
    if ((body == null ? void 0 : body.reason) === "NoEstimateAvailable" || typeof body === "string" && body.includes("NoEstimateAvailable")) {
      throw new NoEstimateAvailableError(((_a = body == null ? void 0 : body.reason_data) == null ? void 0 : _a.message) ?? "");
    }
    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${body}"`);
  }
  const data = await response.json();
  return data.estimations;
}
async function broadcastTransaction(transaction, network, attachment) {
  const rawTx = transaction.serialize();
  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
  const url = derivedNetwork.getBroadcastApiUrl();
  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);
}
async function broadcastRawTransaction(rawTx, url, attachment, fetchFn = createFetchFn()) {
  const options = {
    method: "POST",
    headers: { "Content-Type": attachment ? "application/json" : "application/octet-stream" },
    body: attachment ? JSON.stringify({
      tx: bytesToHex(rawTx),
      attachment: bytesToHex(attachment)
    }) : rawTx
  };
  const response = await fetchFn(url, options);
  if (!response.ok) {
    try {
      return await response.json();
    } catch (e) {
      throw Error(`Failed to broadcast transaction: ${e.message}`);
    }
  }
  const text = await response.text();
  const txid = text.replace(/["]+/g, "");
  if (!validateTxId(txid))
    throw new Error(text);
  return { txid };
}
async function getAbi(address2, contractName, network) {
  const options = {
    method: "GET"
  };
  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);
  const url = derivedNetwork.getAbiApiUrl(address2, contractName);
  const response = await derivedNetwork.fetchFn(url, options);
  if (!response.ok) {
    const msg = await response.text().catch(() => "");
    throw new Error(`Error fetching contract ABI for contract "${contractName}" at address ${address2}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
  }
  return JSON.parse(await response.text());
}
function deriveNetwork(transaction) {
  switch (transaction.version) {
    case TransactionVersion2.Mainnet:
      return new StacksMainnet();
    case TransactionVersion2.Testnet:
      return new StacksTestnet();
  }
}
async function makeUnsignedSTXTokenTransfer(txOptions) {
  const defaultOptions = {
    fee: BigInt(0),
    nonce: BigInt(0),
    network: new StacksMainnet(),
    memo: "",
    sponsored: false
  };
  const options = Object.assign(defaultOptions, txOptions);
  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);
  let authorization = null;
  let spendingCondition = null;
  if ("publicKey" in options) {
    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
  } else {
    const hashMode = options.useNonSequentialMultiSig ? AddressHashMode.SerializeP2SHNonSequential : AddressHashMode.SerializeP2SH;
    const publicKeys = options.address ? sortPublicKeysForAddress(options.publicKeys, options.numSignatures, hashMode, createAddress(options.address).hash160) : options.publicKeys;
    spendingCondition = createMultiSigSpendingCondition(hashMode, options.numSignatures, publicKeys, options.nonce, options.fee);
  }
  if (options.sponsored) {
    authorization = createSponsoredAuth(spendingCondition);
  } else {
    authorization = createStandardAuth(spendingCondition);
  }
  const network = StacksNetwork.fromNameOrNetwork(options.network);
  const transaction = new StacksTransaction(network.version, authorization, payload, void 0, void 0, options.anchorMode, network.chainId);
  if (txOptions.fee === void 0 || txOptions.fee === null) {
    const fee = await estimateTransactionFeeWithFallback(transaction, network);
    transaction.setFee(fee);
  }
  if (txOptions.nonce === void 0 || txOptions.nonce === null) {
    const addressVersion = options.network.version === TransactionVersion2.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;
    const senderAddress = (0, import_c32check5.c32address)(addressVersion, transaction.auth.spendingCondition.signer);
    const txNonce = await getNonce(senderAddress, options.network);
    transaction.setNonce(txNonce);
  }
  return transaction;
}
async function makeSTXTokenTransfer(txOptions) {
  if ("senderKey" in txOptions) {
    const publicKey = publicKeyToString(getPublicKey2(createStacksPrivateKey(txOptions.senderKey)));
    const options = omit(txOptions, "senderKey");
    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });
    const privKey = createStacksPrivateKey(txOptions.senderKey);
    const signer = new TransactionSigner(transaction);
    signer.signOrigin(privKey);
    return transaction;
  } else {
    const options = omit(txOptions, "signerKeys");
    const transaction = await makeUnsignedSTXTokenTransfer(options);
    mutatingSignAppendMultiSig(transaction, txOptions.publicKeys.slice(), txOptions.signerKeys, txOptions.address);
    return transaction;
  }
}
async function estimateContractDeploy(transaction, network) {
  if (transaction.payload.payloadType !== PayloadType.SmartContract && transaction.payload.payloadType !== PayloadType.VersionedSmartContract) {
    throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);
  }
  const requestHeaders = {
    Accept: "application/text"
  };
  const fetchOptions = {
    method: "GET",
    headers: requestHeaders
  };
  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
  const url = derivedNetwork.getTransferFeeEstimateApiUrl();
  const response = await derivedNetwork.fetchFn(url, fetchOptions);
  if (!response.ok) {
    const msg = await response.text().catch(() => "");
    throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
  }
  const feeRateResult = await response.text();
  const txBytes = intToBigInt(transaction.serialize().byteLength, false);
  const feeRate = intToBigInt(feeRateResult, false);
  return feeRate * txBytes;
}
async function makeContractDeploy(txOptions) {
  if ("senderKey" in txOptions) {
    const publicKey = publicKeyToString(getPublicKey2(createStacksPrivateKey(txOptions.senderKey)));
    const options = omit(txOptions, "senderKey");
    const transaction = await makeUnsignedContractDeploy({ publicKey, ...options });
    const privKey = createStacksPrivateKey(txOptions.senderKey);
    const signer = new TransactionSigner(transaction);
    signer.signOrigin(privKey);
    return transaction;
  } else {
    const options = omit(txOptions, "signerKeys");
    const transaction = await makeUnsignedContractDeploy(options);
    mutatingSignAppendMultiSig(transaction, txOptions.publicKeys.slice(), txOptions.signerKeys, txOptions.address);
    return transaction;
  }
}
async function makeUnsignedContractDeploy(txOptions) {
  const defaultOptions = {
    fee: BigInt(0),
    nonce: BigInt(0),
    network: new StacksMainnet(),
    postConditionMode: PostConditionMode.Deny,
    sponsored: false,
    clarityVersion: ClarityVersion.Clarity2
  };
  const options = Object.assign(defaultOptions, txOptions);
  const payload = createSmartContractPayload(options.contractName, options.codeBody, options.clarityVersion);
  let authorization = null;
  let spendingCondition = null;
  if ("publicKey" in options) {
    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
  } else {
    const hashMode = options.useNonSequentialMultiSig ? AddressHashMode.SerializeP2SHNonSequential : AddressHashMode.SerializeP2SH;
    const publicKeys = options.address ? sortPublicKeysForAddress(options.publicKeys, options.numSignatures, hashMode, createAddress(options.address).hash160) : options.publicKeys;
    spendingCondition = createMultiSigSpendingCondition(hashMode, options.numSignatures, publicKeys, options.nonce, options.fee);
  }
  if (options.sponsored) {
    authorization = createSponsoredAuth(spendingCondition);
  } else {
    authorization = createStandardAuth(spendingCondition);
  }
  const network = StacksNetwork.fromNameOrNetwork(options.network);
  const postConditions = [];
  if (options.postConditions && options.postConditions.length > 0) {
    options.postConditions.forEach((postCondition) => {
      postConditions.push(postCondition);
    });
  }
  const lpPostConditions = createLPList(postConditions);
  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
  if (txOptions.fee === void 0 || txOptions.fee === null) {
    const fee = await estimateTransactionFeeWithFallback(transaction, network);
    transaction.setFee(fee);
  }
  if (txOptions.nonce === void 0 || txOptions.nonce === null) {
    const addressVersion = options.network.version === TransactionVersion2.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;
    const senderAddress = (0, import_c32check5.c32address)(addressVersion, transaction.auth.spendingCondition.signer);
    const txNonce = await getNonce(senderAddress, options.network);
    transaction.setNonce(txNonce);
  }
  return transaction;
}
async function estimateContractFunctionCall(transaction, network) {
  if (transaction.payload.payloadType !== PayloadType.ContractCall) {
    throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);
  }
  const requestHeaders = {
    Accept: "application/text"
  };
  const fetchOptions = {
    method: "GET",
    headers: requestHeaders
  };
  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
  const url = derivedNetwork.getTransferFeeEstimateApiUrl();
  const response = await derivedNetwork.fetchFn(url, fetchOptions);
  if (!response.ok) {
    const msg = await response.text().catch(() => "");
    throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
  }
  const feeRateResult = await response.text();
  const txBytes = intToBigInt(transaction.serialize().byteLength, false);
  const feeRate = intToBigInt(feeRateResult, false);
  return feeRate * txBytes;
}
async function makeUnsignedContractCall(txOptions) {
  const defaultOptions = {
    fee: BigInt(0),
    nonce: BigInt(0),
    network: new StacksMainnet(),
    postConditionMode: PostConditionMode.Deny,
    sponsored: false
  };
  const options = Object.assign(defaultOptions, txOptions);
  const payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);
  if (options == null ? void 0 : options.validateWithAbi) {
    let abi;
    if (typeof options.validateWithAbi === "boolean") {
      if (options == null ? void 0 : options.network) {
        abi = await getAbi(options.contractAddress, options.contractName, options.network);
      } else {
        throw new Error("Network option must be provided in order to validate with ABI");
      }
    } else {
      abi = options.validateWithAbi;
    }
    validateContractCall(payload, abi);
  }
  let spendingCondition = null;
  let authorization = null;
  if ("publicKey" in options) {
    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
  } else {
    const hashMode = options.useNonSequentialMultiSig ? AddressHashMode.SerializeP2SHNonSequential : AddressHashMode.SerializeP2SH;
    const publicKeys = options.address ? sortPublicKeysForAddress(options.publicKeys, options.numSignatures, hashMode, createAddress(options.address).hash160) : options.publicKeys;
    spendingCondition = createMultiSigSpendingCondition(hashMode, options.numSignatures, publicKeys, options.nonce, options.fee);
  }
  if (options.sponsored) {
    authorization = createSponsoredAuth(spendingCondition);
  } else {
    authorization = createStandardAuth(spendingCondition);
  }
  const network = StacksNetwork.fromNameOrNetwork(options.network);
  const postConditions = [];
  if (options.postConditions && options.postConditions.length > 0) {
    options.postConditions.forEach((postCondition) => {
      postConditions.push(postCondition);
    });
  }
  const lpPostConditions = createLPList(postConditions);
  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
  if (txOptions.fee === void 0 || txOptions.fee === null) {
    const fee = await estimateTransactionFeeWithFallback(transaction, network);
    transaction.setFee(fee);
  }
  if (txOptions.nonce === void 0 || txOptions.nonce === null) {
    const addressVersion = network.version === TransactionVersion2.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;
    const senderAddress = (0, import_c32check5.c32address)(addressVersion, transaction.auth.spendingCondition.signer);
    const txNonce = await getNonce(senderAddress, network);
    transaction.setNonce(txNonce);
  }
  return transaction;
}
async function makeContractCall(txOptions) {
  if ("senderKey" in txOptions) {
    const publicKey = publicKeyToString(getPublicKey2(createStacksPrivateKey(txOptions.senderKey)));
    const options = omit(txOptions, "senderKey");
    const transaction = await makeUnsignedContractCall({ publicKey, ...options });
    const privKey = createStacksPrivateKey(txOptions.senderKey);
    const signer = new TransactionSigner(transaction);
    signer.signOrigin(privKey);
    return transaction;
  } else {
    const options = omit(txOptions, "signerKeys");
    const transaction = await makeUnsignedContractCall(options);
    mutatingSignAppendMultiSig(transaction, txOptions.publicKeys.slice(), txOptions.signerKeys, txOptions.address);
    return transaction;
  }
}
function makeStandardSTXPostCondition(address2, conditionCode, amount) {
  return createSTXPostCondition(createStandardPrincipal(address2), conditionCode, amount);
}
function makeContractSTXPostCondition(address2, contractName, conditionCode, amount) {
  return createSTXPostCondition(createContractPrincipal(address2, contractName), conditionCode, amount);
}
function makeStandardFungiblePostCondition(address2, conditionCode, amount, assetInfo) {
  return createFungiblePostCondition(createStandardPrincipal(address2), conditionCode, amount, assetInfo);
}
function makeContractFungiblePostCondition(address2, contractName, conditionCode, amount, assetInfo) {
  return createFungiblePostCondition(createContractPrincipal(address2, contractName), conditionCode, amount, assetInfo);
}
function makeStandardNonFungiblePostCondition(address2, conditionCode, assetInfo, assetId) {
  return createNonFungiblePostCondition(createStandardPrincipal(address2), conditionCode, assetInfo, assetId);
}
function makeContractNonFungiblePostCondition(address2, contractName, conditionCode, assetInfo, assetId) {
  return createNonFungiblePostCondition(createContractPrincipal(address2, contractName), conditionCode, assetInfo, assetId);
}
async function callReadOnlyFunction(readOnlyFunctionOptions) {
  const defaultOptions = {
    network: new StacksMainnet()
  };
  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);
  const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;
  const network = StacksNetwork.fromNameOrNetwork(options.network);
  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);
  const args = functionArgs.map((arg) => cvToHex(arg));
  const body = JSON.stringify({
    sender: senderAddress,
    arguments: args
  });
  const response = await network.fetchFn(url, {
    method: "POST",
    body,
    headers: {
      "Content-Type": "application/json"
    }
  });
  if (!response.ok) {
    const msg = await response.text().catch(() => "");
    throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
  }
  return response.json().then((responseJson) => parseReadOnlyResponse(responseJson));
}
async function getContractMapEntry(getContractMapEntryOptions) {
  const defaultOptions = {
    network: new StacksMainnet()
  };
  const { contractAddress, contractName, mapName, mapKey, network } = Object.assign(defaultOptions, getContractMapEntryOptions);
  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);
  const url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);
  const serializedKeyBytes = serializeCV(mapKey);
  const serializedKeyHex = "0x" + bytesToHex(serializedKeyBytes);
  const fetchOptions = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json"
    },
    body: JSON.stringify(serializedKeyHex)
  };
  const response = await derivedNetwork.fetchFn(url, fetchOptions);
  if (!response.ok) {
    const msg = await response.text().catch(() => "");
    throw new Error(`Error fetching map entry for map "${mapName}" in contract "${contractName}" at address ${contractAddress}, using map key "${serializedKeyHex}". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
  }
  const responseBody = await response.text();
  const responseJson = JSON.parse(responseBody);
  if (!responseJson.data) {
    throw new Error(`Error fetching map entry for map "${mapName}" in contract "${contractName}" at address ${contractAddress}, using map key "${serializedKeyHex}". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the response: "${responseBody}"`);
  }
  let deserializedCv;
  try {
    deserializedCv = deserializeCV(responseJson.data);
  } catch (error2) {
    throw new Error(`Error deserializing Clarity value "${responseJson.data}": ${error2}`);
  }
  return deserializedCv;
}
async function sponsorTransaction(sponsorOptions) {
  const defaultOptions = {
    fee: 0,
    sponsorNonce: 0,
    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH,
    network: sponsorOptions.transaction.version === TransactionVersion2.Mainnet ? new StacksMainnet() : new StacksTestnet()
  };
  const options = Object.assign(defaultOptions, sponsorOptions);
  const network = StacksNetwork.fromNameOrNetwork(options.network);
  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);
  if (sponsorOptions.fee === void 0 || sponsorOptions.fee === null) {
    let txFee = 0;
    switch (options.transaction.payload.payloadType) {
      case PayloadType.TokenTransfer:
      case PayloadType.SmartContract:
      case PayloadType.VersionedSmartContract:
      case PayloadType.ContractCall:
        const estimatedLen = estimateTransactionByteLength(options.transaction);
        try {
          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1].fee;
        } catch (e) {
          throw e;
        }
        break;
      default:
        throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[options.transaction.payload.payloadType]}`);
    }
    options.transaction.setFee(txFee);
    options.fee = txFee;
  }
  if (sponsorOptions.sponsorNonce === void 0 || sponsorOptions.sponsorNonce === null) {
    const addressVersion = network.version === TransactionVersion2.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;
    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);
    const sponsorNonce = await getNonce(senderAddress, network);
    options.sponsorNonce = sponsorNonce;
  }
  const sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);
  options.transaction.setSponsor(sponsorSpendingCondition);
  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);
  const signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);
  signer.signSponsor(privKey);
  return signer.transaction;
}
function estimateTransactionByteLength(transaction) {
  const hashMode = transaction.auth.spendingCondition.hashMode;
  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];
  if (multiSigHashModes.includes(hashMode)) {
    const multiSigSpendingCondition = transaction.auth.spendingCondition;
    const existingSignatures = multiSigSpendingCondition.fields.filter((field) => field.contents.type === StacksMessageType.MessageSignature).length;
    const totalSignatureLength = (multiSigSpendingCondition.signaturesRequired - existingSignatures) * (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);
    return transaction.serialize().byteLength + totalSignatureLength;
  } else {
    return transaction.serialize().byteLength;
  }
}
async function estimateTransactionFeeWithFallback(transaction, network) {
  try {
    const estimatedLen = estimateTransactionByteLength(transaction);
    return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;
  } catch (error2) {
    if (error2 instanceof NoEstimateAvailableError) {
      return await estimateTransferUnsafe(transaction, network);
    }
    throw error2;
  }
}
function mutatingSignAppendMultiSig(transaction, publicKeys, signerKeys, address2) {
  if (isSingleSig(transaction.auth.spendingCondition)) {
    throw new Error("Transaction is not a multi-sig transaction");
  }
  const signer = new TransactionSigner(transaction);
  const pubs = address2 ? sortPublicKeysForAddress(publicKeys, transaction.auth.spendingCondition.signaturesRequired, transaction.auth.spendingCondition.hashMode, createAddress(address2).hash160) : publicKeys;
  for (const publicKey of pubs) {
    const signerKey = signerKeys.find((key) => bytesToHex(pubKeyfromPrivKey(key).data) === publicKey);
    if (signerKey) {
      signer.signOrigin(createStacksPrivateKey(signerKey));
    } else {
      signer.appendOrigin(publicKeyFromBytes(hexToBytes(publicKey)));
    }
  }
}
function sortPublicKeysForAddress(publicKeys, numSigs, hashMode, hash) {
  const hashUnsorted = addressFromPublicKeys(0, hashMode, numSigs, publicKeys.map(createStacksPublicKey)).hash160;
  if (hashUnsorted === hash)
    return publicKeys;
  const publicKeysSorted = publicKeys.slice().sort();
  const hashSorted = addressFromPublicKeys(0, hashMode, numSigs, publicKeysSorted.map(createStacksPublicKey)).hash160;
  if (hashSorted === hash)
    return publicKeysSorted;
  throw new Error("Failed to find matching multi-sig address given public-keys.");
}

// node_modules/@stacks/transactions/dist/esm/cl.js
var cl_exports = {};
__export(cl_exports, {
  address: () => address,
  bool: () => bool,
  buffer: () => buffer,
  bufferFromAscii: () => bufferFromAscii,
  bufferFromHex: () => bufferFromHex,
  bufferFromUtf8: () => bufferFromUtf8,
  contractPrincipal: () => contractPrincipal,
  deserialize: () => deserialize,
  error: () => error,
  int: () => int,
  list: () => list,
  none: () => none,
  ok: () => ok,
  parse: () => parse,
  prettyPrint: () => prettyPrint,
  principal: () => principal,
  serialize: () => serialize,
  some: () => some,
  standardPrincipal: () => standardPrincipal,
  stringAscii: () => stringAscii,
  stringUtf8: () => stringUtf8,
  stringify: () => stringify,
  tuple: () => tuple,
  uint: () => uint
});

// node_modules/@stacks/transactions/dist/esm/clarity/prettyPrint.js
function formatSpace(space, depth, end = false) {
  if (!space)
    return " ";
  return `
${" ".repeat(space * (depth - (end ? 1 : 0)))}`;
}
function formatList(cv, space, depth = 1) {
  if (cv.list.length === 0)
    return "(list)";
  const spaceBefore = formatSpace(space, depth, false);
  const endSpace = space ? formatSpace(space, depth, true) : "";
  const items = cv.list.map((v) => prettyPrintWithDepth(v, space, depth)).join(spaceBefore);
  return `(list${spaceBefore}${items}${endSpace})`;
}
function formatTuple(cv, space, depth = 1) {
  if (Object.keys(cv.data).length === 0)
    return "{}";
  const items = [];
  for (const [key, value] of Object.entries(cv.data)) {
    items.push(`${key}: ${prettyPrintWithDepth(value, space, depth)}`);
  }
  const spaceBefore = formatSpace(space, depth, false);
  const endSpace = formatSpace(space, depth, true);
  return `{${spaceBefore}${items.sort().join(`,${spaceBefore}`)}${endSpace}}`;
}
function exhaustiveCheck(param) {
  throw new Error(`invalid clarity value type: ${param}`);
}
function prettyPrintWithDepth(cv, space = 0, depth) {
  if (cv.type === ClarityType.BoolFalse)
    return "false";
  if (cv.type === ClarityType.BoolTrue)
    return "true";
  if (cv.type === ClarityType.Int)
    return cv.value.toString();
  if (cv.type === ClarityType.UInt)
    return `u${cv.value.toString()}`;
  if (cv.type === ClarityType.StringASCII)
    return `"${cv.data}"`;
  if (cv.type === ClarityType.StringUTF8)
    return `u"${cv.data}"`;
  if (cv.type === ClarityType.PrincipalContract)
    return `'${principalToString(cv)}`;
  if (cv.type === ClarityType.PrincipalStandard)
    return `'${principalToString(cv)}`;
  if (cv.type === ClarityType.Buffer)
    return `0x${bytesToHex(cv.buffer)}`;
  if (cv.type === ClarityType.OptionalNone)
    return "none";
  if (cv.type === ClarityType.OptionalSome)
    return `(some ${prettyPrintWithDepth(cv.value, space, depth)})`;
  if (cv.type === ClarityType.ResponseOk)
    return `(ok ${prettyPrintWithDepth(cv.value, space, depth)})`;
  if (cv.type === ClarityType.ResponseErr)
    return `(err ${prettyPrintWithDepth(cv.value, space, depth)})`;
  if (cv.type === ClarityType.List) {
    return formatList(cv, space, depth + 1);
  }
  if (cv.type === ClarityType.Tuple) {
    return formatTuple(cv, space, depth + 1);
  }
  exhaustiveCheck(cv);
}
function stringify(cv, space = 0) {
  return prettyPrintWithDepth(cv, space, 0);
}
var prettyPrint = stringify;

// node_modules/@stacks/transactions/dist/esm/clarity/parser.js
function regex(pattern, map) {
  return (s) => {
    const match = s.match(pattern);
    if (!match || match.index !== 0)
      return { success: false };
    return {
      success: true,
      value: match[0],
      rest: s.substring(match[0].length),
      capture: map ? map(match[0]) : void 0
    };
  };
}
function whitespace() {
  return regex(/\s+/);
}
function lazy(c) {
  return (s) => c()(s);
}
function either(combinators) {
  return (s) => {
    for (const c of combinators) {
      const result = c(s);
      if (result.success)
        return result;
    }
    return { success: false };
  };
}
function entire(combinator) {
  return (s) => {
    const result = combinator(s);
    if (!result.success || result.rest)
      return { success: false };
    return result;
  };
}
function optional(c) {
  return (s) => {
    const result = c(s);
    if (result.success)
      return result;
    return {
      success: true,
      value: "",
      rest: s
    };
  };
}
function sequence(combinators, reduce = (v) => v[0]) {
  return (s) => {
    let rest = s;
    let value = "";
    const captures = [];
    for (const c of combinators) {
      const result = c(rest);
      if (!result.success)
        return { success: false };
      rest = result.rest;
      value += result.value;
      if (result.capture)
        captures.push(result.capture);
    }
    return {
      success: true,
      value,
      rest,
      capture: reduce(captures)
    };
  };
}
function chain(combinators, reduce = (v) => v[0]) {
  const joined = combinators.flatMap((combinator, index) => index === 0 ? [combinator] : [optional(whitespace()), combinator]);
  return sequence(joined, reduce);
}
function parens(combinator) {
  return chain([regex(/\(/), combinator, regex(/\)/)]);
}
function greedy(min, combinator, reduce = (v) => v[v.length - 1], separator) {
  return (s) => {
    let rest = s;
    let value = "";
    const captures = [];
    let count;
    for (count = 0; ; count++) {
      const result = combinator(rest);
      if (!result.success)
        break;
      rest = result.rest;
      value += result.value;
      if (result.capture)
        captures.push(result.capture);
      if (separator) {
        const sepResult = separator(rest);
        if (!sepResult.success) {
          count++;
          break;
        }
        rest = sepResult.rest;
        value += sepResult.value;
      }
    }
    if (count < min)
      return { success: false };
    return {
      success: true,
      value,
      rest,
      capture: reduce(captures)
    };
  };
}
function capture(combinator, map) {
  return (s) => {
    const result = combinator(s);
    if (!result.success)
      return { success: false };
    return {
      success: true,
      value: result.value,
      rest: result.rest,
      capture: map ? map(result.value) : result.value
    };
  };
}
function clInt() {
  return capture(regex(/\-?[0-9]+/), (v) => cl_exports.int(parseInt(v)));
}
function clUint() {
  return sequence([regex(/u/), capture(regex(/[0-9]+/), (v) => cl_exports.uint(parseInt(v)))]);
}
function clBool() {
  return capture(regex(/true|false/), (v) => cl_exports.bool(v === "true"));
}
function clPrincipal() {
  return sequence([
    regex(/\'/),
    capture(sequence([regex(/[A-Z0-9]+/), optional(sequence([regex(/\./), regex(/[a-zA-Z0-9\-]+/)]))]), cl_exports.address)
  ]);
}
function clBuffer() {
  return sequence([regex(/0x/), capture(regex(/[0-9a-fA-F]+/), cl_exports.bufferFromHex)]);
}
function unescape(input) {
  return input.replace(/\\\\/g, "\\").replace(/\\(.)/g, "$1");
}
function clAscii() {
  return sequence([
    regex(/"/),
    capture(regex(/(\\.|[^"])*/), (t) => cl_exports.stringAscii(unescape(t))),
    regex(/"/)
  ]);
}
function clUtf8() {
  return sequence([
    regex(/u"/),
    capture(regex(/(\\.|[^"])*/), (t) => cl_exports.stringUtf8(unescape(t))),
    regex(/"/)
  ]);
}
function clList() {
  return parens(sequence([
    regex(/list/),
    greedy(0, sequence([whitespace(), clValue()]), (c) => cl_exports.list(c))
  ]));
}
function clTuple() {
  const tupleCurly = chain([
    regex(/\{/),
    greedy(1, sequence([
      capture(regex(/[a-zA-Z][a-zA-Z0-9_]*/)),
      regex(/\s*\:/),
      whitespace(),
      clValue()
    ], ([k, v]) => cl_exports.tuple({ [k]: v })), (c) => cl_exports.tuple(Object.assign({}, ...c.map((t) => t.data))), regex(/\s*\,\s*/)),
    regex(/\}/)
  ]);
  const tupleFunction = parens(sequence([
    optional(whitespace()),
    regex(/tuple/),
    whitespace(),
    greedy(1, parens(sequence([
      optional(whitespace()),
      capture(regex(/[a-zA-Z][a-zA-Z0-9_]*/)),
      whitespace(),
      clValue(),
      optional(whitespace())
    ], ([k, v]) => cl_exports.tuple({ [k]: v }))), (c) => cl_exports.tuple(Object.assign({}, ...c.map((t) => t.data))), whitespace())
  ]));
  return either([tupleCurly, tupleFunction]);
}
function clNone() {
  return capture(regex(/none/), cl_exports.none);
}
function clSome() {
  return parens(sequence([regex(/some/), whitespace(), clValue()], (c) => cl_exports.some(c[0])));
}
function clOk() {
  return parens(sequence([regex(/ok/), whitespace(), clValue()], (c) => cl_exports.ok(c[0])));
}
function clErr() {
  return parens(sequence([regex(/err/), whitespace(), clValue()], (c) => cl_exports.error(c[0])));
}
function clValue(map = (v) => v) {
  return either([
    clBuffer,
    clAscii,
    clUtf8,
    clInt,
    clUint,
    clBool,
    clPrincipal,
    clList,
    clTuple,
    clNone,
    clSome,
    clOk,
    clErr
  ].map(lazy).map(map));
}
function parse(clarityValueString) {
  const result = clValue(entire)(clarityValueString);
  if (!result.success || !result.capture)
    throw "Parse error";
  return result.capture;
}

// node_modules/@stacks/transactions/dist/esm/cl.js
var bool = boolCV;
var int = intCV;
var uint = uintCV;
function principal(address2) {
  const [addr, name] = address2.split(".");
  return name ? contractPrincipalCV(addr, name) : standardPrincipalCV(addr);
}
var address = principal;
var contractPrincipal = contractPrincipalCV;
var standardPrincipal = standardPrincipalCV;
var list = listCV;
var stringAscii = stringAsciiCV;
var stringUtf8 = stringUtf8CV;
var buffer = bufferCV;
var bufferFromHex = (hex) => bufferCV(hexToBytes(hex));
var bufferFromAscii = (ascii) => bufferCV(asciiToBytes(ascii));
var bufferFromUtf8 = (utf8) => bufferCV(utf8ToBytes(utf8));
var none = noneCV;
var some = someCV;
var ok = responseOkCV;
var error = responseErrorCV;
var tuple = tupleCV;
var serialize = serializeCV;
var deserialize = deserializeCV;

// node_modules/@stacks/transactions/dist/esm/pc.js
var pc_exports = {};
__export(pc_exports, {
  principal: () => principal2
});
function principal2(principal3) {
  if (isContractIdString(principal3)) {
    const [address2, name] = parseContractId(principal3);
    return new PartialPcWithPrincipal(address2, name);
  }
  return new PartialPcWithPrincipal(principal3, void 0);
}
var PartialPcWithPrincipal = class {
  constructor(address2, contractName) {
    this.address = address2;
    this.contractName = contractName;
  }
  willSendEq(amount) {
    return new PartialPcFtWithCode(this.address, amount, FungibleConditionCode.Equal, this.contractName);
  }
  willSendLte(amount) {
    return new PartialPcFtWithCode(this.address, amount, FungibleConditionCode.LessEqual, this.contractName);
  }
  willSendLt(amount) {
    return new PartialPcFtWithCode(this.address, amount, FungibleConditionCode.Less, this.contractName);
  }
  willSendGte(amount) {
    return new PartialPcFtWithCode(this.address, amount, FungibleConditionCode.GreaterEqual, this.contractName);
  }
  willSendGt(amount) {
    return new PartialPcFtWithCode(this.address, amount, FungibleConditionCode.Greater, this.contractName);
  }
  willSendAsset() {
    return new PartialPcNftWithCode(this.address, NonFungibleConditionCode.Sends, this.contractName);
  }
  willNotSendAsset() {
    return new PartialPcNftWithCode(this.address, NonFungibleConditionCode.DoesNotSend, this.contractName);
  }
};
var PartialPcFtWithCode = class {
  constructor(address2, amount, code, contractName) {
    this.address = address2;
    this.amount = amount;
    this.code = code;
    this.contractName = contractName;
  }
  ustx() {
    if (this.contractName) {
      return makeContractSTXPostCondition(this.address, this.contractName, this.code, this.amount);
    }
    return makeStandardSTXPostCondition(this.address, this.code, this.amount);
  }
  ft(contractId, tokenName) {
    const [address2, name] = parseContractId(contractId);
    if (this.contractName) {
      return makeContractFungiblePostCondition(this.address, this.contractName, this.code, this.amount, createAssetInfo(address2, name, tokenName));
    }
    return makeStandardFungiblePostCondition(this.address, this.code, this.amount, createAssetInfo(address2, name, tokenName));
  }
};
var PartialPcNftWithCode = class {
  constructor(principal3, code, contractName) {
    this.principal = principal3;
    this.code = code;
    this.contractName = contractName;
  }
  nft(...args) {
    const { contractAddress, contractName, tokenName, assetId } = getNftArgs(...args);
    if (this.contractName) {
      return makeContractNonFungiblePostCondition(this.principal, this.contractName, this.code, createAssetInfo(contractAddress, contractName, tokenName), assetId);
    }
    return makeStandardNonFungiblePostCondition(this.principal, this.code, createAssetInfo(contractAddress, contractName, tokenName), assetId);
  }
};
function parseContractId(contractId) {
  const [address2, name] = contractId.split(".");
  if (!address2 || !name)
    throw new Error(`Invalid contract identifier: ${contractId}`);
  return [address2, name];
}
function parseNft(nftAssetName) {
  const [principal3, tokenName] = nftAssetName.split("::");
  if (!principal3 || !tokenName)
    throw new Error(`Invalid fully-qualified nft asset name: ${nftAssetName}`);
  const [address2, name] = parseContractId(principal3);
  return { contractAddress: address2, contractName: name, tokenName };
}
function isContractIdString(value) {
  return value.includes(".");
}
function getNftArgs(...args) {
  if (args.length === 2) {
    const [assetName, assetId2] = args;
    return { ...parseNft(assetName), assetId: assetId2 };
  }
  const [contractId, tokenName, assetId] = args;
  const [address2, name] = parseContractId(contractId);
  return { contractAddress: address2, contractName: name, tokenName, assetId };
}

// node_modules/@stacks/transactions/dist/esm/structuredDataSignature.js
var STRUCTURED_DATA_PREFIX = new Uint8Array([83, 73, 80, 48, 49, 56]);
function hashStructuredData(structuredData) {
  return sha256(serializeCV(structuredData));
}
var hash256BytesLength = 32;
function isDomain(value) {
  if (value.type !== ClarityType.Tuple)
    return false;
  if (!["name", "version", "chain-id"].every((key) => key in value.data))
    return false;
  if (!["name", "version"].every((key) => value.data[key].type === ClarityType.StringASCII))
    return false;
  if (value.data["chain-id"].type !== ClarityType.UInt)
    return false;
  return true;
}
function encodeStructuredData({ message, domain }) {
  const structuredDataHash = hashStructuredData(message);
  if (!isDomain(domain)) {
    throw new Error("domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt");
  }
  const domainHash = hashStructuredData(domain);
  return concatBytes(STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash);
}
function decodeStructuredDataSignature(signature) {
  const encodedMessageBytes = typeof signature === "string" ? utf8ToBytes(signature) : signature;
  const domainHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length, STRUCTURED_DATA_PREFIX.length + hash256BytesLength);
  const messageHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);
  return {
    domainHash,
    messageHash
  };
}
function signStructuredData({ message, domain, privateKey }) {
  const structuredDataHash = bytesToHex(sha256(encodeStructuredData({ message, domain })));
  const { data } = signMessageHashRsv({
    messageHash: structuredDataHash,
    privateKey
  });
  return {
    data,
    type: StacksMessageType.StructuredDataSignature
  };
}
export {
  AddressHashMode,
  AddressVersion,
  AnchorMode,
  AnchorModeNames,
  AssetType,
  AuthFieldType,
  AuthType,
  BytesReader,
  CLARITY_INT_BYTE_SIZE,
  CLARITY_INT_SIZE,
  COINBASE_BYTES_LENGTH,
  COMPRESSED_PUBKEY_LENGTH_BYTES,
  ChainID2 as ChainID,
  cl_exports as Cl,
  ClarityAbiTypeId,
  ClarityType,
  ClarityVersion,
  DEFAULT_CHAIN_ID,
  DEFAULT_CORE_NODE_API_URL,
  DEFAULT_TRANSACTION_VERSION,
  FungibleConditionCode,
  MAX_STRING_LENGTH_BYTES,
  MEMO_MAX_LENGTH_BYTES,
  NonFungibleConditionCode,
  PayloadType,
  pc_exports as Pc,
  PostConditionMode,
  PostConditionPrincipalID,
  PostConditionType,
  PubKeyEncoding,
  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,
  STRUCTURED_DATA_PREFIX,
  StacksMessageType,
  StacksTransaction,
  TransactionSigner,
  TransactionVersion2 as TransactionVersion,
  TxRejectedReason,
  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,
  VRF_PROOF_BYTES_LENGTH,
  abiFunctionToString,
  addressFromHashMode,
  addressFromPublicKeys,
  addressFromVersionHash,
  addressHashModeToVersion,
  addressToString,
  anchorModeFromNameOrValue,
  boolCV,
  broadcastRawTransaction,
  broadcastTransaction,
  bufferCV,
  bufferCVFromString,
  callReadOnlyFunction,
  cloneDeep,
  codeBodyString,
  compressPublicKey,
  contractPrincipalCV,
  contractPrincipalCVFromAddress,
  contractPrincipalCVFromStandard,
  createAddress,
  createAssetInfo,
  createContractPrincipal,
  createEmptyAddress,
  createFungiblePostCondition,
  createLPList,
  createLPString,
  createMemoString,
  createMessageSignature,
  createMultiSigSpendingCondition,
  createNonFungiblePostCondition,
  createSTXPostCondition,
  createSingleSigSpendingCondition,
  createSponsoredAuth,
  createStacksPrivateKey,
  createStacksPublicKey,
  createStandardAuth,
  createStandardPrincipal,
  createTransactionAuthField,
  cvToHex,
  cvToJSON,
  cvToString,
  cvToValue,
  decodeStructuredDataSignature,
  deserializeAddress,
  deserializeAssetInfo,
  deserializeAuthorization,
  deserializeCV,
  deserializeLPList,
  deserializeLPString,
  deserializeMemoString,
  deserializeMessageSignature,
  deserializeMultiSigSpendingCondition,
  deserializePostCondition,
  deserializePrincipal,
  deserializePublicKey,
  deserializeSingleSigSpendingCondition,
  deserializeSpendingCondition,
  deserializeStacksMessage,
  deserializeTransaction,
  deserializeTransactionAuthField,
  emptyMessageSignature,
  encodeAbiClarityValue,
  encodeClarityValue,
  encodeStructuredData,
  estimateContractDeploy,
  estimateContractFunctionCall,
  estimateTransaction,
  estimateTransactionByteLength,
  estimateTransactionFeeWithFallback,
  estimateTransfer,
  estimateTransferUnsafe,
  exceedsMaxLengthBytes,
  falseCV,
  getAbi,
  getAddressFromPrivateKey,
  getAddressFromPublicKey,
  getCVTypeString,
  getContractMapEntry,
  getFee,
  getNonce,
  getPublicKey2 as getPublicKey,
  getTypeString,
  getTypeUnion,
  hash160,
  hashP2PKH,
  hashP2SH,
  hashP2WPKH,
  hashP2WSH,
  hashStructuredData,
  hexToCV,
  intCV,
  intoInitialSighashAuth,
  isClarityAbiBuffer,
  isClarityAbiList,
  isClarityAbiOptional,
  isClarityAbiPrimitive,
  isClarityAbiResponse,
  isClarityAbiStringAscii,
  isClarityAbiStringUtf8,
  isClarityAbiTuple,
  isClarityName,
  isClarityType,
  isCoinbasePayload,
  isCompressed,
  isContractCallPayload,
  isNonSequentialMultiSig,
  isPoisonPayload,
  isSequentialMultiSig,
  isSingleSig,
  isSmartContractPayload,
  isTokenTransferPayload,
  leftPadHex,
  leftPadHexToLength,
  listCV,
  makeContractCall,
  makeContractDeploy,
  makeContractFungiblePostCondition,
  makeContractNonFungiblePostCondition,
  makeContractSTXPostCondition,
  makeRandomPrivKey,
  makeSTXTokenTransfer,
  makeSigHashPreSign,
  makeStandardFungiblePostCondition,
  makeStandardNonFungiblePostCondition,
  makeStandardSTXPostCondition,
  makeUnsignedContractCall,
  makeUnsignedContractDeploy,
  makeUnsignedSTXTokenTransfer,
  nextSignature,
  nextVerification,
  noneCV,
  omit,
  optionalCVOf,
  parseAssetInfoString,
  parsePrincipalString,
  parseReadOnlyResponse,
  parseToCV,
  principalCV,
  principalToString,
  privateKeyToString,
  pubKeyfromPrivKey,
  publicKeyFromBytes,
  publicKeyFromSignatureRsv,
  publicKeyFromSignatureVrs,
  publicKeyToAddress,
  publicKeyToString,
  randomBytes,
  responseErrorCV,
  responseOkCV,
  rightPadHexToLength,
  serializeAddress,
  serializeAssetInfo,
  serializeAuthorization,
  serializeCV,
  serializeLPList,
  serializeLPString,
  serializeMemoString,
  serializeMessageSignature,
  serializeMultiSigSpendingCondition,
  serializePayload,
  serializePostCondition,
  serializePrincipal,
  serializePublicKey,
  serializeSingleSigSpendingCondition,
  serializeSpendingCondition,
  serializeStacksMessage,
  serializeTransactionAuthField,
  setFee,
  setNonce,
  setSponsor,
  setSponsorNonce,
  signMessageHashRsv,
  signStructuredData,
  signWithKey,
  someCV,
  sponsorTransaction,
  standardPrincipalCV,
  standardPrincipalCVFromAddress,
  stringAsciiCV,
  stringCV,
  stringUtf8CV,
  trueCV,
  tupleCV,
  txidFromBytes,
  txidFromData,
  uintCV,
  uncompressPublicKey,
  validateContractCall,
  validateStacksAddress,
  validateTxId,
  verifyOrigin,
  verify as verifySignature,
  whenMessageType
};
//# sourceMappingURL=@stacks_transactions.js.map
