{
  "version": 3,
  "sources": ["../../@stacks/transactions/node_modules/@stacks/common/src/errors.ts", "../../@stacks/transactions/node_modules/@stacks/common/src/logger.ts", "../../@stacks/transactions/node_modules/@stacks/common/src/utils.ts", "../../@stacks/transactions/node_modules/@stacks/common/src/constants.ts", "../../@stacks/transactions/node_modules/@stacks/common/src/signatures.ts", "../../@stacks/transactions/node_modules/@stacks/common/src/keys.ts", "../../@stacks/transactions/node_modules/@stacks/common/src/buffer.ts", "../../@stacks/transactions/src/constants.ts", "../../@stacks/transactions/src/utils.ts", "../../@stacks/transactions/src/common.ts", "../../@stacks/transactions/src/postcondition-types.ts", "../../@stacks/transactions/src/clarity/constants.ts", "../../@stacks/transactions/src/clarity/types/principalCV.ts", "../../@stacks/transactions/src/clarity/clarityValue.ts", "../../@stacks/transactions/src/clarity/types/booleanCV.ts", "../../@stacks/transactions/src/clarity/types/intCV.ts", "../../@stacks/transactions/src/clarity/types/bufferCV.ts", "../../@stacks/transactions/src/clarity/types/optionalCV.ts", "../../@stacks/transactions/src/clarity/types/responseCV.ts", "../../@stacks/transactions/src/clarity/types/listCV.ts", "../../@stacks/transactions/src/clarity/types/tupleCV.ts", "../../@stacks/transactions/src/clarity/types/stringCV.ts", "../../@stacks/transactions/src/keys.ts", "../../@stacks/transactions/src/payload.ts", "../../@stacks/transactions/src/errors.ts", "../../@stacks/transactions/src/signature.ts", "../../@stacks/transactions/src/types.ts", "../../@stacks/transactions/src/clarity/serialize.ts", "../../@stacks/transactions/src/bytesReader.ts", "../../@stacks/transactions/src/clarity/deserialize.ts", "../../@stacks/transactions/src/authorization.ts", "../../@stacks/transactions/src/builders.ts", "../../@stacks/transactions/src/contract-abi.ts", "../../@stacks/transactions/src/postcondition.ts", "../../@stacks/transactions/src/signer.ts", "../../@stacks/transactions/src/transaction.ts", "../../@stacks/transactions/src/cl.ts", "../../@stacks/transactions/src/clarity/prettyPrint.ts", "../../@stacks/transactions/src/clarity/parser.ts", "../../@stacks/transactions/src/pc.ts", "../../@stacks/transactions/src/structuredDataSignature.ts"],
  "sourcesContent": ["/**\n * @ignore\n */\nexport const ERROR_CODES = {\n  MISSING_PARAMETER: 'missing_parameter',\n  REMOTE_SERVICE_ERROR: 'remote_service_error',\n  INVALID_STATE: 'invalid_state',\n  NO_SESSION_DATA: 'no_session_data',\n  DOES_NOT_EXIST: 'does_not_exist',\n  FAILED_DECRYPTION_ERROR: 'failed_decryption_error',\n  INVALID_DID_ERROR: 'invalid_did_error',\n  NOT_ENOUGH_FUNDS_ERROR: 'not_enough_error',\n  INVALID_AMOUNT_ERROR: 'invalid_amount_error',\n  LOGIN_FAILED_ERROR: 'login_failed',\n  SIGNATURE_VERIFICATION_ERROR: 'signature_verification_failure',\n  CONFLICT_ERROR: 'conflict_error',\n  NOT_ENOUGH_PROOF_ERROR: 'not_enough_proof_error',\n  BAD_PATH_ERROR: 'bad_path_error',\n  VALIDATION_ERROR: 'validation_error',\n  PAYLOAD_TOO_LARGE_ERROR: 'payload_too_large_error',\n  PRECONDITION_FAILED_ERROR: 'precondition_failed_error',\n  UNKNOWN: 'unknown',\n};\n\nObject.freeze(ERROR_CODES);\n\n/**\n * @ignore\n */\ntype ErrorData = {\n  code: string;\n  parameter?: string;\n  message: string;\n};\n\n/**\n * @ignore\n */\nexport class BlockstackError extends Error {\n  message: string;\n\n  code: string;\n\n  parameter?: string;\n\n  constructor(error: ErrorData) {\n    super();\n    let message = error.message;\n    let bugDetails = `Error Code: ${error.code}`;\n    let stack = this.stack;\n    if (!stack) {\n      try {\n        throw new Error();\n      } catch (e: any) {\n        stack = e.stack;\n      }\n    } else {\n      bugDetails += `Stack Trace:\\n${stack}`;\n    }\n    message += `\\nIf you believe this exception is caused by a bug in stacks.js,\n      please file a bug report: https://github.com/blockstack/stacks.js/issues\\n\\n${bugDetails}`;\n    this.message = message;\n    this.code = error.code;\n    this.parameter = error.parameter ? error.parameter : undefined;\n  }\n\n  toString() {\n    return `${super.toString()}\n    code: ${this.code} param: ${this.parameter ? this.parameter : 'n/a'}`;\n  }\n}\n\n/**\n * @ignore\n */\nexport class InvalidParameterError extends BlockstackError {\n  constructor(parameter: string, message: string = '') {\n    super({ code: ERROR_CODES.MISSING_PARAMETER, message, parameter });\n    this.name = 'MissingParametersError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class MissingParameterError extends BlockstackError {\n  constructor(parameter: string, message: string = '') {\n    super({ code: ERROR_CODES.MISSING_PARAMETER, message, parameter });\n    this.name = 'MissingParametersError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class RemoteServiceError extends BlockstackError {\n  response: Response;\n\n  constructor(response: Response, message: string = '') {\n    super({ code: ERROR_CODES.REMOTE_SERVICE_ERROR, message });\n    this.response = response;\n  }\n}\n\n/**\n * @ignore\n */\nexport class InvalidDIDError extends BlockstackError {\n  constructor(message: string = '') {\n    super({ code: ERROR_CODES.INVALID_DID_ERROR, message });\n    this.name = 'InvalidDIDError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class NotEnoughFundsError extends BlockstackError {\n  leftToFund: number;\n\n  constructor(leftToFund: number) {\n    const message = `Not enough UTXOs to fund. Left to fund: ${leftToFund}`;\n    super({ code: ERROR_CODES.NOT_ENOUGH_FUNDS_ERROR, message });\n    this.leftToFund = leftToFund;\n    this.name = 'NotEnoughFundsError';\n    this.message = message;\n  }\n}\n\n/**\n * @ignore\n */\nexport class InvalidAmountError extends BlockstackError {\n  fees: number;\n\n  specifiedAmount: number;\n\n  constructor(fees: number, specifiedAmount: number) {\n    const message =\n      `Not enough coin to fund fees transaction fees. Fees would be ${fees},` +\n      ` specified spend is  ${specifiedAmount}`;\n    super({ code: ERROR_CODES.INVALID_AMOUNT_ERROR, message });\n    this.specifiedAmount = specifiedAmount;\n    this.fees = fees;\n    this.name = 'InvalidAmountError';\n    this.message = message;\n  }\n}\n\n/**\n * @ignore\n */\nexport class LoginFailedError extends BlockstackError {\n  constructor(reason: string) {\n    const message = `Failed to login: ${reason}`;\n    super({ code: ERROR_CODES.LOGIN_FAILED_ERROR, message });\n    this.message = message;\n    this.name = 'LoginFailedError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class SignatureVerificationError extends BlockstackError {\n  constructor(reason: string) {\n    const message = `Failed to verify signature: ${reason}`;\n    super({ code: ERROR_CODES.SIGNATURE_VERIFICATION_ERROR, message });\n    this.message = message;\n    this.name = 'SignatureVerificationError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class FailedDecryptionError extends BlockstackError {\n  constructor(message: string = 'Unable to decrypt cipher object.') {\n    super({ code: ERROR_CODES.FAILED_DECRYPTION_ERROR, message });\n    this.message = message;\n    this.name = 'FailedDecryptionError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class InvalidStateError extends BlockstackError {\n  constructor(message: string) {\n    super({ code: ERROR_CODES.INVALID_STATE, message });\n    this.message = message;\n    this.name = 'InvalidStateError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class NoSessionDataError extends BlockstackError {\n  constructor(message: string) {\n    super({ code: ERROR_CODES.INVALID_STATE, message });\n    this.message = message;\n    this.name = 'NoSessionDataError';\n  }\n}\n\n/**\n * @ignore\n */\nexport interface GaiaHubErrorResponse {\n  status: number;\n  statusText: string;\n  body?: any; // todo: should this be string?\n}\n\nexport interface HubErrorDetails {\n  message?: string;\n  statusCode: number;\n  statusText: string;\n  [prop: string]: any;\n}\n\n/**\n * @ignore\n */\nexport class GaiaHubError extends BlockstackError {\n  hubError?: HubErrorDetails;\n\n  constructor(error: ErrorData, response: GaiaHubErrorResponse) {\n    super(error);\n    if (response) {\n      this.hubError = {\n        statusCode: response.status,\n        statusText: response.statusText,\n      };\n      if (typeof response.body === 'string') {\n        this.hubError.message = response.body;\n      } else if (typeof response.body === 'object') {\n        Object.assign(this.hubError, response.body);\n      }\n    }\n  }\n}\n\n/**\n * @ignore\n */\nexport class DoesNotExist extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.DOES_NOT_EXIST }, response);\n    this.name = 'DoesNotExist';\n  }\n}\n\n/**\n * @ignore\n */\nexport class ConflictError extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.CONFLICT_ERROR }, response);\n    this.name = 'ConflictError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class NotEnoughProofError extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.NOT_ENOUGH_PROOF_ERROR }, response);\n    this.name = 'NotEnoughProofError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class BadPathError extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.BAD_PATH_ERROR }, response);\n    this.name = 'BadPathError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class ValidationError extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.VALIDATION_ERROR }, response);\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class PayloadTooLargeError extends GaiaHubError {\n  /** Can be `null` when an oversized payload is detected client-side. */\n  hubError?: HubErrorDetails;\n\n  maxUploadByteSize: number;\n\n  constructor(message: string, response: GaiaHubErrorResponse | null, maxUploadByteSize: number) {\n    super({ message, code: ERROR_CODES.PAYLOAD_TOO_LARGE_ERROR }, response!);\n    this.name = 'PayloadTooLargeError';\n    this.maxUploadByteSize = maxUploadByteSize;\n  }\n}\n\n/**\n * @ignore\n */\nexport class PreconditionFailedError extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.PRECONDITION_FAILED_ERROR }, response);\n    this.name = 'PreconditionFailedError';\n  }\n}\n", "import { config } from './config';\n\nconst levels = ['debug', 'info', 'warn', 'error', 'none'];\n\nconst levelToInt: { [level: string]: number } = {};\nconst intToLevel: { [int: number]: string } = {};\n\nfor (let index = 0; index < levels.length; index++) {\n  const level = levels[index];\n  levelToInt[level] = index;\n  intToLevel[index] = level;\n}\n\n/**\n * @ignore\n */\nexport class Logger {\n  static error(message: string) {\n    if (!this.shouldLog('error')) return;\n    console.error(this.logMessage('error', message));\n  }\n\n  static warn(message: string) {\n    if (!this.shouldLog('warn')) return;\n    console.warn(this.logMessage('warn', message));\n  }\n\n  static info(message: string) {\n    if (!this.shouldLog('info')) return;\n    console.log(this.logMessage('info', message));\n  }\n\n  static debug(message: string) {\n    if (!this.shouldLog('debug')) return;\n    console.log(this.logMessage('debug', message));\n  }\n\n  static logMessage(level: string, message: string) {\n    return `[${level.toUpperCase()}] ${message}`;\n  }\n\n  static shouldLog(level: string) {\n    const currentLevel = levelToInt[config.logLevel];\n    return currentLevel <= levelToInt[level];\n  }\n}\n", "import { Logger } from './logger';\n\n/**\n *  @ignore\n */\nexport const BLOCKSTACK_HANDLER = 'blockstack';\n\n/**\n * Time\n * @private\n * @ignore\n */\nexport function nextYear() {\n  return new Date(new Date().setFullYear(new Date().getFullYear() + 1));\n}\n\n/**\n * Time\n * @private\n * @ignore\n */\nexport function nextMonth() {\n  return new Date(new Date().setMonth(new Date().getMonth() + 1));\n}\n\n/**\n * Time\n * @private\n * @ignore\n */\nexport function nextHour() {\n  return new Date(new Date().setHours(new Date().getHours() + 1));\n}\n\n/**\n * Converts megabytes to bytes. Returns 0 if the input is not a finite number.\n * @ignore\n */\nexport function megabytesToBytes(megabytes: number): number {\n  if (!Number.isFinite(megabytes)) {\n    return 0;\n  }\n  return Math.floor(megabytes * 1024 * 1024);\n}\n\n/**\n * Calculate the AES-CBC ciphertext output byte length a given input length.\n * AES has a fixed block size of 16-bytes regardless key size.\n * @ignore\n */\nexport function getAesCbcOutputLength(inputByteLength: number) {\n  // AES-CBC block mode rounds up to the next block size.\n  const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;\n  return cipherTextLength;\n}\n\n/**\n * Calculate the base64 encoded string length for a given input length.\n * This is equivalent to the byte length when the string is ASCII or UTF8-8\n * encoded.\n * @param number\n */\nexport function getBase64OutputLength(inputByteLength: number) {\n  const encodedLength = Math.ceil(inputByteLength / 3) * 4;\n  return encodedLength;\n}\n\n/**\n * Query Strings\n * @private\n * @ignore\n */\n\nexport function updateQueryStringParameter(uri: string, key: string, value: string) {\n  const re = new RegExp(`([?&])${key}=.*?(&|$)`, 'i');\n  const separator = uri.indexOf('?') !== -1 ? '&' : '?';\n  if (uri.match(re)) {\n    return uri.replace(re, `$1${key}=${value}$2`);\n  } else {\n    return `${uri}${separator}${key}=${value}`;\n  }\n}\n\n/**\n * Versioning\n * @param {string} v1 - the left half of the version inequality\n * @param {string} v2 - right half of the version inequality\n * @returns {bool} iff v1 >= v2\n * @private\n * @ignore\n */\n\nexport function isLaterVersion(v1: string, v2: string) {\n  if (v1 === undefined || v1 === '') {\n    v1 = '0.0.0';\n  }\n\n  if (v2 === undefined || v1 === '') {\n    v2 = '0.0.0';\n  }\n\n  const v1tuple = v1.split('.').map(x => parseInt(x, 10));\n  const v2tuple = v2.split('.').map(x => parseInt(x, 10));\n\n  for (let index = 0; index < v2.length; index++) {\n    if (index >= v1.length) {\n      v2tuple.push(0);\n    }\n    if (v1tuple[index] < v2tuple[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * UUIDs\n * @private\n * @ignore\n */\nexport function makeUUID4() {\n  let d = new Date().getTime();\n  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n    d += performance.now(); // use high-precision timer if available\n  }\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n\n/**\n * Checks if both urls pass the same origin check & are absolute\n * @param  {[type]}  uri1 first uri to check\n * @param  {[type]}  uri2 second uri to check\n * @return {Boolean} true if they pass the same origin check\n * @private\n * @ignore\n */\nexport function isSameOriginAbsoluteUrl(uri1: string, uri2: string) {\n  try {\n    const parsedUri1 = new URL(uri1);\n    const parsedUri2 = new URL(uri2);\n\n    const port1 =\n      parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);\n    const port2 =\n      parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);\n\n    const match = {\n      scheme: parsedUri1.protocol === parsedUri2.protocol,\n      hostname: parsedUri1.hostname === parsedUri2.hostname,\n      port: port1 === port2,\n      absolute:\n        (uri1.includes('http://') || uri1.includes('https://')) &&\n        (uri2.includes('http://') || uri2.includes('https://')),\n    };\n\n    return match.scheme && match.hostname && match.port && match.absolute;\n  } catch (error) {\n    console.log(error);\n    console.log('Parsing error in same URL origin check');\n    // Parse error\n    return false;\n  }\n}\n\n/**\n * Returns the global scope `Window`, `WorkerGlobalScope`, or `NodeJS.Global` if available in the\n * currently executing environment.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/self\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope\n *\n * This could be switched to `globalThis` once it is standardized and widely available.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\n * @ignore\n */\nexport function getGlobalScope(): Window {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  // This function is meant to be called when accessing APIs that are typically only available in\n  // web-browser/DOM environments, but we also want to support situations where running in Node.js\n  // environment, and a polyfill was added to the Node.js `global` object scope without adding the\n  // `window` global object as well.\n  if (typeof global !== 'undefined') {\n    return global as unknown as Window;\n  }\n  throw new Error(\n    'Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available'\n  );\n}\n\nfunction getAPIUsageErrorMessage(\n  scopeObject: unknown,\n  apiName: string,\n  usageDesc?: string\n): string {\n  if (usageDesc) {\n    return `Use of '${usageDesc}' requires \\`${apiName}\\` which is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n  } else {\n    return `\\`${apiName}\\` is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n  }\n}\n\ninterface GetGlobalObjectOptions {\n  /**\n   * Throw an error if the object is not found.\n   * @default false\n   */\n  throwIfUnavailable?: boolean;\n  /**\n   * Additional information to include in an error if thrown.\n   */\n  usageDesc?: string;\n  /**\n   * If the object is not found, return an new empty object instead of undefined.\n   * Requires [[throwIfUnavailable]] to be falsey.\n   * @default false\n   */\n  returnEmptyObject?: boolean;\n}\n\n/**\n * Returns an object from the global scope (`Window` or `WorkerGlobalScope`) if it\n * is available within the currently executing environment.\n * When executing within the Node.js runtime these APIs are unavailable and will be\n * `undefined` unless the API is provided via polyfill.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @ignore\n */\nexport function getGlobalObject<K extends Extract<keyof Window, string>>(\n  name: K,\n  { throwIfUnavailable, usageDesc, returnEmptyObject }: GetGlobalObjectOptions = {}\n): Window[K] | undefined {\n  let globalScope: Window | undefined = undefined;\n  try {\n    globalScope = getGlobalScope();\n    if (globalScope) {\n      const obj = globalScope[name];\n      if (obj) {\n        return obj;\n      }\n    }\n  } catch (error) {\n    Logger.error(`Error getting object '${name}' from global scope '${globalScope}': ${error}`);\n  }\n  if (throwIfUnavailable) {\n    const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n    Logger.error(errMsg);\n    throw new Error(errMsg);\n  }\n  if (returnEmptyObject) {\n    return {} as any;\n  }\n  return undefined;\n}\n\n/**\n * Returns a specified subset of objects from the global scope (`Window` or `WorkerGlobalScope`)\n * if they are available within the currently executing environment.\n * When executing within the Node.js runtime these APIs are unavailable will be `undefined`\n * unless the API is provided via polyfill.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @ignore\n */\nexport function getGlobalObjects<K extends Extract<keyof Window, string>>(\n  names: K[],\n  { throwIfUnavailable, usageDesc, returnEmptyObject }: GetGlobalObjectOptions = {}\n): Pick<Window, K> {\n  let globalScope: Window | undefined;\n  try {\n    globalScope = getGlobalScope();\n  } catch (error) {\n    Logger.error(`Error getting global scope: ${error}`);\n    if (throwIfUnavailable) {\n      const errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);\n      Logger.error(errMsg);\n      throw errMsg;\n    } else if (returnEmptyObject) {\n      globalScope = {} as any;\n    }\n  }\n\n  const result: Pick<Window, K> = {} as any;\n  for (let i = 0; i < names.length; i++) {\n    const name = names[i];\n    try {\n      if (globalScope) {\n        const obj = globalScope[name];\n        if (obj) {\n          result[name] = obj;\n        } else if (throwIfUnavailable) {\n          const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n          Logger.error(errMsg);\n          throw new Error(errMsg);\n        } else if (returnEmptyObject) {\n          result[name] = {} as any;\n        }\n      }\n    } catch (error) {\n      if (throwIfUnavailable) {\n        const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n        Logger.error(errMsg);\n        throw new Error(errMsg);\n      }\n    }\n  }\n  return result;\n}\n// After removing bn.js library provide backward compatibility for users passing bn.js instance\ntype BN = import('bn.js'); // Type only import from @types/bn.js\nexport type IntegerType = number | string | bigint | Uint8Array | BN;\n\nexport function intToBytes(value: IntegerType, signed: boolean, byteLength: number): Uint8Array {\n  return bigIntToBytes(intToBigInt(value, signed), byteLength);\n}\n\nexport function intToBigInt(value: IntegerType, signed: boolean): bigint {\n  let parsedValue = value;\n\n  if (typeof parsedValue === 'number') {\n    if (!Number.isInteger(parsedValue)) {\n      throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);\n    }\n    if (parsedValue > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError(\n        `Invalid value. Values of type 'number' must be less than or equal to ${Number.MAX_SAFE_INTEGER}. For larger values, try using a BigInt instead.`\n      );\n    }\n    return BigInt(parsedValue);\n  }\n  if (typeof parsedValue === 'string') {\n    // If hex string then convert to bytes then fall through to the bytes condition\n    if (parsedValue.toLowerCase().startsWith('0x')) {\n      // Trim '0x' hex-prefix\n      let hex = parsedValue.slice(2);\n\n      // Allow odd-length strings like `0xf` -- some libs output these, or even just `0x${num.toString(16)}`\n      hex = hex.padStart(hex.length + (hex.length % 2), '0');\n\n      parsedValue = hexToBytes(hex);\n    } else {\n      try {\n        return BigInt(parsedValue);\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);\n        }\n      }\n    }\n  }\n  if (typeof parsedValue === 'bigint') {\n    return parsedValue;\n  }\n  if (parsedValue instanceof Uint8Array) {\n    if (signed) {\n      // Allow byte arrays smaller than 128-bits to be passed.\n      // This allows positive signed ints like `0x08` (8) or negative signed\n      // ints like `0xf8` (-8) to be passed without having to pad to 16 bytes.\n      const bn = fromTwos(\n        BigInt(`0x${bytesToHex(parsedValue)}`),\n        BigInt(parsedValue.byteLength * 8)\n      );\n      return BigInt(bn.toString());\n    } else {\n      return BigInt(`0x${bytesToHex(parsedValue)}`);\n    }\n  }\n  // After removing bn.js library provide backward compatibility for users passing bn.js instance\n  // For backward compatibility with bn.js check if it's a bn.js instance\n  if (\n    parsedValue != null &&\n    typeof parsedValue === 'object' &&\n    parsedValue.constructor.name === 'BN'\n  ) {\n    return BigInt(parsedValue.toString());\n  }\n  throw new TypeError(\n    `Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array.`\n  );\n}\n\n/**\n * Adds a `0x` prefix to a string if it does not already have one.\n */\nexport function with0x(value: string): string {\n  return value.startsWith('0x') ? value : `0x${value}`;\n}\n\n/**\n * Converts hex input string to bigint\n * @param hex - hex input string without 0x prefix and in big endian format\n * @example \"6c7cde4d702830c1db34ef7c19e2776f59107afef39084776fc88bc78dbb9656\"\n * @ignore\n */\nexport function hexToBigInt(hex: string): bigint {\n  if (typeof hex !== 'string')\n    throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);\n  // Big Endian\n  return BigInt(`0x${hex}`);\n}\n\n/**\n * Converts IntegerType to hex string\n * @ignore\n */\nexport function intToHex(integer: IntegerType, lengthBytes = 8): string {\n  const value = typeof integer === 'bigint' ? integer : intToBigInt(integer, false);\n  return value.toString(16).padStart(lengthBytes * 2, '0');\n}\n\n/**\n * Converts hex string to integer\n * @ignore\n */\nexport function hexToInt(hex: string): number {\n  return parseInt(hex, 16);\n}\n\n/**\n * Converts bigint to byte array\n * @param value bigint value to be converted\n * @param length byte array optional length\n * @return {Uint8Array} byte array\n */\nexport function bigIntToBytes(value: bigint, length: number = 16): Uint8Array {\n  const hex = intToHex(value, length);\n  return hexToBytes(hex);\n}\n\n/**\n * Converts from signed number to two's complement\n * MIN_VALUE = -(1 << (width - 1))\n * MAX_VALUE =  (1 << (width - 1)) - 1\n * @ignore\n */\nexport function toTwos(value: bigint, width: bigint): bigint {\n  if (\n    value < -(BigInt(1) << (width - BigInt(1))) ||\n    (BigInt(1) << (width - BigInt(1))) - BigInt(1) < value\n  ) {\n    throw `Unable to represent integer in width: ${width}`;\n  }\n  if (value >= BigInt(0)) {\n    return BigInt(value);\n  }\n  return value + (BigInt(1) << width);\n}\n\n/**\n * Returns nth bit (right-to-left, zero-indexed)\n */\nfunction nthBit(value: bigint, n: bigint) {\n  return value & (BigInt(1) << n);\n}\n\n/**\n * Converts from two's complement to signed number\n * @ignore\n */\nexport function fromTwos(value: bigint, width: bigint) {\n  if (nthBit(value, width - BigInt(1))) {\n    return value - (BigInt(1) << width);\n  }\n  return value;\n}\n\n// The following methods are based on `@noble/hashes` implementation\n// https://github.com/paulmillr/noble-hashes\n// Copyright (c) 2022 Paul Miller (https://paulmillr.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the “Software”), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\nconst hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n\n/**\n * Converts bytes to the equivalent hex string\n * @example\n * ```\n * bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef])) // 'deadbeef'\n * ```\n */\nexport function bytesToHex(uint8a: Uint8Array): string {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n  for (const u of uint8a) {\n    hex += hexes[u];\n  }\n  return hex;\n}\n\n/**\n * Converts a hex string to the equivalent bytes\n * @example\n * ```\n * hexToBytes('deadbeef') // Uint8Array(4) [ 222, 173, 190, 239 ]\n * hexToBytes('0xdeadbeef') // Uint8Array(4) [ 222, 173, 190, 239 ]\n * ```\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') {\n    throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);\n  }\n\n  // todo: add use `without0x` from current `next` to replace duplicate trimming code\n  hex = hex.startsWith('0x') || hex.startsWith('0X') ? hex.slice(2) : hex; // remove 0x prefix\n\n  const paddedHex = hex.length % 2 ? `0${hex}` : hex; // left pad with a zero if odd length\n  const array = new Uint8Array(paddedHex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = paddedHex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts a UTF-8 string to the equivalent bytes\n * @example\n * ```\n * utf8ToBytes('stacks Ӿ'); // Uint8Array(9) [ 115, 116, 97, 99, 107, 115, 32, 211, 190 ];\n * ```\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  return new TextEncoder().encode(str);\n}\n\n/**\n * Converts bytes to the equivalent UTF-8 string\n * @example\n * ```\n * bytesToUtf8(Uint8Array.from([115, 116, 97, 99, 107, 115, 32, 211, 190])); // 'stacks Ӿ'\n * ```\n */\nexport function bytesToUtf8(arr: Uint8Array): string {\n  return new TextDecoder().decode(arr);\n}\n\n/**\n * Converts an ASCII string to the equivalent bytes\n * @example\n * ```\n * asciiToBytes('stacks $'); // Uint8Array(8) [ 115, 116, 97, 99, 107, 115, 32, 36 ]\n * ```\n */\nexport function asciiToBytes(str: string) {\n  const byteArray = [];\n  for (let i = 0; i < str.length; i++) {\n    byteArray.push(str.charCodeAt(i) & 0xff); // ignore second bytes of UTF-16 character\n  }\n  return new Uint8Array(byteArray);\n}\n\n/**\n * Converts bytes to the equivalent ASCII string\n * @example\n * ```\n * bytesToAscii(Uint8Array.from([115, 116, 97, 99, 107, 115, 32, 36])); // 'stacks $'\n * ```\n */\nexport function bytesToAscii(arr: Uint8Array) {\n  return String.fromCharCode.apply(null, arr as any as number[]);\n}\n\nfunction isNotOctet(octet: number) {\n  return !Number.isInteger(octet) || octet < 0 || octet > 255;\n}\n\n/** @ignore */\nexport function octetsToBytes(numbers: number[]) {\n  if (numbers.some(isNotOctet)) throw new Error('Some values are invalid bytes.');\n  return new Uint8Array(numbers);\n}\n\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n * @ignore\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\n\n/** @ignore */\nexport function concatArray(elements: (Uint8Array | number[] | number)[]) {\n  return concatBytes(\n    ...elements.map(e => {\n      if (typeof e === 'number') return octetsToBytes([e]);\n      if (e instanceof Array) return octetsToBytes(e);\n      return e;\n    })\n  );\n}\n\n/**\n * Better `instanceof` check for types in different environments\n * @ignore\n */\nexport function isInstance(object: any, type: any) {\n  return object instanceof type || object?.constructor?.name?.toLowerCase() === type.name;\n}\n", "/**\n * The **chain** ID.\n * Is used for signing, so transactions can't be replayed on other chains.\n */\nexport enum ChainID {\n  Testnet = 0x80000000,\n  Mainnet = 0x00000001,\n}\n\n/**\n * The **transaction** version.\n * Is used for signing, so transactions can't be replayed on other networks.\n */\nexport enum TransactionVersion {\n  Mainnet = 0x00,\n  Testnet = 0x80,\n}\n\n/**\n * The **peer** network ID.\n * Typically not used in signing, but used for broadcasting to the P2P network.\n * It can also be used to determine the parent of a subnet.\n *\n * **Attention:**\n * For mainnet/testnet the v2/info response `.network_id` refers to the chain ID.\n * For subnets the v2/info response `.network_id` refers to the peer network ID and the chain ID (they are the same for subnets).\n * The `.parent_network_id` refers to the actual peer network ID (of the parent) in both cases.\n */\nexport enum PeerNetworkID {\n  Mainnet = 0x17000000,\n  Testnet = 0xff000000,\n}\n\n/** @ignore internal */\nexport const PRIVATE_KEY_COMPRESSED_LENGTH = 33;\n// todo: `next` make length consts more consistent in naming\n\n/** @ignore internal */\nexport const PRIVATE_KEY_UNCOMPRESSED_LENGTH = 32;\n\n/** @ignore internal */\nexport const BLOCKSTACK_DEFAULT_GAIA_HUB_URL = 'https://hub.blockstack.org';\n", "import { hexToInt } from './utils';\n\nconst COORDINATE_BYTES = 32;\n\n/** @ignore */\nexport function parseRecoverableSignatureVrs(signature: string) {\n  // todo: prefer RSV format or add format options of message signing functions\n  if (signature.length < COORDINATE_BYTES * 2 * 2 + 1) {\n    throw new Error('Invalid signature');\n  }\n  const recoveryIdHex = signature.slice(0, 2);\n  const r = signature.slice(2, 2 + COORDINATE_BYTES * 2);\n  const s = signature.slice(2 + COORDINATE_BYTES * 2);\n  return {\n    recoveryId: hexToInt(recoveryIdHex),\n    r,\n    s,\n  };\n}\n\n/** @ignore */\nexport function signatureVrsToRsv(signature: string) {\n  return signature.slice(2) + signature.slice(0, 2);\n}\n\n/** @ignore */\nexport function signatureRsvToVrs(signature: string) {\n  return signature.slice(-2) + signature.slice(0, -2);\n}\n", "import { hexToBytes } from './utils';\n\n/**\n * @private\n * @ignore\n */\nexport function privateKeyToBytes(privateKey: string | Uint8Array): Uint8Array {\n  const privateKeyBuffer = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;\n\n  if (privateKeyBuffer.length != 32 && privateKeyBuffer.length != 33) {\n    throw new Error(\n      `Improperly formatted private-key. Private-key byte length should be 32 or 33. Length provided: ${privateKeyBuffer.length}`\n    );\n  }\n\n  if (privateKeyBuffer.length == 33 && privateKeyBuffer[32] !== 1) {\n    throw new Error(\n      'Improperly formatted private-key. 33 bytes indicate compressed key, but the last byte must be == 01'\n    );\n  }\n\n  return privateKeyBuffer;\n}\n", "/** @ignore */\nexport function equals(a: Uint8Array, b: Uint8Array) {\n  if (a.byteLength !== b.byteLength) return false;\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\n/**\n * @ignore\n * TODO: maybe remove and use string repeat\n */\nexport function alloc(length: number, value: number) {\n  const a = new Uint8Array(length);\n  for (let i = 0; i < length; i++) {\n    a[i] = value;\n  }\n  return a;\n}\n\n/** @ignore */\nexport function readUInt16BE(source: Uint8Array, offset: number): number {\n  return ((source[offset + 0] << 8) | source[offset + 1]) >>> 0;\n}\n\n/** @ignore */\nexport function writeUInt16BE(destination: Uint8Array, value: number, offset = 0): Uint8Array {\n  destination[offset + 0] = value >>> 8;\n  destination[offset + 1] = value >>> 0;\n  return destination;\n}\n\n// The following methods are based on `microsoft/vscode` implementation\n// https://github.com/microsoft/vscode/blob/1e6ac12df197fc3e5d1c1bdb25702125cccb135a/src/vs/base/common/buffer.ts\n\n// Copyright (c) 2015 - present Microsoft Corporation\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the “Software”), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n/** @ignore */\nexport function readUInt8(source: Uint8Array, offset: number): number {\n  return source[offset];\n}\n\n/** @ignore */\nexport function writeUInt8(destination: Uint8Array, value: number, offset = 0): Uint8Array {\n  destination[offset] = value;\n  return destination;\n}\n\n/** @ignore */\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n  return ((source[offset + 0] << 0) >>> 0) | ((source[offset + 1] << 8) >>> 0);\n}\n\n/** @ignore */\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset = 0): Uint8Array {\n  destination[offset + 0] = value & 0b1111_1111;\n  value >>>= 8;\n  destination[offset + 1] = value & 0b1111_1111;\n  return destination;\n}\n\n/** @ignore */\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n  return (\n    source[offset] * 2 ** 24 +\n    source[offset + 1] * 2 ** 16 +\n    source[offset + 2] * 2 ** 8 +\n    source[offset + 3]\n  );\n}\n\n/** @ignore */\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset = 0): Uint8Array {\n  destination[offset + 3] = value;\n  value >>>= 8;\n  destination[offset + 2] = value;\n  value >>>= 8;\n  destination[offset + 1] = value;\n  value >>>= 8;\n  destination[offset] = value;\n  return destination;\n}\n\n/** @ignore */\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n  return (\n    ((source[offset + 0] << 0) >>> 0) |\n    ((source[offset + 1] << 8) >>> 0) |\n    ((source[offset + 2] << 16) >>> 0) |\n    ((source[offset + 3] << 24) >>> 0)\n  );\n}\n\n/** @ignore */\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset = 0): Uint8Array {\n  destination[offset + 0] = value & 0b1111_1111;\n  value >>>= 8;\n  destination[offset + 1] = value & 0b1111_1111;\n  value >>>= 8;\n  destination[offset + 2] = value & 0b1111_1111;\n  value >>>= 8;\n  destination[offset + 3] = value & 0b1111_1111;\n  return destination;\n}\n", "/**\n * The chain ID (unsigned 32-bit integer), used so transactions can't be replayed on other chains.\n * Similar to the {@link TransactionVersion}.\n */\nexport enum ChainID {\n  Testnet = 0x80000000,\n  Mainnet = 0x00000001,\n}\n\nexport const DEFAULT_CHAIN_ID = ChainID.Mainnet;\nexport const MAX_STRING_LENGTH_BYTES = 128;\nexport const CLARITY_INT_SIZE = 128;\nexport const CLARITY_INT_BYTE_SIZE = 16;\nexport const COINBASE_BYTES_LENGTH = 32;\nexport const VRF_PROOF_BYTES_LENGTH = 80;\nexport const RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;\nexport const COMPRESSED_PUBKEY_LENGTH_BYTES = 32;\nexport const UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;\nexport const MEMO_MAX_LENGTH_BYTES = 34;\nexport const DEFAULT_CORE_NODE_API_URL = 'https://api.mainnet.hiro.so';\n\n// todo: add explicit enum values\n/**\n * The type of message that is being serialized.\n * Used internally for serializing and deserializing messages.\n */\nexport enum StacksMessageType {\n  Address,\n  Principal,\n  LengthPrefixedString,\n  MemoString,\n  AssetInfo,\n  PostCondition,\n  PublicKey,\n  LengthPrefixedList,\n  Payload,\n  MessageSignature,\n  StructuredDataSignature,\n  TransactionAuthField,\n}\n\ntype WhenMessageTypeMap<T> = Record<StacksMessageType, T>;\n\nexport function whenMessageType(messageType: StacksMessageType) {\n  return <T>(messageTypeMap: WhenMessageTypeMap<T>): T => messageTypeMap[messageType];\n}\n\n/**\n * The type of transaction (payload) that is being serialized.\n * Used internally for serializing and deserializing transactions.\n */\nexport enum PayloadType {\n  TokenTransfer = 0x00,\n  SmartContract = 0x01,\n  VersionedSmartContract = 0x06,\n  ContractCall = 0x02,\n  PoisonMicroblock = 0x03,\n  Coinbase = 0x04,\n  CoinbaseToAltRecipient = 0x05,\n  TenureChange = 0x7,\n  NakamotoCoinbase = 0x08,\n}\n\n/**\n * The version of Clarity used to deploy a smart contract.\n * Most methods will default to the latest available version of Clarity.\n */\nexport enum ClarityVersion {\n  Clarity1 = 1,\n  Clarity2 = 2,\n  Clarity3 = 3,\n}\n\n/**\n * How a transaction should get appended to the Stacks blockchain.\n *\n * In the Stacks blockchain, there are two kinds of blocks: anchored\n * blocks and streaming microblocks. A transactions AnchorMode specifies\n * which kind of block it should be included in.\n *\n * For more information about the kinds of Stacks blocks and the various\n * AnchorModes, check out {@link https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md SIP 001} and\n * {@link https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md SIP 005}\n */\nexport enum AnchorMode {\n  /** The transaction MUST be included in an anchored block */\n  OnChainOnly = 0x01,\n  /** The transaction MUST be included in a microblock */\n  OffChainOnly = 0x02,\n  /** The leader can choose where to include the transaction (anchored block or microblock)*/\n  Any = 0x03,\n}\n\nexport const AnchorModeNames = ['onChainOnly', 'offChainOnly', 'any'] as const;\nexport type AnchorModeName = (typeof AnchorModeNames)[number];\n\nconst AnchorModeMap = {\n  [AnchorModeNames[0]]: AnchorMode.OnChainOnly,\n  [AnchorModeNames[1]]: AnchorMode.OffChainOnly,\n  [AnchorModeNames[2]]: AnchorMode.Any,\n  [AnchorMode.OnChainOnly]: AnchorMode.OnChainOnly,\n  [AnchorMode.OffChainOnly]: AnchorMode.OffChainOnly,\n  [AnchorMode.Any]: AnchorMode.Any,\n};\n\n/** @ignore */\nexport function anchorModeFromNameOrValue(mode: AnchorModeName | AnchorMode): AnchorMode {\n  if (mode in AnchorModeMap) return AnchorModeMap[mode];\n  throw new Error(`Invalid anchor mode \"${mode}\", must be one of: ${AnchorModeNames.join(', ')}`);\n}\n\n/**\n * The transaction version, used so transactions can't be replayed on other networks.\n * Similar to the {@link ChainID}.\n * Used internally for serializing and deserializing transactions.\n */\nexport enum TransactionVersion {\n  Mainnet = 0x00,\n  Testnet = 0x80,\n}\n\nexport const DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;\n\n/**\n * How to treat unspecified transfers of a transaction.\n * Used for creating transactions.\n *\n * Post-conditions are **always** be validated by nodes, regardless of the {@link PostConditionMode}.\n * `PostConditionMode.Allow` will allow additional (aka unspecified) transfers, while `PostConditionMode.Deny` will not.\n */\nexport enum PostConditionMode {\n  /** `Allow` — Allow unspecified transfers */\n  Allow = 0x01,\n  /** `Deny` — Do not allow unspecified transfers */\n  Deny = 0x02,\n}\n\n/**\n * The type of asset a post-condition is referring to.\n * Used for serializing post-conditions.\n */\nexport enum PostConditionType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\n/**\n * The sponsorship mode of a transaction.\n *\n * Specifies whether a transaction is sponsored or not.\n */\nexport enum AuthType {\n  /** `Standard` (not sponsored) — The transaction is not sponsored. The sender will need to spend fees. */\n  Standard = 0x04,\n  /** `Sponsored` — The transaction is sponsored. The sponsor will spend fees on behalf of the sender. */\n  Sponsored = 0x05,\n}\n\n/**\n * Serialization modes for public keys to addresses.\n * Four different modes are supported due to legacy compatibility with Stacks v1 addresses.\n */\nexport enum AddressHashMode {\n  /** `SingleSigHashMode` — hash160(public-key), same as bitcoin's p2pkh */\n  SerializeP2PKH = 0x00,\n  /** Legacy `MultiSigHashMode` — hash160(multisig-redeem-script), same as bitcoin's multisig p2sh */\n  SerializeP2SH = 0x01,\n  /** `SingleSigHashMode` — hash160(segwit-program-00(p2pkh)), same as bitcoin's p2sh-p2wpkh */\n  SerializeP2WPKH = 0x02,\n  /** Legacy `MultiSigHashMode` — hash160(segwit-program-00(public-keys)), same as bitcoin's p2sh-p2wsh */\n  SerializeP2WSH = 0x03,\n  /** Non-Sequential `MultiSigHashMode` — hash160(multisig-redeem-script), same as bitcoin's multisig p2sh */\n  SerializeP2SHNonSequential = 0x05,\n  /** Non-Sequential `MultiSigHashMode` — hash160(segwit-program-00(public-keys)), same as bitcoin's p2sh-p2wsh */\n  SerializeP2WSHNonSequential = 0x07,\n\n  // todo: `next` rename to remove the `Serialize` prefix?\n  // todo: `next` rename to remove `NonSequential` and add `Legacy` to sequential mutlisig\n}\n\nexport type SingleSigHashMode = AddressHashMode.SerializeP2PKH | AddressHashMode.SerializeP2WPKH;\nexport type MultiSigHashMode =\n  | AddressHashMode.SerializeP2SH\n  | AddressHashMode.SerializeP2WSH\n  | AddressHashMode.SerializeP2SHNonSequential\n  | AddressHashMode.SerializeP2WSHNonSequential;\n\n/**\n * Address versions for identifying address types in an encoded Stacks address.\n * The address version is a single byte, indicating the address type.\n * Every Stacks address starts with `S` followed by a single character indicating the address version.\n * The second character is the c32-encoded AddressVersion byte.\n */\nexport enum AddressVersion {\n  /** `P` — A single-sig address for mainnet (starting with `SP`) */\n  MainnetSingleSig = 22,\n  /** `M` — A multi-sig address for mainnet (starting with `SM`) */\n  MainnetMultiSig = 20,\n  /** `T` — A single-sig address for testnet (starting with `ST`) */\n  TestnetSingleSig = 26,\n  /** `N` — A multi-sig address for testnet (starting with `SN`) */\n  TestnetMultiSig = 21,\n}\n\n// todo: try to remove this\nexport enum PubKeyEncoding {\n  Compressed = 0x00,\n  Uncompressed = 0x01,\n}\n\n/**\n * The type of fungible token post-condition comparison.\n * Used for serializing post-conditions.\n */\nexport enum FungibleConditionCode {\n  Equal = 0x01,\n  Greater = 0x02,\n  GreaterEqual = 0x03,\n  Less = 0x04,\n  LessEqual = 0x05,\n}\n\n/**\n * The type of non-fungible token post-condition comparison.\n * Used for serializing post-conditions.\n */\nexport enum NonFungibleConditionCode {\n  Sends = 0x10,\n  DoesNotSend = 0x11,\n}\n\n/**\n * The type of sender for a post-condition.\n */\nexport enum PostConditionPrincipalID {\n  Origin = 0x01,\n  Standard = 0x02,\n  Contract = 0x03,\n}\n\n/**\n * The type of asset used in a post-condition.\n */\nexport enum AssetType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\n// todo: refactor this, if only used in one place, just use a string\n/** @ignore */\nexport enum TxRejectedReason {\n  Serialization = 'Serialization',\n  Deserialization = 'Deserialization',\n  SignatureValidation = 'SignatureValidation',\n  FeeTooLow = 'FeeTooLow',\n  BadNonce = 'BadNonce',\n  NotEnoughFunds = 'NotEnoughFunds',\n  NoSuchContract = 'NoSuchContract',\n  NoSuchPublicFunction = 'NoSuchPublicFunction',\n  BadFunctionArgument = 'BadFunctionArgument',\n  ContractAlreadyExists = 'ContractAlreadyExists',\n  PoisonMicroblocksDoNotConflict = 'PoisonMicroblocksDoNotConflict',\n  PoisonMicroblockHasUnknownPubKeyHash = 'PoisonMicroblockHasUnknownPubKeyHash',\n  PoisonMicroblockIsInvalid = 'PoisonMicroblockIsInvalid',\n  BadAddressVersionByte = 'BadAddressVersionByte',\n  NoCoinbaseViaMempool = 'NoCoinbaseViaMempool',\n  ServerFailureNoSuchChainTip = 'ServerFailureNoSuchChainTip',\n  TooMuchChaining = 'TooMuchChaining',\n  ConflictingNonceInMempool = 'ConflictingNonceInMempool',\n  BadTransactionVersion = 'BadTransactionVersion',\n  TransferRecipientCannotEqualSender = 'TransferRecipientCannotEqualSender',\n  TransferAmountMustBePositive = 'TransferAmountMustBePositive',\n  ServerFailureDatabase = 'ServerFailureDatabase',\n  EstimatorError = 'EstimatorError',\n  TemporarilyBlacklisted = 'TemporarilyBlacklisted',\n  ServerFailureOther = 'ServerFailureOther',\n}\n", "import { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512_256 } from '@noble/hashes/sha512';\nimport { utils } from '@noble/secp256k1';\nimport { bytesToHex, concatArray, concatBytes, utf8ToBytes, with0x } from '@stacks/common';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash.clonedeep';\nimport { ClarityValue, deserializeCV, serializeCV } from './clarity';\n\n// Export verify as utility method for signature verification\nexport { verify as verifySignature } from '@noble/secp256k1';\n\n/**\n * Use utils.randomBytes to replace randombytes dependency\n * Generates random bytes of given length\n * @param {number} bytesLength an optional bytes length, default is 32 bytes\n */\nexport const randomBytes = (bytesLength?: number): Uint8Array => utils.randomBytes(bytesLength);\n\nexport const leftPadHex = (hexString: string): string =>\n  hexString.length % 2 == 0 ? hexString : `0${hexString}`;\n\nexport const leftPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padStart(length, '0');\n\nexport const rightPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padEnd(length, '0');\n\nexport const exceedsMaxLengthBytes = (string: string, maxLengthBytes: number): boolean =>\n  string ? utf8ToBytes(string).length > maxLengthBytes : false;\n\n/** @ignore */\nexport function cloneDeep<T>(obj: T): T {\n  return lodashCloneDeep(obj);\n}\n\n// todo: remove this function and instead delete param without clone (if possible)?\nexport function omit<T, K extends keyof any>(obj: T, prop: K): Omit<T, K> {\n  const clone = cloneDeep(obj);\n  // @ts-expect-error\n  delete clone[prop];\n  return clone;\n}\n\nexport const hash160 = (input: Uint8Array): Uint8Array => {\n  return ripemd160(sha256(input));\n};\n\n/** @deprecated renamed to {@link txidFromBytes} */\nexport const txidFromData = (data: Uint8Array): string => {\n  return bytesToHex(sha512_256(data));\n};\n\n/**\n * Computes the transaction ID of the bytes from a serialized transaction (or any other bytes using the same hash function).\n */\nexport const txidFromBytes = txidFromData;\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address (p2pkh)\n/** @ignore */\nexport const hashP2PKH = (input: Uint8Array): string => {\n  return bytesToHex(hash160(input));\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address over p2sh (p2h-p2wpkh)\n/** @ignore */\nexport const hashP2WPKH = (input: Uint8Array): string => {\n  const keyHash = hash160(input);\n  const redeemScript = concatBytes(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);\n  const redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multi-sig address (p2sh)\n/** @ignore */\nexport const hashP2SH = (numSigs: number, pubKeys: Uint8Array[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const bytesArray = [];\n  // OP_n\n  bytesArray.push(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    bytesArray.push(pubKey.length);\n    bytesArray.push(pubKey);\n  });\n  // OP_m\n  bytesArray.push(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  bytesArray.push(174);\n\n  const redeemScript = concatArray(bytesArray);\n  const redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multisig address over p2sh (p2sh-p2wsh)\n/** @ignore */\nexport const hashP2WSH = (numSigs: number, pubKeys: Uint8Array[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2WSH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const scriptArray = [];\n  // OP_n\n  scriptArray.push(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    scriptArray.push(pubKey.length);\n    scriptArray.push(pubKey);\n  });\n  // OP_m\n  scriptArray.push(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  scriptArray.push(174);\n\n  const script = concatArray(scriptArray);\n  const digest = sha256(script);\n\n  const bytesArray = [];\n  bytesArray.push(0);\n  bytesArray.push(digest.length);\n  bytesArray.push(digest);\n\n  const redeemScript = concatArray(bytesArray);\n  const redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\n\nexport function isClarityName(name: string) {\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\n\n/**\n * Converts a clarity value to a hex encoded string with `0x` prefix\n * @param {ClarityValue} cv  - the clarity value to convert\n */\nexport function cvToHex(cv: ClarityValue) {\n  const serialized = serializeCV(cv);\n  return `0x${bytesToHex(serialized)}`;\n}\n\n/**\n * Converts a hex encoded string to a clarity value\n * @param {string} hex - the hex encoded string with or without `0x` prefix\n */\nexport function hexToCV(hex: string) {\n  return deserializeCV(hex);\n}\n/**\n * Read only function response object\n *\n * @param {Boolean} okay - the status of the response\n * @param {string} result - serialized hex clarity value\n */\n\nexport interface ReadOnlyFunctionSuccessResponse {\n  okay: true;\n  result: string;\n}\n\nexport interface ReadOnlyFunctionErrorResponse {\n  okay: false;\n  cause: string;\n}\n\nexport type ReadOnlyFunctionResponse =\n  | ReadOnlyFunctionSuccessResponse\n  | ReadOnlyFunctionErrorResponse;\n\n/**\n * Converts the response of a read-only function call into its Clarity Value\n * @param param\n */\nexport const parseReadOnlyResponse = (response: ReadOnlyFunctionResponse): ClarityValue => {\n  if (response.okay) return hexToCV(response.result);\n  throw new Error(response.cause);\n};\n\nexport const validateStacksAddress = (stacksAddress: string): boolean => {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nexport const validateTxId = (txid: string): boolean => {\n  if (txid === 'success') return true; // Bypass fetchMock tests // todo: move this line into mocks in test files\n  const value = with0x(txid).toLowerCase();\n  if (value.length !== 66) return false;\n  return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\n};\n", "import {\n  AddressHashMode,\n  AddressVersion,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\n\nimport { c32address } from 'c32check';\nimport { hexToBytes } from '@stacks/common';\n\nexport interface Address {\n  readonly type: StacksMessageType.Address;\n  readonly version: AddressVersion;\n  readonly hash160: string;\n}\n\nexport interface MessageSignature {\n  readonly type: StacksMessageType.MessageSignature;\n  data: string;\n}\n\nexport function createMessageSignature(signature: string): MessageSignature {\n  const length = hexToBytes(signature).byteLength;\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature,\n  };\n}\n\n/**\n * Translates the tx auth hash mode to the corresponding address version.\n * @see https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#transaction-authorization\n */\nexport function addressHashModeToVersion(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion\n): AddressVersion {\n  // todo: `next` refacto with network param\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetSingleSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetSingleSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2SHNonSequential:\n    case AddressHashMode.SerializeP2WPKH:\n    case AddressHashMode.SerializeP2WSH:\n    case AddressHashMode.SerializeP2WSHNonSequential:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetMultiSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetMultiSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    default:\n      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n  }\n}\n\nexport function addressFromVersionHash(version: AddressVersion, hash: string): Address {\n  return { type: StacksMessageType.Address, version, hash160: hash };\n}\n\nexport function addressToString(address: Address): string {\n  return c32address(address.version, address.hash160);\n}\n", "import {\n  FungibleConditionCode,\n  MAX_STRING_LENGTH_BYTES,\n  NonFungibleConditionCode,\n  PostConditionPrincipalID,\n  PostConditionType,\n  StacksMessageType,\n} from './constants';\nimport { c32addressDecode } from 'c32check';\nimport { Address } from './common';\nimport { ClarityValue } from './clarity';\nimport { exceedsMaxLengthBytes } from './utils';\n\nexport interface StandardPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Standard;\n  readonly address: Address;\n}\n\nexport interface ContractPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Contract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\nexport interface LengthPrefixedString {\n  readonly type: StacksMessageType.LengthPrefixedString;\n  readonly content: string;\n  readonly lengthPrefixBytes: number;\n  readonly maxLengthBytes: number;\n}\n\nexport interface AssetInfo {\n  readonly type: StacksMessageType.AssetInfo;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly assetName: LengthPrefixedString;\n}\n\nexport interface STXPostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.STX;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: bigint;\n}\n\nexport interface FungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.Fungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: bigint;\n  readonly assetInfo: AssetInfo;\n}\n\nexport interface NonFungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.NonFungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: NonFungibleConditionCode;\n  /** Structure that identifies the token type. */\n  readonly assetInfo: AssetInfo;\n  /** The Clarity value that names the token instance. */\n  readonly assetName: ClarityValue;\n}\n\nexport function parseAssetInfoString(id: string): AssetInfo {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\n\nexport function createLPString(content: string): LengthPrefixedString;\nexport function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes: number,\n  maxLengthBytes: number\n): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes?: number,\n  maxLengthBytes?: number\n): LengthPrefixedString {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength}`);\n  }\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength,\n  };\n}\n\nexport function createAssetInfo(\n  addressString: string,\n  contractName: string,\n  assetName: string\n): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName),\n  };\n}\n\nexport function createAddress(c32AddressString: string): Address {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1],\n  };\n}\n\n/**\n * Parses a principal string for either a standard principal or contract principal.\n * @param principalString - String in the format `{address}.{contractName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract\"\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G\"\n */\nexport function parsePrincipalString(\n  principalString: string\n): StandardPrincipal | ContractPrincipal {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\n\nexport function createContractPrincipal(\n  addressString: string,\n  contractName: string\n): ContractPrincipal {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name,\n  };\n}\n\nexport function createStandardPrincipal(addressString: string): StandardPrincipal {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr,\n  };\n}\n\nexport type PostCondition = STXPostCondition | FungiblePostCondition | NonFungiblePostCondition;\n\nexport type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;\n", "/**\n * Type IDs corresponding to each of the Clarity value types as described here:\n * {@link https://github.com/blockstack/blockstack-core/blob/sip/sip-005/sip/sip-005-blocks-and-transactions.md#clarity-value-representation}\n */\nexport enum ClarityType {\n  Int = 0x00,\n  UInt = 0x01,\n  Buffer = 0x02,\n  BoolTrue = 0x03,\n  BoolFalse = 0x04,\n  PrincipalStandard = 0x05,\n  PrincipalContract = 0x06,\n  ResponseOk = 0x07,\n  ResponseErr = 0x08,\n  OptionalNone = 0x09,\n  OptionalSome = 0x0a,\n  List = 0x0b,\n  Tuple = 0x0c,\n  StringASCII = 0x0d,\n  StringUTF8 = 0x0e,\n}\n", "import { utf8ToBytes } from '@stacks/common';\nimport { Address, addressToString } from '../../common';\nimport { LengthPrefixedString, createAddress, createLPString } from '../../postcondition-types';\nimport { ClarityType } from '../constants';\n\ntype PrincipalCV = StandardPrincipalCV | ContractPrincipalCV;\n\ninterface StandardPrincipalCV {\n  readonly type: ClarityType.PrincipalStandard;\n  readonly address: Address;\n}\n\ninterface ContractPrincipalCV {\n  readonly type: ClarityType.PrincipalContract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n/** Returns a string in the format `address` or `address.contract-name` from a principal (standard or contract) */\nfunction principalToString(principal: PrincipalCV): string {\n  if (principal.type === ClarityType.PrincipalStandard) {\n    return addressToString(principal.address);\n  } else if (principal.type === ClarityType.PrincipalContract) {\n    const address = addressToString(principal.address);\n    return `${address}.${principal.contractName.content}`;\n  } else {\n    throw new Error(`Unexpected principal data: ${JSON.stringify(principal)}`);\n  }\n}\n\nfunction principalCV(principal: string): PrincipalCV {\n  if (principal.includes('.')) {\n    const [address, contractName] = principal.split('.');\n    return contractPrincipalCV(address, contractName);\n  } else {\n    return standardPrincipalCV(principal);\n  }\n}\n\n/**\n * Converts stx address in to StandardPrincipalCV clarity type\n * @param {addressString} string value to be converted to StandardPrincipalCV clarity type\n * @returns {StandardPrincipalCV} returns instance of type StandardPrincipalCV\n *\n * @example\n * ```\n *  import { standardPrincipalCV } from '@stacks/transactions';\n *\n *  const addr = standardPrincipalCV('SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B');\n *  // { type: 5, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' } }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nfunction standardPrincipalCV(addressString: string): StandardPrincipalCV {\n  const addr = createAddress(addressString);\n  return { type: ClarityType.PrincipalStandard, address: addr };\n}\n\n/**\n * Converts stx address in to StandardPrincipalCV clarity type\n * @param {addressString} string value to be converted to StandardPrincipalCV clarity type\n * @returns {StandardPrincipalCV} returns instance of type StandardPrincipalCV\n *\n * @example\n * ```\n *  import { standardPrincipalCVFromAddress, Address  } from '@stacks/transactions';\n *\n *  const address: Address = {\n *    type: 0,\n *    version: 22,\n *    hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6'\n *  };\n *\n *  const principalCV = standardPrincipalCVFromAddress(address);\n *  // { type: 5, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' } }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nfunction standardPrincipalCVFromAddress(address: Address): StandardPrincipalCV {\n  return { type: ClarityType.PrincipalStandard, address };\n}\n\n/**\n * Converts stx address in to ContractPrincipalCV clarity type\n * @param {addressString} string value to be converted to ContractPrincipalCV clarity type\n * @param {contractName} string containing contract name\n * @returns {ContractPrincipalCV} returns instance of type ContractPrincipalCV\n *\n * @example\n * ```\n *  import { contractPrincipalCV } from '@stacks/transactions';\n *\n *  const contractAddress = contractPrincipalCV('SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B', 'test');\n *  // { type: 6, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' }, contractName: { type: 2, content: 'test', lengthPrefixBytes: 1, maxLengthBytes: 128 } }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nfunction contractPrincipalCV(addressString: string, contractName: string): ContractPrincipalCV {\n  const addr = createAddress(addressString);\n  const lengthPrefixedContractName = createLPString(contractName);\n  return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);\n}\n\n/**\n * Create ContractPrincipalCV from Address type\n * @param {address} address value to be converted to ContractPrincipalCV clarity type\n * @param {contractName} contract name of type LengthPrefixedString\n * @returns {ContractPrincipalCV} returns instance of type ContractPrincipalCV\n *\n * @example\n * ```\n *  import { contractPrincipalCVFromAddress, createLPString, createAddress } from '@stacks/transactions';\n *\n *  const contractAddressCV = contractPrincipalCVFromAddress(createAddress('SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B'), createLPString('test'));\n *\n *  // { type: 6, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' }, contractName: { type: 2, content: 'test', lengthPrefixBytes: 1, maxLengthBytes: 128 } }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nfunction contractPrincipalCVFromAddress(\n  address: Address,\n  contractName: LengthPrefixedString\n): ContractPrincipalCV {\n  if (utf8ToBytes(contractName.content).byteLength >= 128) {\n    throw new Error('Contract name must be less than 128 bytes');\n  }\n  return { type: ClarityType.PrincipalContract, address, contractName };\n}\n\nfunction contractPrincipalCVFromStandard(\n  sp: StandardPrincipalCV,\n  contractName: string\n): ContractPrincipalCV {\n  const lengthPrefixedContractName = createLPString(contractName);\n  return {\n    type: ClarityType.PrincipalContract,\n    address: sp.address,\n    contractName: lengthPrefixedContractName,\n  };\n}\n\nexport {\n  PrincipalCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  principalCV,\n  principalToString,\n  standardPrincipalCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCV,\n  contractPrincipalCVFromAddress,\n  contractPrincipalCVFromStandard,\n};\n", "import {\n  BooleanCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseErrorCV,\n  ResponseOkCV,\n  ListCV,\n  TupleCV,\n  StringAsciiCV,\n  StringUtf8CV,\n  NoneCV,\n  SomeCV,\n  TrueCV,\n  FalseCV,\n} from '.';\n\nimport { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\nimport { asciiToBytes, bytesToAscii, bytesToHex, utf8ToBytes } from '@stacks/common';\n\nexport type ClarityValue =\n  | BooleanCV\n  | BufferCV\n  | IntCV\n  | UIntCV\n  | StandardPrincipalCV\n  | ContractPrincipalCV\n  | ResponseErrorCV\n  | ResponseOkCV\n  | NoneCV\n  | SomeCV\n  | ListCV\n  | TupleCV\n  | StringAsciiCV\n  | StringUtf8CV;\n\nexport function cvToString(val: ClarityValue, encoding: 'tryAscii' | 'hex' = 'hex'): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = bytesToAscii(val.buffer);\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\n\n/**\n * @param strictJsonCompat If true then ints and uints are returned as JSON serializable numbers when\n * less than or equal to 53 bit length, otherwise string wrapped integers when larger than 53 bits.\n * If false, they are returned as js native `bigint`s which are _not_ JSON serializable.\n */\nexport function cvToValue(val: ClarityValue, strictJsonCompat: boolean = false): any {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      if (strictJsonCompat) {\n        return val.value.toString();\n      }\n      return val.value;\n    case ClarityType.Buffer:\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result: { [key: string]: any } = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\n\nexport function cvToJSON(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: false };\n    case ClarityType.ResponseOk:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: true };\n    default:\n      return { type: getCVTypeString(val), value: cvToValue(val, true) };\n  }\n}\n\nexport function getCVTypeString(val: ClarityValue): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${\n        val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'\n      })`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${getCVTypeString(val.data[key])})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${asciiToBytes(val.data).length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${utf8ToBytes(val.data).length})`;\n  }\n}\n\ntype ClarityTypetoValue = {\n  [ClarityType.OptionalNone]: NoneCV;\n  [ClarityType.OptionalSome]: SomeCV;\n  [ClarityType.ResponseOk]: ResponseOkCV;\n  [ClarityType.ResponseErr]: ResponseErrorCV;\n  [ClarityType.BoolTrue]: TrueCV;\n  [ClarityType.BoolFalse]: FalseCV;\n  [ClarityType.Int]: IntCV;\n  [ClarityType.UInt]: UIntCV;\n  [ClarityType.StringASCII]: StringAsciiCV;\n  [ClarityType.StringUTF8]: StringUtf8CV;\n  [ClarityType.PrincipalStandard]: StandardPrincipalCV;\n  [ClarityType.PrincipalContract]: ContractPrincipalCV;\n  [ClarityType.List]: ListCV;\n  [ClarityType.Tuple]: TupleCV;\n  [ClarityType.Buffer]: BufferCV;\n};\n\n/**\n * Narrow down the type of a generic ClarityValue\n * @example\n * ```ts\n * // some functions can return a generic `ClarityValue` type\n * let value = callReadOnlyFunction();\n * //  ^ ClarityValue\n * // use `isClarityType` to narrow down the type\n * assert(isClarityType(value, ClarityType.Int))\n * console.log(value)\n * //          ^ IntCV\n * ```\n */\nexport function isClarityType<T extends ClarityType>(\n  input: ClarityValue,\n  withType: T\n): input is ClarityTypetoValue[T] {\n  return input.type === withType;\n}\n", "import { ClarityType } from '../constants';\n\ntype BooleanCV = TrueCV | FalseCV;\n\ninterface TrueCV {\n  type: ClarityType.BoolTrue;\n}\n\ninterface FalseCV {\n  type: ClarityType.BoolFalse;\n}\n\n/**\n * Converts true to BooleanCV clarity type\n *\n * @returns {BooleanCV} returns instance of type BooleanCV\n *\n * @example\n * ```\n *  import { trueCV } from '@stacks/transactions';\n *\n *  const trueCV = trueCV();\n *  // { type: 3 }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nconst trueCV = (): BooleanCV => ({ type: ClarityType.BoolTrue });\n\n/**\n * Converts false to BooleanCV clarity type\n *\n * @returns {BooleanCV} returns instance of type BooleanCV\n *\n * @example\n * ```\n *  import { falseCV } from '@stacks/transactions';\n *\n *  const falseCV = falseCV();\n *  // { type: 4 }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nconst falseCV = (): BooleanCV => ({ type: ClarityType.BoolFalse });\n\n/**\n * Converts a boolean to BooleanCV clarity type\n *\n * @returns {BooleanCV} returns instance of type BooleanCV\n *\n * @example\n * ```\n *  import { boolCV } from '@stacks/transactions';\n *\n *  const boolCV = boolCV(false);\n *  // { type: 4 }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nconst boolCV = (bool: boolean) => (bool ? trueCV() : falseCV());\n\nexport { BooleanCV, TrueCV, FalseCV, boolCV, trueCV, falseCV };\n", "import { IntegerType, intToBigInt } from '@stacks/common';\nimport { ClarityType } from '../constants';\n\nconst MAX_U128 = BigInt('0xffffffffffffffffffffffffffffffff'); // (2 ** 128 - 1)\nconst MIN_U128 = BigInt(0);\nconst MAX_I128 = BigInt('0x7fffffffffffffffffffffffffffffff'); // (2 ** 127 - 1)\n// no signed (negative) hex support in bigint constructor\nconst MIN_I128 = BigInt('-170141183460469231731687303715884105728'); // (-2 ** 127)\n\ninterface IntCV {\n  readonly type: ClarityType.Int;\n  readonly value: bigint;\n}\n\n/**\n * Converts IntegerType in to IntCV clarity type\n *\n * @param {value} integer value to be converted to IntCV clarity type\n *\n * @returns {IntCV} returns instance of type IntCV\n *\n * @example\n * ```\n *  import { intCV } from '@stacks/transactions';\n *\n *  const value = intCV('100'); // parameter any of type: number | string | bigint | Uint8Array | BN\n *  // { type: 0, value: 100n }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nconst intCV = (value: IntegerType): IntCV => {\n  const bigInt = intToBigInt(value, true);\n  if (bigInt > MAX_I128) {\n    throw new RangeError(`Cannot construct clarity integer from value greater than ${MAX_I128}`);\n  } else if (bigInt < MIN_I128) {\n    throw new RangeError(`Cannot construct clarity integer form value less than ${MIN_I128}`);\n  }\n  return { type: ClarityType.Int, value: bigInt };\n};\n\ninterface UIntCV {\n  readonly type: ClarityType.UInt;\n  readonly value: bigint;\n}\n\n/**\n * Converts IntegerType in to IntCV clarity type\n *\n * @param {value} integer value to be converted to UIntCV clarity type (Only unsigned integer is allowed otherwise throws exception)\n *\n * @returns {UIntCV} returns instance of type UIntCV\n *\n * @example\n * ```\n *  import { uintCV } from '@stacks/transactions';\n *\n *  const value = uintCV('100'); // parameter any of type: number | string | bigint | Uint8Array | BN\n *  // { type: 1, value: 100n }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nconst uintCV = (value: IntegerType): UIntCV => {\n  const bigInt = intToBigInt(value, false);\n  if (bigInt < MIN_U128) {\n    throw new RangeError('Cannot construct unsigned clarity integer from negative value');\n  } else if (bigInt > MAX_U128) {\n    throw new RangeError(`Cannot construct unsigned clarity integer greater than ${MAX_U128}`);\n  }\n  return { type: ClarityType.UInt, value: bigInt };\n};\n\nexport { IntCV, UIntCV, intCV, uintCV };\n", "import { utf8ToBytes } from '@stacks/common';\nimport { ClarityType } from '../constants';\n\ninterface BufferCV {\n  readonly type: ClarityType.Buffer;\n  readonly buffer: Uint8Array;\n}\n\n/**\n * Converts a Uint8Array to a BufferCV clarity type\n *\n * @param {Uint8Array} buffer value to be converted to clarity type\n *\n * @returns {BufferCV} returns instance of type BufferCV\n *\n * @example\n * ```\n *  import { bufferCV } from '@stacks/transactions';\n *\n *  const buffer = utf8ToBytes('this is a test');\n *  const buf = bufferCV(buffer);\n *  // { type: 2, buffer: <Uint8Array 74 68 69 73 20 69 73 20 61 20 74 65 73 74> }\n *  const value = bytesToUtf8(buf.buffer);\n *  // this is a test\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nconst bufferCV = (buffer: Uint8Array): BufferCV => {\n  // max size 1024 * 1024 = 1MB; https://github.com/stacks-network/stacks-core/blob/c50a93088d7c0261f1dbe31ab24b95028a038447/clarity/src/vm/types/mod.rs#L47\n  if (buffer.byteLength > 1_048_576) {\n    throw new Error('Cannot construct clarity buffer that is greater than 1MB');\n  }\n\n  return { type: ClarityType.Buffer, buffer };\n};\n\n/**\n * Converts a string to BufferCV clarity type\n *\n * @param {str} string input to be converted to bufferCV clarity type\n *\n * @returns {BufferCV} returns instance of type BufferCV\n *\n * @example\n * ```\n *  import { bufferCVFromString } from '@stacks/transactions';\n *\n *  const str = 'this is a test';\n *  const buf = bufferCVFromString(str);\n *  // { type: 2, buffer: <Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74> }\n *  const value = bytesToUtf8(buf.buffer);\n *  // this is a test\n *```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nconst bufferCVFromString = (str: string): BufferCV => bufferCV(utf8ToBytes(str));\n\nexport { BufferCV, bufferCV, bufferCVFromString };\n", "import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\ntype OptionalCV<T extends ClarityValue = ClarityValue> = NoneCV | SomeCV<T>;\n\ninterface NoneCV {\n  readonly type: ClarityType.OptionalNone;\n}\n\ninterface SomeCV<T extends ClarityValue = ClarityValue> {\n  readonly type: ClarityType.OptionalSome;\n  readonly value: T;\n}\n\n/**\n * Create a null clarity type\n **\n * @returns {NoneCV} returns instance of type NoneCV\n *\n * @example\n * ```\n *  import { noneCV } from '@stacks/transactions';\n *\n *  const value = noneCV();\n *  // { type: 9 }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nfunction noneCV(): NoneCV {\n  return { type: ClarityType.OptionalNone };\n}\n\n/**\n * Converts any ClarityValue in to OptionalCV clarity type\n *\n * @param {ClarityValue} value to be converted to OptionalCV clarity type\n *\n * @returns {OptionalCV} returns instance of type OptionalCV\n *\n * @example\n * ```\n *  import { someCV, trueCV } from '@stacks/transactions';\n *\n *  const value = someCV(trueCV());\n *  // { type: 10, value: { type: 3 } }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nfunction someCV<T extends ClarityValue = ClarityValue>(value: T): OptionalCV<T> {\n  return { type: ClarityType.OptionalSome, value };\n}\n\nfunction optionalCVOf<T extends ClarityValue = ClarityValue>(value?: T): OptionalCV<T> {\n  if (value) {\n    return someCV(value);\n  } else {\n    return noneCV();\n  }\n}\n\nexport { OptionalCV, NoneCV, SomeCV, noneCV, someCV, optionalCVOf };\n", "import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\n\ntype ResponseCV = ResponseErrorCV | ResponseOkCV;\n\ninterface ResponseErrorCV<T extends ClarityValue = ClarityValue> {\n  readonly type: ClarityType.ResponseErr;\n  readonly value: T;\n}\n\ninterface ResponseOkCV<T extends ClarityValue = ClarityValue> {\n  readonly type: ClarityType.ResponseOk;\n  readonly value: T;\n}\n\n/**\n * Converts ClarityValue to responseErrorCV\n *\n * @param {value} ClarityValue value to be converted to responseErrorCV clarity type\n *\n * @returns {responseErrorCV} returns instance of type responseErrorCV\n *\n * @example\n * ```\n *  import { responseErrorCV, intCV } from '@stacks/transactions';\n *\n *  const respErrorCV = responseErrorCV(intCV(1));\n *\n *  // { type: 8, value: { type: 0, value: 1n } }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nfunction responseErrorCV<T extends ClarityValue = ClarityValue>(value: T): ResponseErrorCV<T> {\n  return { type: ClarityType.ResponseErr, value };\n}\n\n/**\n * Converts ClarityValue to ResponseOkCV\n *\n * @param {value} ClarityValue value to be converted to ResponseOkCV clarity type\n *\n * @returns {ResponseOkCV} returns instance of type ResponseOkCV\n *\n * @example\n * ```\n *  import { responseOkCV, intCV } from '@stacks/transactions';\n *\n *  const respOKCV = responseOkCV(intCV(1));\n *\n *  // { type: 7, value: { type: 0, value: 1n } }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nfunction responseOkCV<T extends ClarityValue = ClarityValue>(value: T): ResponseOkCV<T> {\n  return { type: ClarityType.ResponseOk, value };\n}\n\nexport { ResponseCV, ResponseErrorCV, ResponseOkCV, responseErrorCV, responseOkCV };\n", "import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\n\ninterface ListCV<T extends ClarityValue = ClarityValue> {\n  type: ClarityType.List;\n  list: T[];\n}\n\n/**\n * Create list of clarity types\n *\n * @param {ClarityValue[]} list of ClarityValues to be converted to ListCV clarity type\n *\n * @returns {ListCV<T>} instance of type ListCV<T> of the provided values\n *\n * @example\n * ```\n *  import { listCV, intCV } from '@stacks/transactions';\n *\n *  const list = listCV([intCV(1), intCV(2), intCV(3), intCV(-4)]);\n *  // { type: 11, list: [ { type: 0, value: 1n }, { type: 0, value: 2n }, { type: 0, value: 3n }, { type: 0, value: -4n } ] }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nfunction listCV<T extends ClarityValue = ClarityValue>(values: T[]): ListCV<T> {\n  return { type: ClarityType.List, list: values };\n}\n\nexport { ListCV, listCV };\n", "import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\nimport { isClarityName } from '../../utils';\n\ntype TupleData<T extends ClarityValue = ClarityValue> = { [key: string]: T };\n\ninterface TupleCV<T extends TupleData = TupleData> {\n  type: ClarityType.Tuple;\n  data: T;\n}\n\n/**\n * Create tuple of clarity values\n *\n * @param {tupleData} tuple value to be converted to tuple of clarity types\n *\n * @returns {TupleCV} returns instance of type clarity tuple\n *\n * @example\n * ```\n *  import { tupleCV, trueCV, falseCV } from '@stacks/transactions';\n *\n *  const tuple = tupleCV({\n *    c: trueCV(),\n *    b: falseCV(),\n *    a: trueCV(),\n *  });\n *  // { type: 12, data: { c: { type: 3 }, b: { type: 4 }, a: { type: 3 } } }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nfunction tupleCV<T extends ClarityValue = ClarityValue>(data: TupleData<T>): TupleCV<TupleData<T>> {\n  for (const key in data) {\n    if (!isClarityName(key)) {\n      throw new Error(`\"${key}\" is not a valid Clarity name`);\n    }\n  }\n\n  return { type: ClarityType.Tuple, data };\n}\n\nexport { TupleCV, tupleCV };\n", "import { ClarityType } from '../constants';\n\ninterface StringAsciiCV {\n  readonly type: ClarityType.StringASCII;\n  readonly data: string;\n}\n\ninterface StringUtf8CV {\n  readonly type: ClarityType.StringUTF8;\n  readonly data: string;\n}\n\n/**\n * Converts ClarityValue to stringAsciiCV\n *\n * @param {data} ClarityValue value to be converted to stringAsciiCV clarity type\n *\n * @returns {StringAsciiCV} returns instance of type StringAsciiCV\n *\n * @example\n * ```\n *  import { stringAsciiCV } from '@stacks/transactions';\n *\n *  const stringAscii = stringAsciiCV('test');\n *\n *  // { type: 13, data: 'hello' }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nconst stringAsciiCV = (data: string): StringAsciiCV => {\n  return { type: ClarityType.StringASCII, data };\n};\n\n/**\n * Converts ClarityValue to stringUtf8CV\n *\n * @param {data} ClarityValue value to be converted to stringUtf8CV clarity type\n *\n * @returns {stringUtf8CV} returns instance of type stringUtf8CV\n *\n * @example\n * ```\n *  import { stringUtf8CV } from '@stacks/transactions';\n *\n *  const stringUTF8 = stringUtf8CV('test');\n *\n *  // { type: 13, data: 'hello' }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nconst stringUtf8CV = (data: string): StringUtf8CV => {\n  return { type: ClarityType.StringUTF8, data };\n};\n\n/**\n * @ignore\n */\nconst stringCV = (data: string, encoding: 'ascii' | 'utf8'): StringAsciiCV | StringUtf8CV => {\n  switch (encoding) {\n    case 'ascii':\n      return stringAsciiCV(data);\n    case 'utf8':\n      return stringUtf8CV(data);\n  }\n};\n\nexport { StringAsciiCV, StringUtf8CV, stringAsciiCV, stringUtf8CV, stringCV };\n", "import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n  getPublicKey as nobleGetPublicKey,\n  Point,\n  Signature,\n  signSync,\n  utils,\n} from '@noble/secp256k1';\nimport {\n  bytesToHex,\n  concatArray,\n  hexToBigInt,\n  hexToBytes,\n  intToHex,\n  parseRecoverableSignatureVrs,\n  privateKeyToBytes,\n  PRIVATE_KEY_COMPRESSED_LENGTH,\n  signatureRsvToVrs,\n  signatureVrsToRsv,\n} from '@stacks/common';\nimport { c32address } from 'c32check';\nimport { BytesReader } from './bytesReader';\nimport {\n  addressFromVersionHash,\n  addressHashModeToVersion,\n  addressToString,\n  createMessageSignature,\n  MessageSignature,\n} from './common';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n} from './constants';\nimport { hash160, hashP2PKH } from './utils';\nimport { StructuredDataSignature } from './message-types';\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signWithKey in this file\n * secp256k1.signSync is used to maintain the semantics of signWithKey while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\nexport interface StacksPublicKey {\n  readonly type: StacksMessageType.PublicKey;\n  readonly data: Uint8Array;\n}\n\n/** Creates a P2PKH address string from the given private key and tx version. */\nexport function getAddressFromPrivateKey(\n  /** Private key bytes or hex string */\n  privateKey: string | Uint8Array,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\n\n/** Creates a P2PKH address string from the given public key and tx version. */\nexport function getAddressFromPublicKey(\n  /** Public key bytes or hex string */\n  publicKey: string | Uint8Array,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  publicKey = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(hexToBytes(publicKey)));\n  const addrString = addressToString(addr);\n  return addrString;\n}\n\nexport function createStacksPublicKey(key: string): StacksPublicKey {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: hexToBytes(key),\n  };\n}\n\nexport function publicKeyFromSignatureVrs(\n  messageHash: string,\n  messageSignature: MessageSignature | StructuredDataSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\n  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\n  const point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);\n  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\n  return point.toHex(compressed);\n}\n\nexport function publicKeyFromSignatureRsv(\n  messageHash: string,\n  messageSignature: MessageSignature | StructuredDataSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  return publicKeyFromSignatureVrs(\n    messageHash,\n    { ...messageSignature, data: signatureRsvToVrs(messageSignature.data) },\n    pubKeyEncoding\n  );\n}\n\nexport function publicKeyFromBytes(data: Uint8Array): StacksPublicKey {\n  return { type: StacksMessageType.PublicKey, data };\n}\n\nexport function isCompressed(key: StacksPublicKey): boolean {\n  return !bytesToHex(key.data).startsWith('04');\n}\n\nexport function publicKeyToString(key: StacksPublicKey): string {\n  return bytesToHex(key.data);\n}\n\nexport function serializePublicKey(key: StacksPublicKey): Uint8Array {\n  return key.data.slice();\n}\n\nexport function pubKeyfromPrivKey(privateKey: string | Uint8Array): StacksPublicKey {\n  const privKey = createStacksPrivateKey(privateKey);\n  const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\n  return createStacksPublicKey(bytesToHex(publicKey));\n}\n\nexport function compressPublicKey(publicKey: string | Uint8Array): StacksPublicKey {\n  const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const compressed = Point.fromHex(hex).toHex(true);\n  return createStacksPublicKey(compressed);\n}\n\nexport function uncompressPublicKey(publicKey: string | Uint8Array): StacksPublicKey {\n  const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const compressed = Point.fromHex(hex).toHex(false);\n  return createStacksPublicKey(compressed);\n}\n\nexport function deserializePublicKey(bytesReader: BytesReader): StacksPublicKey {\n  const fieldId = bytesReader.readUInt8();\n  const keyLength =\n    fieldId === 4 ? UNCOMPRESSED_PUBKEY_LENGTH_BYTES : COMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBytes(concatArray([fieldId, bytesReader.readBytes(keyLength)]));\n}\n\nexport interface StacksPrivateKey {\n  // \"compressed\" private key is a misnomer: https://web.archive.org/web/20220131144208/https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch04.html#comp_priv\n  // it actually means: should public keys be generated as \"compressed\" or \"uncompressed\" from this private key\n  compressed: boolean;\n  data: Uint8Array;\n}\n\nexport function createStacksPrivateKey(key: string | Uint8Array): StacksPrivateKey {\n  const data = privateKeyToBytes(key);\n  const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\n  return { data, compressed };\n}\n\nexport function makeRandomPrivKey(): StacksPrivateKey {\n  // todo: `next` default to compressed private key\n  return createStacksPrivateKey(utils.randomPrivateKey());\n}\n\n/**\n * @deprecated The Clarity compatible {@link signMessageHashRsv} is preferred, but differs in signature format\n * @returns A recoverable signature (in VRS order)\n */\nexport function signWithKey(privateKey: StacksPrivateKey, messageHash: string): MessageSignature {\n  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {\n    canonical: true,\n    recovered: true,\n  });\n  if (recoveryId == null) {\n    throw new Error('No signature recoveryId received');\n  }\n  const recoveryIdHex = intToHex(recoveryId, 1);\n  const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex(); // V + RS\n  return createMessageSignature(recoverableSignatureString);\n}\n\n/**\n * Signs a message using a private key. The resulting signature along with the\n * original message can be verified using {@link verifyMessageSignatureRsv}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signMessageHashRsv({\n  messageHash,\n  privateKey,\n}: {\n  messageHash: string;\n  privateKey: StacksPrivateKey;\n}): MessageSignature {\n  const messageSignature = signWithKey(privateKey, messageHash);\n  return { ...messageSignature, data: signatureVrsToRsv(messageSignature.data) };\n}\n\nexport function getPublicKey(privateKey: StacksPrivateKey): StacksPublicKey {\n  return pubKeyfromPrivKey(privateKey.data);\n}\n\nexport function privateKeyToString(privateKey: StacksPrivateKey): string {\n  return bytesToHex(privateKey.data);\n}\n\nexport function publicKeyToAddress(version: AddressVersion, publicKey: StacksPublicKey): string {\n  return c32address(version, bytesToHex(hash160(publicKey.data)));\n}\n", "import {\n  bytesToHex,\n  concatArray,\n  hexToBytes,\n  IntegerType,\n  intToBigInt,\n  intToBytes,\n  writeUInt32BE,\n  writeUInt8,\n} from '@stacks/common';\nimport { BytesReader } from './bytesReader';\nimport {\n  ClarityType,\n  ClarityValue,\n  deserializeCV,\n  noneCV,\n  OptionalCV,\n  serializeCV,\n  someCV,\n} from './clarity/';\nimport { PrincipalCV, principalCV } from './clarity/types/principalCV';\nimport { Address } from './common';\nimport {\n  ClarityVersion,\n  COINBASE_BYTES_LENGTH,\n  PayloadType,\n  StacksMessageType,\n  VRF_PROOF_BYTES_LENGTH,\n} from './constants';\nimport { createAddress, createLPString, LengthPrefixedString } from './postcondition-types';\nimport {\n  codeBodyString,\n  createMemoString,\n  deserializeAddress,\n  deserializeLPString,\n  deserializeMemoString,\n  MemoString,\n  serializeStacksMessage,\n} from './types';\n\nexport type Payload =\n  | TokenTransferPayload\n  | ContractCallPayload\n  | SmartContractPayload\n  | VersionedSmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload\n  | CoinbasePayloadToAltRecipient\n  | NakamotoCoinbasePayload\n  | TenureChangePayload;\n\nexport function isTokenTransferPayload(p: Payload): p is TokenTransferPayload {\n  return p.payloadType === PayloadType.TokenTransfer;\n}\nexport function isContractCallPayload(p: Payload): p is ContractCallPayload {\n  return p.payloadType === PayloadType.ContractCall;\n}\nexport function isSmartContractPayload(p: Payload): p is SmartContractPayload {\n  return p.payloadType === PayloadType.SmartContract;\n}\nexport function isPoisonPayload(p: Payload): p is PoisonPayload {\n  return p.payloadType === PayloadType.PoisonMicroblock;\n}\nexport function isCoinbasePayload(p: Payload): p is CoinbasePayload {\n  return p.payloadType === PayloadType.Coinbase;\n}\n\nexport interface TokenTransferPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.TokenTransfer;\n  readonly recipient: PrincipalCV;\n  readonly amount: bigint;\n  readonly memo: MemoString;\n}\n\nexport type PayloadInput =\n  | (TokenTransferPayload | (Omit<TokenTransferPayload, 'amount'> & { amount: IntegerType }))\n  | ContractCallPayload\n  | SmartContractPayload\n  | VersionedSmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload\n  | CoinbasePayloadToAltRecipient\n  | NakamotoCoinbasePayload\n  | TenureChangePayload;\n\nexport function createTokenTransferPayload(\n  recipient: string | PrincipalCV,\n  amount: IntegerType,\n  memo?: string | MemoString\n): TokenTransferPayload {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount: intToBigInt(amount, false),\n    memo: memo ?? createMemoString(''),\n  };\n}\n\nexport interface ContractCallPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.ContractCall;\n  readonly contractAddress: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly functionName: LengthPrefixedString;\n  readonly functionArgs: ClarityValue[];\n}\n\nexport function createContractCallPayload(\n  contractAddress: string | Address,\n  contractName: string | LengthPrefixedString,\n  functionName: string | LengthPrefixedString,\n  functionArgs: ClarityValue[]\n): ContractCallPayload {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs,\n  };\n}\n\nexport interface SmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.SmartContract;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport interface VersionedSmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.VersionedSmartContract;\n  readonly clarityVersion: ClarityVersion;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport function createSmartContractPayload(\n  contractName: string | LengthPrefixedString,\n  codeBody: string | LengthPrefixedString,\n  clarityVersion?: ClarityVersion\n): SmartContractPayload | VersionedSmartContractPayload {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n\n  if (typeof clarityVersion === 'number') {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.VersionedSmartContract,\n      clarityVersion,\n      contractName,\n      codeBody,\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody,\n  };\n}\n\nexport interface PoisonPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.PoisonMicroblock;\n}\n\nexport function createPoisonPayload(): PoisonPayload {\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };\n}\n\nexport interface CoinbasePayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.Coinbase;\n  readonly coinbaseBytes: Uint8Array;\n}\n\nexport interface CoinbasePayloadToAltRecipient {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.CoinbaseToAltRecipient;\n  readonly coinbaseBytes: Uint8Array;\n  readonly recipient: PrincipalCV;\n}\n\nexport function createCoinbasePayload(\n  coinbaseBytes: Uint8Array,\n  altRecipient?: PrincipalCV\n): CoinbasePayload | CoinbasePayloadToAltRecipient {\n  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BYTES_LENGTH} bytes`);\n  }\n\n  if (altRecipient != undefined) {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.CoinbaseToAltRecipient,\n      coinbaseBytes,\n      recipient: altRecipient,\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.Coinbase,\n    coinbaseBytes,\n  };\n}\n\nexport interface NakamotoCoinbasePayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.NakamotoCoinbase;\n  readonly coinbaseBytes: Uint8Array;\n  readonly recipient?: PrincipalCV;\n  readonly vrfProof: Uint8Array;\n}\n\nexport function createNakamotoCoinbasePayload(\n  coinbaseBytes: Uint8Array,\n  recipient: OptionalCV<PrincipalCV>,\n  vrfProof: Uint8Array\n): NakamotoCoinbasePayload {\n  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BYTES_LENGTH} bytes`);\n  }\n\n  if (vrfProof.byteLength != VRF_PROOF_BYTES_LENGTH) {\n    throw Error(`VRF proof buffer size must be ${VRF_PROOF_BYTES_LENGTH} bytes`);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.NakamotoCoinbase,\n    coinbaseBytes,\n    recipient: recipient.type === ClarityType.OptionalSome ? recipient.value : undefined,\n    vrfProof,\n  };\n}\n\nexport enum TenureChangeCause {\n  /** A valid winning block-commit */\n  BlockFound = 0,\n  /** The next burnchain block is taking too long, so extend the runtime budget */\n  Extended = 1,\n}\n\nexport interface TenureChangePayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.TenureChange;\n  /**\n   * The consensus hash of this tenure (hex string). Corresponds to the\n   * sortition in which the miner of this block was chosen. It may be the case\n   * that this miner's tenure gets _extended_ acrosssubsequent sortitions; if\n   * this happens, then this `consensus_hash` value _remains the same _as the\n   * sortition in which the winning block-commit was mined.\n   */\n  readonly tenureHash: string;\n  /**\n   * The consensus hash (hex string) of the previous tenure.  Corresponds to the\n   * sortition of the previous winning block-commit.\n   */\n  readonly previousTenureHash: string;\n  /**\n   * Current consensus hash (hex string) on the underlying burnchain.\n   * Corresponds to the last-seen sortition.\n   */\n  readonly burnViewHash: string;\n  /** Stacks block hash (hex string) */\n  readonly previousTenureEnd: string;\n  /** The number of blocks produced since the last sortition-linked tenure */\n  readonly previousTenureBlocks: number;\n  /** The cause of change in mining tenure */\n  readonly cause: TenureChangeCause;\n  /** The public key hash of the current tenure (hex string) */\n  readonly publicKeyHash: string;\n}\n\nexport function createTenureChangePayload(\n  tenureHash: string,\n  previousTenureHash: string,\n  burnViewHash: string,\n  previousTenureEnd: string,\n  previousTenureBlocks: number,\n  cause: TenureChangeCause,\n  publicKeyHash: string\n): TenureChangePayload {\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TenureChange,\n    tenureHash,\n    previousTenureHash,\n    burnViewHash,\n    previousTenureEnd,\n    previousTenureBlocks,\n    cause,\n    publicKeyHash,\n  };\n}\n\nexport function serializePayload(payload: PayloadInput): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(payload.payloadType);\n\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bytesArray.push(serializeCV(payload.recipient));\n      bytesArray.push(intToBytes(payload.amount, false, 8));\n      bytesArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bytesArray.push(serializeStacksMessage(payload.contractAddress));\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = new Uint8Array(4);\n      writeUInt32BE(numArgs, payload.functionArgs.length, 0);\n      bytesArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bytesArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.VersionedSmartContract:\n      bytesArray.push(payload.clarityVersion);\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      break;\n    case PayloadType.Coinbase:\n      bytesArray.push(payload.coinbaseBytes);\n      break;\n    case PayloadType.CoinbaseToAltRecipient:\n      bytesArray.push(payload.coinbaseBytes);\n      bytesArray.push(serializeCV(payload.recipient));\n      break;\n    case PayloadType.NakamotoCoinbase:\n      bytesArray.push(payload.coinbaseBytes);\n      bytesArray.push(serializeCV(payload.recipient ? someCV(payload.recipient) : noneCV()));\n      bytesArray.push(payload.vrfProof);\n      break;\n    case PayloadType.TenureChange:\n      bytesArray.push(hexToBytes(payload.tenureHash));\n      bytesArray.push(hexToBytes(payload.previousTenureHash));\n      bytesArray.push(hexToBytes(payload.burnViewHash));\n      bytesArray.push(hexToBytes(payload.previousTenureEnd));\n      bytesArray.push(writeUInt32BE(new Uint8Array(4), payload.previousTenureBlocks));\n      bytesArray.push(writeUInt8(new Uint8Array(1), payload.cause));\n      bytesArray.push(hexToBytes(payload.publicKeyHash));\n      break;\n  }\n\n  return concatArray(bytesArray);\n}\n\nexport function deserializePayload(bytesReader: BytesReader): Payload {\n  const payloadType = bytesReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bytesReader) as PrincipalCV;\n      const amount = intToBigInt(bytesReader.readBytes(8), false);\n      const memo = deserializeMemoString(bytesReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bytesReader);\n      const contractCallName = deserializeLPString(bytesReader);\n      const functionName = deserializeLPString(bytesReader);\n      const functionArgs: ClarityValue[] = [];\n      const numberOfArgs = bytesReader.readUInt32BE();\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bytesReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(\n        contractAddress,\n        contractCallName,\n        functionName,\n        functionArgs\n      );\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bytesReader);\n      const codeBody = deserializeLPString(bytesReader, 4, 100_000);\n      return createSmartContractPayload(smartContractName, codeBody);\n\n    case PayloadType.VersionedSmartContract: {\n      const clarityVersion = bytesReader.readUInt8Enum(ClarityVersion, n => {\n        throw new Error(`Cannot recognize ClarityVersion: ${n}`);\n      });\n      const smartContractName = deserializeLPString(bytesReader);\n      const codeBody = deserializeLPString(bytesReader, 4, 100_000);\n      return createSmartContractPayload(smartContractName, codeBody, clarityVersion);\n    }\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      return createPoisonPayload();\n    case PayloadType.Coinbase: {\n      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      return createCoinbasePayload(coinbaseBytes);\n    }\n    case PayloadType.CoinbaseToAltRecipient: {\n      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      const altRecipient = deserializeCV(bytesReader) as PrincipalCV;\n      return createCoinbasePayload(coinbaseBytes, altRecipient);\n    }\n    case PayloadType.NakamotoCoinbase: {\n      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      const recipient = deserializeCV(bytesReader) as OptionalCV<PrincipalCV>;\n      const vrfProof = bytesReader.readBytes(VRF_PROOF_BYTES_LENGTH);\n      return createNakamotoCoinbasePayload(coinbaseBytes, recipient, vrfProof);\n    }\n    case PayloadType.TenureChange:\n      const tenureHash = bytesToHex(bytesReader.readBytes(20));\n      const previousTenureHash = bytesToHex(bytesReader.readBytes(20));\n      const burnViewHash = bytesToHex(bytesReader.readBytes(20));\n      const previousTenureEnd = bytesToHex(bytesReader.readBytes(32));\n      const previousTenureBlocks = bytesReader.readUInt32BE();\n      const cause = bytesReader.readUInt8Enum(TenureChangeCause, n => {\n        throw new Error(`Cannot recognize TenureChangeCause: ${n}`);\n      });\n      const publicKeyHash = bytesToHex(bytesReader.readBytes(20));\n      return createTenureChangePayload(\n        tenureHash,\n        previousTenureHash,\n        burnViewHash,\n        previousTenureEnd,\n        previousTenureBlocks,\n        cause,\n        publicKeyHash\n      );\n  }\n}\n", "class TransactionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class SerializationError extends TransactionError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class DeserializationError extends TransactionError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n/**\n * Thrown when `NoEstimateAvailable` is received as an error reason from a\n * Stacks node. The Stacks node has not seen this kind of contract-call before,\n * and it cannot provide an estimate yet.\n * @see https://docs.hiro.so/api#tag/Fees/operation/post_fee_transaction\n */\nexport class NoEstimateAvailableError extends TransactionError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class NotImplementedError extends TransactionError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class SigningError extends TransactionError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class VerificationError extends TransactionError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n", "import { BytesReader } from './bytesReader';\nimport { DeserializationError } from './errors';\nimport { PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport {\n  compressPublicKey,\n  deserializePublicKey,\n  serializePublicKey,\n  StacksPublicKey,\n  uncompressPublicKey,\n} from './keys';\n\nimport { createMessageSignature, MessageSignature } from './common';\n\n// @ts-ignore\nimport { bytesToHex, concatArray, hexToBytes } from '@stacks/common';\n\nexport enum AuthFieldType {\n  PublicKeyCompressed = 0x00,\n  PublicKeyUncompressed = 0x01,\n  SignatureCompressed = 0x02,\n  SignatureUncompressed = 0x03,\n}\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;\n\nexport function deserializeMessageSignature(bytesReader: BytesReader): MessageSignature {\n  return createMessageSignature(\n    bytesToHex(bytesReader.readBytes(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES))\n  );\n}\n\n// todo: `next` refactor to match wire format more precisely eg https://github.com/jbencin/sips/blob/sip-02x-non-sequential-multisig-transactions/sips/sip-02x/sip-02x-non-sequential-multisig-transactions.md\n//  \"A spending authorization field is encoded as follows:\" ...\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport function createTransactionAuthField(\n  pubKeyEncoding: PubKeyEncoding,\n  contents: TransactionAuthFieldContents\n): TransactionAuthField {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents,\n  };\n}\n\nexport function deserializeTransactionAuthField(bytesReader: BytesReader): TransactionAuthField {\n  const authFieldType = bytesReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializePublicKey(bytesReader)\n      );\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        uncompressPublicKey(deserializePublicKey(bytesReader).data)\n      );\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializeMessageSignature(bytesReader)\n      );\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializeMessageSignature(bytesReader)\n      );\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\n\nexport function serializeMessageSignature(messageSignature: MessageSignature): Uint8Array {\n  return hexToBytes(messageSignature.data);\n}\n\nexport function serializeTransactionAuthField(field: TransactionAuthField): Uint8Array {\n  const bytesArray = [];\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      bytesArray.push(\n        field.pubKeyEncoding === PubKeyEncoding.Compressed\n          ? AuthFieldType.PublicKeyCompressed\n          : AuthFieldType.PublicKeyUncompressed\n      );\n      bytesArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      break;\n    case StacksMessageType.MessageSignature:\n      bytesArray.push(\n        field.pubKeyEncoding === PubKeyEncoding.Compressed\n          ? AuthFieldType.SignatureCompressed\n          : AuthFieldType.SignatureUncompressed\n      );\n      bytesArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return concatArray(bytesArray);\n}\n", "import {\n  bytesToHex,\n  bytesToUtf8,\n  concatArray,\n  hexToBytes,\n  hexToInt,\n  intToBytes,\n  intToHex,\n  utf8ToBytes,\n} from '@stacks/common';\nimport {\n  MEMO_MAX_LENGTH_BYTES,\n  AddressHashMode,\n  AddressVersion,\n  TransactionVersion,\n  StacksMessageType,\n  PostConditionPrincipalID,\n  PostConditionType,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n} from './constants';\n\nimport { StacksPublicKey, serializePublicKey, deserializePublicKey, isCompressed } from './keys';\n\nimport {\n  exceedsMaxLengthBytes,\n  hashP2PKH,\n  rightPadHexToLength,\n  hashP2SH,\n  hashP2WSH,\n  hashP2WPKH,\n} from './utils';\n\nimport { BytesReader } from './bytesReader';\nimport {\n  PostCondition,\n  StandardPrincipal,\n  ContractPrincipal,\n  PostConditionPrincipal,\n  LengthPrefixedString,\n  AssetInfo,\n  createLPString,\n} from './postcondition-types';\nimport { Payload, deserializePayload, serializePayload } from './payload';\nimport { DeserializationError, SerializationError } from './errors';\nimport {\n  deserializeTransactionAuthField,\n  deserializeMessageSignature,\n  serializeMessageSignature,\n  serializeTransactionAuthField,\n  TransactionAuthField,\n} from './signature';\nimport {\n  MessageSignature,\n  Address,\n  addressHashModeToVersion,\n  addressFromVersionHash,\n} from './common';\nimport { deserializeCV, serializeCV } from './clarity';\nexport type StacksMessage =\n  | Address\n  | PostConditionPrincipal\n  | LengthPrefixedString\n  | LengthPrefixedList\n  | Payload\n  | MemoString\n  | AssetInfo\n  | PostCondition\n  | StacksPublicKey\n  | TransactionAuthField\n  | MessageSignature;\n\nexport function serializeStacksMessage(message: StacksMessage): Uint8Array {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\n\nexport function deserializeStacksMessage(\n  bytesReader: BytesReader,\n  type: StacksMessageType,\n  listType?: StacksMessageType\n): StacksMessage {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bytesReader);\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bytesReader);\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bytesReader);\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bytesReader);\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bytesReader);\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bytesReader);\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bytesReader);\n    case StacksMessageType.Payload:\n      return deserializePayload(bytesReader);\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n      return deserializeLPList(bytesReader, listType);\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bytesReader);\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\n\nexport function createEmptyAddress(): Address {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40),\n  };\n}\n\nexport function addressFromHashMode(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion,\n  data: string\n): Address {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\n\nexport function addressFromPublicKeys(\n  version: AddressVersion,\n  hashMode: AddressHashMode,\n  numSigs: number,\n  publicKeys: StacksPublicKey[]\n): Address {\n  // todo: `next` refactor to `requiredSignatures`, and opts object\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n\n  if (\n    hashMode === AddressHashMode.SerializeP2WPKH ||\n    hashMode === AddressHashMode.SerializeP2WSH ||\n    hashMode === AddressHashMode.SerializeP2WSHNonSequential\n  ) {\n    if (!publicKeys.every(isCompressed)) {\n      throw Error('Public keys must be compressed for segwit');\n    }\n  }\n\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2WPKH:\n      return addressFromVersionHash(version, hashP2WPKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2SHNonSequential:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n    case AddressHashMode.SerializeP2WSH:\n    case AddressHashMode.SerializeP2WSHNonSequential:\n      return addressFromVersionHash(\n        version,\n        hashP2WSH(numSigs, publicKeys.map(serializePublicKey))\n      );\n  }\n}\n\nexport function serializeAddress(address: Address): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(hexToBytes(intToHex(address.version, 1)));\n  bytesArray.push(hexToBytes(address.hash160));\n  return concatArray(bytesArray);\n}\n\nexport function deserializeAddress(bytesReader: BytesReader): Address {\n  const version = hexToInt(bytesToHex(bytesReader.readBytes(1)));\n  const data = bytesToHex(bytesReader.readBytes(20));\n\n  return { type: StacksMessageType.Address, version, hash160: data };\n}\n\nexport function serializePrincipal(principal: PostConditionPrincipal): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(principal.prefix);\n  bytesArray.push(serializeAddress(principal.address));\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bytesArray.push(serializeLPString(principal.contractName));\n  }\n  return concatArray(bytesArray);\n}\n\nexport function deserializePrincipal(bytesReader: BytesReader): PostConditionPrincipal {\n  const prefix = bytesReader.readUInt8Enum(PostConditionPrincipalID, n => {\n    throw new DeserializationError(`Unexpected Principal payload type: ${n}`);\n  });\n  const address = deserializeAddress(bytesReader);\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return { type: StacksMessageType.Principal, prefix, address } as StandardPrincipal;\n  }\n  const contractName = deserializeLPString(bytesReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName,\n  } as ContractPrincipal;\n}\n\nexport function serializeLPString(lps: LengthPrefixedString) {\n  const bytesArray = [];\n  const contentBytes = utf8ToBytes(lps.content);\n  const length = contentBytes.byteLength;\n  bytesArray.push(hexToBytes(intToHex(length, lps.lengthPrefixBytes)));\n  bytesArray.push(contentBytes);\n  return concatArray(bytesArray);\n}\n\nexport function deserializeLPString(\n  bytesReader: BytesReader,\n  prefixBytes?: number,\n  maxLength?: number\n): LengthPrefixedString {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexToInt(bytesToHex(bytesReader.readBytes(prefixBytes)));\n  const content = bytesToUtf8(bytesReader.readBytes(length));\n  return createLPString(content, prefixBytes, maxLength ?? 128);\n}\n\nexport function codeBodyString(content: string): LengthPrefixedString {\n  return createLPString(content, 4, 100_000);\n}\n\nexport interface MemoString {\n  readonly type: StacksMessageType.MemoString;\n  readonly content: string;\n}\n\nexport function createMemoString(content: string): MemoString {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES} bytes`);\n  }\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeMemoString(memoString: MemoString): Uint8Array {\n  const bytesArray = [];\n  const contentBytes = utf8ToBytes(memoString.content);\n  const paddedContent = rightPadHexToLength(bytesToHex(contentBytes), MEMO_MAX_LENGTH_BYTES * 2);\n  bytesArray.push(hexToBytes(paddedContent));\n  return concatArray(bytesArray);\n}\n\nexport function deserializeMemoString(bytesReader: BytesReader): MemoString {\n  let content = bytesToUtf8(bytesReader.readBytes(MEMO_MAX_LENGTH_BYTES));\n  content = content.replace(/\\u0000*$/, ''); // remove all trailing unicode null characters\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeAssetInfo(info: AssetInfo): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(serializeAddress(info.address));\n  bytesArray.push(serializeLPString(info.contractName));\n  bytesArray.push(serializeLPString(info.assetName));\n  return concatArray(bytesArray);\n}\n\nexport function deserializeAssetInfo(bytesReader: BytesReader): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bytesReader),\n    contractName: deserializeLPString(bytesReader),\n    assetName: deserializeLPString(bytesReader),\n  };\n}\n\nexport interface LengthPrefixedList {\n  readonly type: StacksMessageType.LengthPrefixedList;\n  readonly lengthPrefixBytes: number;\n  readonly values: StacksMessage[];\n}\n\nexport function createLPList<T extends StacksMessage>(\n  values: T[],\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values,\n  };\n}\n\nexport function serializeLPList(lpList: LengthPrefixedList): Uint8Array {\n  const list = lpList.values;\n  const bytesArray = [];\n  bytesArray.push(hexToBytes(intToHex(list.length, lpList.lengthPrefixBytes)));\n  for (const l of list) {\n    bytesArray.push(serializeStacksMessage(l));\n  }\n  return concatArray(bytesArray);\n}\n\n// todo: `next` refactor for inversion of control\nexport function deserializeLPList(\n  bytesReader: BytesReader,\n  type: StacksMessageType,\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  const length = hexToInt(bytesToHex(bytesReader.readBytes(lengthPrefixBytes || 4)));\n\n  const l: StacksMessage[] = [];\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bytesReader));\n        break;\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bytesReader));\n        break;\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bytesReader));\n        break;\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bytesReader));\n        break;\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bytesReader));\n        break;\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bytesReader));\n        break;\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bytesReader));\n        break;\n    }\n  }\n  return createLPList(l, lengthPrefixBytes);\n}\n\nexport function serializePostCondition(postCondition: PostCondition): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(postCondition.conditionType);\n  bytesArray.push(serializePrincipal(postCondition.principal));\n\n  if (\n    postCondition.conditionType === PostConditionType.Fungible ||\n    postCondition.conditionType === PostConditionType.NonFungible\n  ) {\n    bytesArray.push(serializeAssetInfo(postCondition.assetInfo));\n  }\n\n  if (postCondition.conditionType === PostConditionType.NonFungible) {\n    bytesArray.push(serializeCV(postCondition.assetName));\n  }\n\n  bytesArray.push(postCondition.conditionCode);\n\n  if (\n    postCondition.conditionType === PostConditionType.STX ||\n    postCondition.conditionType === PostConditionType.Fungible\n  ) {\n    // SIP-005: Maximal length of amount is 8 bytes\n    if (postCondition.amount > BigInt('0xffffffffffffffff'))\n      throw new SerializationError('The post-condition amount may not be larger than 8 bytes');\n    bytesArray.push(intToBytes(postCondition.amount, false, 8));\n  }\n\n  return concatArray(bytesArray);\n}\n\nexport function deserializePostCondition(bytesReader: BytesReader): PostCondition {\n  const postConditionType = bytesReader.readUInt8Enum(PostConditionType, n => {\n    throw new DeserializationError(`Could not read ${n} as PostConditionType`);\n  });\n\n  const principal = deserializePrincipal(bytesReader);\n\n  let conditionCode;\n  let assetInfo;\n  let amount: bigint;\n  switch (postConditionType) {\n    case PostConditionType.STX:\n      conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.STX,\n        principal,\n        conditionCode,\n        amount,\n      };\n    case PostConditionType.Fungible:\n      assetInfo = deserializeAssetInfo(bytesReader);\n      conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.Fungible,\n        principal,\n        conditionCode,\n        amount,\n        assetInfo,\n      };\n    case PostConditionType.NonFungible:\n      assetInfo = deserializeAssetInfo(bytesReader);\n      const assetName = deserializeCV(bytesReader);\n      conditionCode = bytesReader.readUInt8Enum(NonFungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.NonFungible,\n        principal,\n        conditionCode,\n        assetInfo,\n        assetName,\n      };\n  }\n}\n", "import {\n  concatArray,\n  concatBytes,\n  bigIntToBytes,\n  toTwos,\n  writeUInt32BE,\n  utf8ToBytes,\n  asciiToBytes,\n} from '@stacks/common';\nimport { serializeAddress, serializeLPString } from '../types';\nimport { createLPString } from '../postcondition-types';\nimport {\n  BooleanCV,\n  OptionalCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseCV,\n  ListCV,\n  TupleCV,\n  ClarityValue,\n} from '.';\nimport { ClarityType } from './constants';\n\nimport { SerializationError } from '../errors';\nimport { StringAsciiCV, StringUtf8CV } from './types/stringCV';\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\n\nfunction bytesWithTypeID(typeId: ClarityType, bytes: Uint8Array): Uint8Array {\n  return concatArray([typeId, bytes]);\n}\n\nfunction serializeBoolCV(value: BooleanCV): Uint8Array {\n  return new Uint8Array([value.type]);\n}\n\nfunction serializeOptionalCV(cv: OptionalCV): Uint8Array {\n  if (cv.type === ClarityType.OptionalNone) {\n    return new Uint8Array([cv.type]);\n  } else {\n    return bytesWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\n\nfunction serializeBufferCV(cv: BufferCV): Uint8Array {\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, cv.buffer.length, 0);\n  return bytesWithTypeID(cv.type, concatBytes(length, cv.buffer));\n}\n\nfunction serializeIntCV(cv: IntCV): Uint8Array {\n  const bytes = bigIntToBytes(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);\n  return bytesWithTypeID(cv.type, bytes);\n}\n\nfunction serializeUIntCV(cv: UIntCV): Uint8Array {\n  const bytes = bigIntToBytes(cv.value, CLARITY_INT_BYTE_SIZE);\n  return bytesWithTypeID(cv.type, bytes);\n}\n\nfunction serializeStandardPrincipalCV(cv: StandardPrincipalCV): Uint8Array {\n  return bytesWithTypeID(cv.type, serializeAddress(cv.address));\n}\n\nfunction serializeContractPrincipalCV(cv: ContractPrincipalCV): Uint8Array {\n  return bytesWithTypeID(\n    cv.type,\n    concatBytes(serializeAddress(cv.address), serializeLPString(cv.contractName))\n  );\n}\n\nfunction serializeResponseCV(cv: ResponseCV) {\n  return bytesWithTypeID(cv.type, serializeCV(cv.value));\n}\n\nfunction serializeListCV(cv: ListCV) {\n  const bytesArray = [];\n\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, cv.list.length, 0);\n  bytesArray.push(length);\n\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    bytesArray.push(serializedValue);\n  }\n\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\n\nfunction serializeTupleCV(cv: TupleCV) {\n  const bytesArray = [];\n\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, Object.keys(cv.data).length, 0);\n  bytesArray.push(length);\n\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => a.localeCompare(b));\n\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    bytesArray.push(serializeLPString(nameWithLength));\n\n    const serializedValue = serializeCV(cv.data[key]);\n    bytesArray.push(serializedValue);\n  }\n\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\n\nfunction serializeStringCV(cv: StringAsciiCV | StringUtf8CV, encoding: 'ascii' | 'utf8') {\n  const bytesArray = [];\n\n  const str = encoding == 'ascii' ? asciiToBytes(cv.data) : utf8ToBytes(cv.data);\n  const len = new Uint8Array(4);\n  writeUInt32BE(len, str.length, 0);\n\n  bytesArray.push(len);\n  bytesArray.push(str);\n\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\n\nfunction serializeStringAsciiCV(cv: StringAsciiCV) {\n  return serializeStringCV(cv, 'ascii');\n}\n\nfunction serializeStringUtf8CV(cv: StringUtf8CV) {\n  return serializeStringCV(cv, 'utf8');\n}\n\n/**\n * Serializes clarity value to Uint8Array\n *\n * @param {ClarityValue} value to be converted to bytes\n *\n * @returns {Uint8Array} returns the bytes\n *\n * @example\n * ```\n *  import { intCV, serializeCV } from '@stacks/transactions';\n *\n *  const serialized = serializeCV(intCV(100)); // Similarly works for other clarity types as well like listCV, booleanCV ...\n *\n *  // <Uint8Array 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64>\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nexport function serializeCV(value: ClarityValue): Uint8Array {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n    case ClarityType.UInt:\n      return serializeUIntCV(value);\n    case ClarityType.Int:\n      return serializeIntCV(value);\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n    case ClarityType.List:\n      return serializeListCV(value);\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}\n", "import { bytesToHex, readUInt16BE, readUInt32BE, readUInt8 } from '@stacks/common';\n\nfunction createEnumChecker<T extends string, TEnumValue extends number>(enumVariable: {\n  [key in T]: TEnumValue;\n}): (value: number) => value is TEnumValue {\n  // Create a set of valid enum number values.\n  const enumValues = Object.values<number>(enumVariable).filter(v => typeof v === 'number');\n  const enumValueSet = new Set<number>(enumValues);\n  return (value: number): value is TEnumValue => enumValueSet.has(value);\n}\n\nconst enumCheckFunctions = new Map<object, (value: number) => boolean>();\n\n/**\n * @ignore\n * Type guard to check if a given value is a valid enum value.\n * @param enumVariable - Literal `enum` type.\n * @param value - A value to check against the enum's values.\n * @example\n * ```ts\n * enum Color {\n *   Purple = 3,\n *   Orange = 5\n * }\n * const val: number = 3;\n * if (isEnum(Color, val)) {\n *   // `val` is known as enum type `Color`, e.g.:\n *   const colorVal: Color = val;\n * }\n * ```\n */\nexport function isEnum<T extends string, TEnumValue extends number>(\n  enumVariable: { [key in T]: TEnumValue },\n  value: number\n): value is TEnumValue {\n  const checker = enumCheckFunctions.get(enumVariable);\n  if (checker !== undefined) {\n    return checker(value);\n  }\n  const newChecker = createEnumChecker(enumVariable);\n  enumCheckFunctions.set(enumVariable, newChecker);\n  return isEnum(enumVariable, value);\n}\n\n/** @ignore */\nexport class BytesReader {\n  source: Uint8Array;\n  consumed: number = 0;\n\n  constructor(arr: Uint8Array) {\n    this.source = arr;\n  }\n\n  readBytes(length: number): Uint8Array {\n    const view = this.source.subarray(this.consumed, this.consumed + length);\n    this.consumed += length;\n    return view;\n  }\n\n  readUInt32BE(): number {\n    return readUInt32BE(this.readBytes(4), 0);\n  }\n\n  readUInt8(): number {\n    return readUInt8(this.readBytes(1), 0);\n  }\n\n  readUInt16BE(): number {\n    return readUInt16BE(this.readBytes(2), 0);\n  }\n\n  readBigUIntLE(length: number): bigint {\n    const bytes = this.readBytes(length).slice().reverse();\n    const hex = bytesToHex(bytes);\n    return BigInt(`0x${hex}`);\n  }\n\n  readBigUIntBE(length: number): bigint {\n    const bytes = this.readBytes(length);\n    const hex = bytesToHex(bytes);\n    return BigInt(`0x${hex}`);\n  }\n\n  // todo: remove or implement with DataView?\n  // readBigUInt64BE(): bigint {\n  //   return this.source.readBigUInt64BE();\n  // }\n\n  get readOffset(): number {\n    return this.consumed;\n  }\n\n  set readOffset(val: number) {\n    this.consumed = val;\n  }\n\n  get internalBytes(): Uint8Array {\n    return this.source;\n  }\n\n  readUInt8Enum<T extends string, TEnumValue extends number>(\n    enumVariable: { [key in T]: TEnumValue },\n    invalidEnumErrorFormatter: (val: number) => Error\n  ): TEnumValue {\n    const num = this.readUInt8();\n    if (isEnum(enumVariable, num)) {\n      return num;\n    }\n    throw invalidEnumErrorFormatter(num);\n  }\n}\n", "import {\n  ClarityType,\n  ClarityValue,\n  intCV,\n  uintCV,\n  bufferCV,\n  trueCV,\n  falseCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCVFromAddress,\n  responseOkCV,\n  responseErrorCV,\n  noneCV,\n  someCV,\n  listCV,\n  tupleCV,\n} from '.';\nimport { BytesReader as BytesReader } from '../bytesReader';\nimport { deserializeAddress, deserializeLPString } from '../types';\nimport { DeserializationError } from '../errors';\nimport { stringAsciiCV, stringUtf8CV } from './types/stringCV';\nimport { bytesToAscii, bytesToUtf8, hexToBytes } from '@stacks/common';\n\n/**\n * Deserializes clarity value to clarity type\n *\n * @param {value} Uint8Array | string value to be converted to clarity type\n **\n * @returns {ClarityType} returns the clarity type instance\n *\n * @example\n * ```\n *  import { intCV, serializeCV, deserializeCV } from '@stacks/transactions';\n *\n *  const serialized = serializeCV(intCV(100)); // Similarly works for other clarity types as well like listCV, booleanCV ...\n *\n *  // <Uint8Array 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64>\n *\n *  const deserialized = deserializeCV(serialized);\n *  // { type: 0, value: 100n }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nexport default function deserializeCV<T extends ClarityValue = ClarityValue>(\n  serializedClarityValue: BytesReader | Uint8Array | string\n): T {\n  let bytesReader: BytesReader;\n  if (typeof serializedClarityValue === 'string') {\n    const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === '0x';\n    bytesReader = new BytesReader(\n      hexToBytes(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue)\n    );\n  } else if (serializedClarityValue instanceof Uint8Array) {\n    bytesReader = new BytesReader(serializedClarityValue);\n  } else {\n    bytesReader = serializedClarityValue;\n  }\n  const type = bytesReader.readUInt8Enum(ClarityType, n => {\n    throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);\n  });\n\n  switch (type) {\n    case ClarityType.Int:\n      return intCV(bytesReader.readBytes(16)) as T;\n\n    case ClarityType.UInt:\n      return uintCV(bytesReader.readBytes(16)) as T;\n\n    case ClarityType.Buffer:\n      const bufferLength = bytesReader.readUInt32BE();\n      return bufferCV(bytesReader.readBytes(bufferLength)) as T;\n\n    case ClarityType.BoolTrue:\n      return trueCV() as T;\n\n    case ClarityType.BoolFalse:\n      return falseCV() as T;\n\n    case ClarityType.PrincipalStandard:\n      const sAddress = deserializeAddress(bytesReader);\n      return standardPrincipalCVFromAddress(sAddress) as T;\n\n    case ClarityType.PrincipalContract:\n      const cAddress = deserializeAddress(bytesReader);\n      const contractName = deserializeLPString(bytesReader);\n      return contractPrincipalCVFromAddress(cAddress, contractName) as T;\n\n    case ClarityType.ResponseOk:\n      return responseOkCV(deserializeCV(bytesReader)) as T;\n\n    case ClarityType.ResponseErr:\n      return responseErrorCV(deserializeCV(bytesReader)) as T;\n\n    case ClarityType.OptionalNone:\n      return noneCV() as T;\n\n    case ClarityType.OptionalSome:\n      return someCV(deserializeCV(bytesReader)) as T;\n\n    case ClarityType.List:\n      const listLength = bytesReader.readUInt32BE();\n      const listContents: ClarityValue[] = [];\n      for (let i = 0; i < listLength; i++) {\n        listContents.push(deserializeCV(bytesReader));\n      }\n      return listCV(listContents) as T;\n\n    case ClarityType.Tuple:\n      const tupleLength = bytesReader.readUInt32BE();\n      const tupleContents: { [key: string]: ClarityValue } = {};\n      for (let i = 0; i < tupleLength; i++) {\n        const clarityName = deserializeLPString(bytesReader).content;\n        if (clarityName === undefined) {\n          throw new DeserializationError('\"content\" is undefined');\n        }\n        tupleContents[clarityName] = deserializeCV(bytesReader);\n      }\n      return tupleCV(tupleContents) as T;\n\n    case ClarityType.StringASCII:\n      const asciiStrLen = bytesReader.readUInt32BE();\n      const asciiStr = bytesToAscii(bytesReader.readBytes(asciiStrLen));\n      return stringAsciiCV(asciiStr) as T;\n\n    case ClarityType.StringUTF8:\n      const utf8StrLen = bytesReader.readUInt32BE();\n      const utf8Str = bytesToUtf8(bytesReader.readBytes(utf8StrLen));\n      return stringUtf8CV(utf8Str) as T;\n\n    default:\n      throw new DeserializationError(\n        'Unable to deserialize Clarity Value from Uint8Array. Could not find valid Clarity Type.'\n      );\n  }\n}\n", "import {\n  bytesToHex,\n  concatArray,\n  hexToBytes,\n  IntegerType,\n  intToBigInt,\n  intToBytes,\n  writeUInt16BE,\n} from '@stacks/common';\nimport {\n  AddressHashMode,\n  AuthType,\n  MultiSigHashMode,\n  PubKeyEncoding,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  SingleSigHashMode,\n  StacksMessageType,\n} from './constants';\n\nimport { cloneDeep, leftPadHex, txidFromData } from './utils';\nimport {\n  TransactionAuthField,\n  serializeMessageSignature,\n  deserializeMessageSignature,\n} from './signature';\nimport {\n  addressFromPublicKeys,\n  createEmptyAddress,\n  createLPList,\n  deserializeLPList,\n  serializeLPList,\n} from './types';\n\nimport {\n  createStacksPublicKey,\n  getPublicKey,\n  isCompressed,\n  publicKeyFromSignatureVrs,\n  signWithKey,\n  StacksPrivateKey,\n  StacksPublicKey,\n} from './keys';\n\nimport { MessageSignature } from './common';\nimport { DeserializationError, SigningError, VerificationError } from './errors';\nimport { BytesReader } from './bytesReader';\n\nexport function emptyMessageSignature(): MessageSignature {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: bytesToHex(new Uint8Array(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)),\n  };\n}\n\nexport interface SingleSigSpendingCondition {\n  hashMode: SingleSigHashMode;\n  signer: string;\n  nonce: bigint;\n  fee: bigint;\n  keyEncoding: PubKeyEncoding;\n  signature: MessageSignature;\n}\n\nexport interface SingleSigSpendingConditionOpts\n  extends Omit<SingleSigSpendingCondition, 'nonce' | 'fee'> {\n  nonce: IntegerType;\n  fee: IntegerType;\n}\n\nexport interface MultiSigSpendingCondition {\n  hashMode: MultiSigHashMode;\n  signer: string;\n  nonce: bigint;\n  fee: bigint;\n  fields: TransactionAuthField[];\n  signaturesRequired: number;\n}\n\nexport interface MultiSigSpendingConditionOpts\n  extends Omit<MultiSigSpendingCondition, 'nonce' | 'fee'> {\n  nonce: IntegerType;\n  fee: IntegerType;\n}\n\nexport type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;\n\nexport type SpendingConditionOpts = SingleSigSpendingConditionOpts | MultiSigSpendingConditionOpts;\n\nexport function createSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  pubKey: string,\n  nonce: IntegerType,\n  fee: IntegerType\n): SingleSigSpendingCondition {\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(\n    0 as any, // only used for hash, so version doesn't matter\n    hashMode,\n    1,\n    [createStacksPublicKey(pubKey)]\n  ).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    keyEncoding,\n    signature: emptyMessageSignature(),\n  };\n}\n\nexport function createMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  numSigs: number,\n  pubKeys: string[],\n  nonce: IntegerType,\n  fee: IntegerType\n): MultiSigSpendingCondition {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(\n    0 as any, // only used for hash, so version doesn't matter\n    hashMode,\n    numSigs,\n    stacksPublicKeys\n  ).hash160;\n\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    fields: [],\n    signaturesRequired: numSigs,\n  };\n}\n\n/** @internal */\nexport function isSingleSig(\n  condition: SpendingConditionOpts\n): condition is SingleSigSpendingConditionOpts {\n  return 'signature' in condition;\n}\n\n/** @internal */\nexport function isSequentialMultiSig(hashMode: AddressHashMode): boolean {\n  return hashMode === AddressHashMode.SerializeP2SH || hashMode === AddressHashMode.SerializeP2WSH;\n}\n\n/** @internal */\nexport function isNonSequentialMultiSig(hashMode: AddressHashMode): boolean {\n  return (\n    hashMode === AddressHashMode.SerializeP2SHNonSequential ||\n    hashMode === AddressHashMode.SerializeP2WSHNonSequential\n  );\n}\n\nfunction clearCondition(condition: SpendingConditionOpts): SpendingCondition {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = 0;\n  cloned.fee = 0;\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return {\n    ...cloned,\n    nonce: BigInt(0),\n    fee: BigInt(0),\n  };\n}\n\nexport function serializeSingleSigSpendingCondition(\n  condition: SingleSigSpendingConditionOpts\n): Uint8Array {\n  const bytesArray = [\n    condition.hashMode,\n    hexToBytes(condition.signer),\n    intToBytes(condition.nonce, false, 8),\n    intToBytes(condition.fee, false, 8),\n    condition.keyEncoding as number,\n    serializeMessageSignature(condition.signature),\n  ];\n  return concatArray(bytesArray);\n}\n\nexport function serializeMultiSigSpendingCondition(\n  condition: MultiSigSpendingConditionOpts\n): Uint8Array {\n  const bytesArray = [\n    condition.hashMode,\n    hexToBytes(condition.signer),\n    intToBytes(condition.nonce, false, 8),\n    intToBytes(condition.fee, false, 8),\n  ];\n\n  const fields = createLPList(condition.fields);\n  bytesArray.push(serializeLPList(fields));\n\n  const numSigs = new Uint8Array(2);\n  writeUInt16BE(numSigs, condition.signaturesRequired, 0);\n  bytesArray.push(numSigs);\n\n  return concatArray(bytesArray);\n}\n\nexport function deserializeSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  bytesReader: BytesReader\n): SingleSigSpendingCondition {\n  const signer = bytesToHex(bytesReader.readBytes(20));\n  const nonce = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n  const fee = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n\n  const keyEncoding = bytesReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n  if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {\n    throw new DeserializationError(\n      'Failed to parse singlesig spending condition: incomaptible hash mode and key encoding'\n    );\n  }\n  const signature = deserializeMessageSignature(bytesReader);\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature,\n  };\n}\n\nexport function deserializeMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  bytesReader: BytesReader\n): MultiSigSpendingCondition {\n  const signer = bytesToHex(bytesReader.readBytes(20));\n  const nonce = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));\n  const fee = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));\n\n  const fields = deserializeLPList(bytesReader, StacksMessageType.TransactionAuthField)\n    .values as TransactionAuthField[];\n\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of fields) {\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        numSigs += 1;\n        if (numSigs === 65536)\n          throw new VerificationError(\n            'Failed to parse multisig spending condition: too many signatures'\n          );\n        break;\n    }\n  }\n  const signaturesRequired = bytesReader.readUInt16BE();\n\n  // Partially signed multi-sig tx can be serialized and deserialized without exception (Incorrect number of signatures)\n  // No need to check numSigs !== signaturesRequired to throw Incorrect number of signatures error\n\n  if (\n    haveUncompressed &&\n    (hashMode === AddressHashMode.SerializeP2WSH ||\n      hashMode === AddressHashMode.SerializeP2WSHNonSequential)\n  ) {\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n  }\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired,\n  };\n}\n\nexport function serializeSpendingCondition(condition: SpendingConditionOpts): Uint8Array {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  }\n  return serializeMultiSigSpendingCondition(condition);\n}\n\nexport function deserializeSpendingCondition(bytesReader: BytesReader): SpendingCondition {\n  const hashMode = bytesReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bytesReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bytesReader);\n  }\n}\n\nexport function makeSigHashPreSign(\n  curSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType\n): string {\n  // new hash combines the previous hash and all the new data this signature will add. This\n  // includes:\n  // * the previous hash\n  // * the auth flag\n  // * the tx fee (big-endian 8-byte number)\n  // * nonce (big-endian 8-byte number)\n  const hashLength = 32 + 1 + 8 + 8;\n\n  const sigHash =\n    curSigHash +\n    bytesToHex(new Uint8Array([authType])) +\n    bytesToHex(intToBytes(fee, false, 8)) +\n    bytesToHex(intToBytes(nonce, false, 8));\n\n  if (hexToBytes(sigHash).byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(hexToBytes(sigHash));\n}\n\nfunction makeSigHashPostSign(\n  curSigHash: string,\n  pubKey: StacksPublicKey,\n  signature: MessageSignature\n): string {\n  // new hash combines the previous hash and all the new data this signature will add.  This\n  // includes:\n  // * the public key compression flag\n  // * the signature\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n\n  const pubKeyEncoding = isCompressed(pubKey)\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n\n  const sigHashBytes = hexToBytes(sigHash);\n  if (sigHashBytes.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(sigHashBytes);\n}\n\nexport function nextSignature(\n  curSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType,\n  privateKey: StacksPrivateKey\n): {\n  nextSig: MessageSignature;\n  nextSigHash: string;\n} {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    nextSig: signature,\n    nextSigHash,\n  };\n}\n\nexport function nextVerification(\n  initialSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType,\n  pubKeyEncoding: PubKeyEncoding,\n  signature: MessageSignature\n) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n\n  const publicKey = createStacksPublicKey(\n    publicKeyFromSignatureVrs(sigHashPreSign, signature, pubKeyEncoding)\n  );\n\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    pubKey: publicKey,\n    nextSigHash,\n  };\n}\n\nfunction newInitialSigHash(): SpendingCondition {\n  const spendingCondition = createSingleSigSpendingCondition(\n    AddressHashMode.SerializeP2PKH,\n    '',\n    0,\n    0\n  );\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(\n  condition: SpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    return verifyMultiSig(condition, initialSigHash, authType);\n  }\n}\n\nfunction verifySingleSig(\n  condition: SingleSigSpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const { pubKey, nextSigHash } = nextVerification(\n    initialSigHash,\n    authType,\n    condition.fee,\n    condition.nonce,\n    condition.keyEncoding,\n    condition.signature\n  );\n\n  // address version arg doesn't matter for signer hash generation\n  const addrBytes = addressFromPublicKeys(\n    0 as any, // only used for hash, so version doesn't matter\n    condition.hashMode,\n    1,\n    [pubKey]\n  ).hash160;\n\n  if (addrBytes !== condition.signer)\n    throw new VerificationError(\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\n    );\n\n  return nextSigHash;\n}\n\nfunction verifyMultiSig(\n  condition: MultiSigSpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const publicKeys: StacksPublicKey[] = [];\n\n  let curSigHash = initialSigHash;\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of condition.fields) {\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        publicKeys.push(field.contents);\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        const { pubKey, nextSigHash } = nextVerification(\n          curSigHash,\n          authType,\n          condition.fee,\n          condition.nonce,\n          field.pubKeyEncoding,\n          field.contents\n        );\n\n        if (isSequentialMultiSig(condition.hashMode)) {\n          curSigHash = nextSigHash;\n        }\n\n        publicKeys.push(pubKey);\n\n        numSigs += 1;\n        if (numSigs === 65536) throw new VerificationError('Too many signatures');\n        break;\n    }\n  }\n\n  if (\n    (isSequentialMultiSig(condition.hashMode) && numSigs !== condition.signaturesRequired) ||\n    (isNonSequentialMultiSig(condition.hashMode) && numSigs < condition.signaturesRequired)\n  )\n    throw new VerificationError('Incorrect number of signatures');\n\n  if (\n    haveUncompressed &&\n    (condition.hashMode === AddressHashMode.SerializeP2WSH ||\n      condition.hashMode === AddressHashMode.SerializeP2WSHNonSequential)\n  )\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n\n  const addrBytes = addressFromPublicKeys(\n    0 as any, // only used for hash, so version doesn't matter\n    condition.hashMode,\n    condition.signaturesRequired,\n    publicKeys\n  ).hash160;\n  if (addrBytes !== condition.signer)\n    throw new VerificationError(\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\n    );\n\n  return curSigHash;\n}\n\nexport type Authorization = StandardAuthorization | SponsoredAuthorization;\n\nexport interface StandardAuthorization {\n  authType: AuthType.Standard;\n  spendingCondition: SpendingCondition;\n}\n\nexport interface SponsoredAuthorization {\n  authType: AuthType.Sponsored;\n  spendingCondition: SpendingCondition;\n  sponsorSpendingCondition: SpendingCondition;\n}\n\nexport function createStandardAuth(spendingCondition: SpendingCondition): StandardAuthorization {\n  return {\n    authType: AuthType.Standard,\n    spendingCondition,\n  };\n}\n\nexport function createSponsoredAuth(\n  spendingCondition: SpendingCondition,\n  sponsorSpendingCondition?: SpendingCondition\n): Authorization {\n  return {\n    authType: AuthType.Sponsored,\n    spendingCondition,\n    sponsorSpendingCondition: sponsorSpendingCondition\n      ? sponsorSpendingCondition\n      : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0),\n  };\n}\n\nexport function intoInitialSighashAuth(auth: Authorization): Authorization {\n  if (auth.spendingCondition) {\n    switch (auth.authType) {\n      case AuthType.Standard:\n        return createStandardAuth(clearCondition(auth.spendingCondition));\n      case AuthType.Sponsored:\n        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());\n      default:\n        throw new SigningError('Unexpected authorization type for signing');\n    }\n  }\n\n  throw new Error('Authorization missing SpendingCondition');\n}\n\nexport function verifyOrigin(auth: Authorization, initialSigHash: string): string {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    case AuthType.Sponsored:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard); // todo: should this be .Sponsored?\n    default:\n      throw new SigningError('Invalid origin auth type');\n  }\n}\n\nexport function setFee(auth: Authorization, amount: IntegerType): Authorization {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      const spendingCondition = {\n        ...auth.spendingCondition,\n        fee: intToBigInt(amount, false),\n      };\n      return { ...auth, spendingCondition };\n    case AuthType.Sponsored:\n      const sponsorSpendingCondition = {\n        ...auth.sponsorSpendingCondition,\n        fee: intToBigInt(amount, false),\n      };\n      return { ...auth, sponsorSpendingCondition };\n  }\n}\n\nexport function getFee(auth: Authorization): bigint {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return auth.spendingCondition.fee;\n    case AuthType.Sponsored:\n      return auth.sponsorSpendingCondition.fee;\n  }\n}\n\nexport function setNonce(auth: Authorization, nonce: IntegerType): Authorization {\n  const spendingCondition = {\n    ...auth.spendingCondition,\n    nonce: intToBigInt(nonce, false),\n  };\n\n  return {\n    ...auth,\n    spendingCondition,\n  };\n}\n\nexport function setSponsorNonce(auth: SponsoredAuthorization, nonce: IntegerType): Authorization {\n  const sponsorSpendingCondition = {\n    ...auth.sponsorSpendingCondition,\n    nonce: intToBigInt(nonce, false),\n  };\n\n  return {\n    ...auth,\n    sponsorSpendingCondition,\n  };\n}\n\nexport function setSponsor(\n  auth: SponsoredAuthorization,\n  sponsorSpendingCondition: SpendingConditionOpts\n): Authorization {\n  const sc = {\n    ...sponsorSpendingCondition,\n    nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n    fee: intToBigInt(sponsorSpendingCondition.fee, false),\n  };\n\n  return {\n    ...auth,\n    sponsorSpendingCondition: sc,\n  };\n}\n\nexport function serializeAuthorization(auth: Authorization): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(auth.authType);\n\n  switch (auth.authType) {\n    case AuthType.Standard:\n      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));\n      break;\n    case AuthType.Sponsored:\n      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));\n      bytesArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));\n      break;\n  }\n\n  return concatArray(bytesArray);\n}\n\nexport function deserializeAuthorization(bytesReader: BytesReader) {\n  const authType = bytesReader.readUInt8Enum(AuthType, n => {\n    throw new DeserializationError(`Could not parse ${n} as AuthType`);\n  });\n\n  let spendingCondition;\n  switch (authType) {\n    case AuthType.Standard:\n      spendingCondition = deserializeSpendingCondition(bytesReader);\n      return createStandardAuth(spendingCondition);\n    case AuthType.Sponsored:\n      spendingCondition = deserializeSpendingCondition(bytesReader);\n      const sponsorSpendingCondition = deserializeSpendingCondition(bytesReader);\n      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);\n  }\n}\n", "import { bytesToHex, hexToBytes, IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  StacksNetwork,\n  StacksMainnet,\n  StacksNetworkName,\n  StacksTestnet,\n  FetchFn,\n  createFetchFn,\n} from '@stacks/network';\nimport { c32address } from 'c32check';\nimport {\n  Authorization,\n  createMultiSigSpendingCondition,\n  createSingleSigSpendingCondition,\n  createSponsoredAuth,\n  createStandardAuth,\n  SpendingCondition,\n  MultiSigSpendingCondition,\n  isSingleSig,\n} from './authorization';\nimport { ClarityValue, deserializeCV, NoneCV, PrincipalCV, serializeCV } from './clarity';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  AnchorMode,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  PayloadType,\n  PostConditionMode,\n  SingleSigHashMode,\n  TransactionVersion,\n  TxRejectedReason,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  StacksMessageType,\n  ClarityVersion,\n  AnchorModeName,\n  MultiSigHashMode,\n} from './constants';\nimport { ClarityAbi, validateContractCall } from './contract-abi';\nimport { NoEstimateAvailableError } from './errors';\nimport {\n  createStacksPrivateKey,\n  createStacksPublicKey,\n  getPublicKey,\n  pubKeyfromPrivKey,\n  publicKeyFromBytes,\n  publicKeyToAddress,\n  publicKeyToString,\n} from './keys';\nimport {\n  createContractCallPayload,\n  createSmartContractPayload,\n  createTokenTransferPayload,\n  Payload,\n  serializePayload,\n} from './payload';\nimport {\n  createFungiblePostCondition,\n  createNonFungiblePostCondition,\n  createSTXPostCondition,\n} from './postcondition';\nimport {\n  AssetInfo,\n  createAddress,\n  createContractPrincipal,\n  createStandardPrincipal,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n  PostCondition,\n  STXPostCondition,\n} from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { addressFromPublicKeys, createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\n\n/** @internal */\nasync function _getNonceApi(address: string, network: StacksNetwork): Promise<bigint> {\n  const url = `${network.coreApiUrl}/extended/v1/address/${address}/nonces`;\n  const response = await network.fetchFn(url);\n  const result = await response.json();\n  return BigInt(result.possible_next_nonce);\n}\n\n/**\n * Lookup the nonce for an address from an API or core node\n * @return a promise that resolves to a bigint\n */\nexport async function getNonce(\n  /** The Stacks (c32check) address to look up */\n  address: string,\n  /** The Stacks network to look up the address on */\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getAccountApiUrl(address);\n\n  // Try API first\n  try {\n    return await _getNonceApi(address, derivedNetwork);\n  } catch (e) {}\n\n  // Try node if API endpoint isn't available\n  const response = await derivedNetwork.fetchFn(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const responseText = await response.text();\n  const result = JSON.parse(responseText) as { nonce: string };\n  return BigInt(result.nonce);\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function instead.\n *\n * Estimate the total transaction fee in microstacks for a token transfer\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateTransfer(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(\n      `Transaction fee estimation only possible with ${\n        PayloadType[PayloadType.TokenTransfer]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  return estimateTransferUnsafe(transaction, network);\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function instead.\n * @internal\n */\nexport async function estimateTransferUnsafe(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\n\ninterface FeeEstimation {\n  fee: number;\n  fee_rate: number;\n}\ninterface FeeEstimateResponse {\n  cost_scalar_change_by_byte: bigint;\n  estimated_cost: {\n    read_count: bigint;\n    read_length: bigint;\n    runtime: bigint;\n    write_count: bigint;\n    write_length: bigint;\n  };\n  estimated_cost_scalar: bigint;\n  estimations: [FeeEstimation, FeeEstimation, FeeEstimation];\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a Stacks transaction\n *\n * @param {StacksTransaction} transaction - the transaction to estimate fees for\n * @param {number} estimatedLen - is an optional argument that provides the endpoint with an\n * estimation of the final length (in bytes) of the transaction, including any post-conditions\n * and signatures\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction fees for\n *\n * @return a promise that resolves to FeeEstimate\n */\nexport async function estimateTransaction(\n  transactionPayload: Payload,\n  estimatedLen?: number,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<[FeeEstimation, FeeEstimation, FeeEstimation]> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      transaction_payload: bytesToHex(serializePayload(transactionPayload)),\n      ...(estimatedLen ? { estimated_len: estimatedLen } : {}),\n    }),\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, options);\n\n  if (!response.ok) {\n    const body = await response.text().then(str => {\n      try {\n        return JSON.parse(str);\n      } catch (error) {\n        return str;\n      }\n    });\n\n    if (\n      body?.reason === 'NoEstimateAvailable' ||\n      (typeof body === 'string' && body.includes('NoEstimateAvailable'))\n    ) {\n      throw new NoEstimateAvailableError(body?.reason_data?.message ?? '');\n    }\n\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${body}\"`\n    );\n  }\n\n  const data: FeeEstimateResponse = await response.json();\n  return data.estimations;\n}\n\nexport type SerializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Serialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type DeserializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Deserialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type SignatureValidationRejection = {\n  error: string;\n  reason: TxRejectedReason.SignatureValidation;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type BadNonceRejection = {\n  error: string;\n  reason: TxRejectedReason.BadNonce;\n  reason_data: {\n    expected: number;\n    actual: number;\n    is_origin: boolean;\n    principal: boolean;\n  };\n  txid: string;\n};\n\nexport type FeeTooLowRejection = {\n  error: string;\n  reason: TxRejectedReason.FeeTooLow;\n  reason_data: {\n    expected: number;\n    actual: number;\n  };\n  txid: string;\n};\n\nexport type NotEnoughFundsRejection = {\n  error: string;\n  reason: TxRejectedReason.NotEnoughFunds;\n  reason_data: {\n    expected: string;\n    actual: string;\n  };\n  txid: string;\n};\n\nexport type NoSuchContractRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchContract;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoSuchPublicFunctionRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchPublicFunction;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadFunctionArgumentRejection = {\n  error: string;\n  reason: TxRejectedReason.BadFunctionArgument;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ContractAlreadyExistsRejection = {\n  error: string;\n  reason: TxRejectedReason.ContractAlreadyExists;\n  reason_data: {\n    contract_identifier: string;\n  };\n  txid: string;\n};\n\nexport type PoisonMicroblocksDoNotConflictRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblocksDoNotConflict;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockHasUnknownPubKeyHashRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockHasUnknownPubKeyHash;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockIsInvalidRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockIsInvalid;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadAddressVersionByteRejection = {\n  error: string;\n  reason: TxRejectedReason.BadAddressVersionByte;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoCoinbaseViaMempoolRejection = {\n  error: string;\n  reason: TxRejectedReason.NoCoinbaseViaMempool;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureNoSuchChainTipRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureNoSuchChainTip;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type TooMuchChainingRejection = {\n  error: string;\n  reason: TxRejectedReason.TooMuchChaining;\n  reason_data: {\n    actual: number;\n    expected: number;\n    is_origin: boolean;\n    message: string;\n    principal: string;\n  };\n  txid: string;\n};\n\nexport type ConflictingNonceInMempoolRejection = {\n  error: string;\n  reason: TxRejectedReason.ConflictingNonceInMempool;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadTransactionVersionRejection = {\n  error: string;\n  reason: TxRejectedReason.BadTransactionVersion;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type TransferRecipientCannotEqualSenderRejection = {\n  error: string;\n  reason: TxRejectedReason.TransferRecipientCannotEqualSender;\n  reason_data: {\n    recipient: string;\n  };\n  txid: string;\n};\n\nexport type TransferAmountMustBePositiveRejection = {\n  error: string;\n  reason: TxRejectedReason.TransferAmountMustBePositive;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureDatabaseRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureDatabase;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type EstimatorErrorRejection = {\n  error: string;\n  reason: TxRejectedReason.EstimatorError;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type TemporarilyBlacklistedRejection = {\n  error: string;\n  reason: TxRejectedReason.TemporarilyBlacklisted;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureOtherRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureOther;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type TxBroadcastResultOk = {\n  txid: string;\n  error?: undefined;\n  reason?: undefined;\n  reason_data?: undefined;\n};\n\nexport type TxBroadcastResultRejected =\n  | SerializationRejection\n  | DeserializationRejection\n  | SignatureValidationRejection\n  | BadNonceRejection\n  | FeeTooLowRejection\n  | NotEnoughFundsRejection\n  | NoSuchContractRejection\n  | NoSuchPublicFunctionRejection\n  | BadFunctionArgumentRejection\n  | ContractAlreadyExistsRejection\n  | PoisonMicroblocksDoNotConflictRejection\n  | PoisonMicroblockHasUnknownPubKeyHashRejection\n  | PoisonMicroblockIsInvalidRejection\n  | BadAddressVersionByteRejection\n  | NoCoinbaseViaMempoolRejection\n  | ServerFailureNoSuchChainTipRejection\n  | TooMuchChainingRejection\n  | ConflictingNonceInMempoolRejection\n  | BadTransactionVersionRejection\n  | TransferRecipientCannotEqualSenderRejection\n  | TransferAmountMustBePositiveRejection\n  | ServerFailureDatabaseRejection\n  | EstimatorErrorRejection\n  | TemporarilyBlacklistedRejection\n  | ServerFailureOtherRejection;\n\nexport type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to broadcast\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastTransaction(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork,\n  attachment?: Uint8Array\n): Promise<TxBroadcastResult> {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getBroadcastApiUrl();\n\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\n}\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {Uint8Array} rawTx - the raw serialized transaction bytes to broadcast\n * @param {string} url - the broadcast endpoint URL\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastRawTransaction(\n  rawTx: Uint8Array,\n  url: string,\n  attachment?: Uint8Array,\n  fetchFn: FetchFn = createFetchFn()\n): Promise<TxBroadcastResult> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n    body: attachment\n      ? JSON.stringify({\n          tx: bytesToHex(rawTx),\n          attachment: bytesToHex(attachment),\n        })\n      : rawTx,\n  };\n\n  const response = await fetchFn(url, options);\n  if (!response.ok) {\n    try {\n      return (await response.json()) as TxBroadcastResult;\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${(e as Error).message}`);\n    }\n  }\n\n  const text = await response.text();\n  // Replace extra quotes around txid string\n  const txid = text.replace(/[\"]+/g, '');\n  if (!validateTxId(txid)) throw new Error(text);\n  return { txid } as TxBroadcastResult;\n}\n\n/**\n * Fetch a contract's ABI\n *\n * @param {string} address - the contracts address\n * @param {string} contractName - the contracts name\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds\n */\nexport async function getAbi(\n  address: string,\n  contractName: string,\n  network: StacksNetworkName | StacksNetwork\n): Promise<ClarityAbi> {\n  const options = {\n    method: 'GET',\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\n\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return JSON.parse(await response.text()) as ClarityAbi;\n}\n\nfunction deriveNetwork(transaction: StacksTransaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\n\n/** @deprecated Not used internally */\nexport interface MultiSigOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys?: string[];\n}\n\nexport interface UnsignedMultiSigOptions {\n  /** The minimum required signatures N (in a N of M multi-sig) */\n  numSignatures: number;\n  /** The M public-keys (in a N of M multi-sig), which together form the address of the multi-sig account */\n  publicKeys: string[];\n  /**\n   * The `address` of the multi-sig account.\n   * - If NOT provided, the public-key order is taken AS IS.\n   * - If provided, the address will be checked against the order of the public-keys (either AS IS or SORTED).\n   * The default is to SORT the public-keys (only if the `address` is provided).\n   */\n  address?: string;\n  /** @experimental Use newer non-sequential multi-sig hashmode for transaction. Future releases may make this the default. */\n  useNonSequentialMultiSig?: boolean;\n}\n\nexport type SignedMultiSigOptions = UnsignedMultiSigOptions & {\n  signerKeys: string[];\n};\n\n/**\n * STX token transfer transaction options\n */\nexport interface TokenTransferOptions {\n  /** the address of the recipient of the token transfer */\n  recipient: string | PrincipalCV;\n  /** the amount to be transfered in microstacks */\n  amount: IntegerType;\n  /** the transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** an arbitrary string to include in the transaction, must be less than 34 bytes */\n  memo?: string;\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedTokenTransferOptions extends TokenTransferOptions {\n  publicKey: string;\n}\n\nexport interface SignedTokenTransferOptions extends TokenTransferOptions {\n  senderKey: string;\n}\n\nexport type UnsignedMultiSigTokenTransferOptions = TokenTransferOptions & UnsignedMultiSigOptions;\n\nexport type SignedMultiSigTokenTransferOptions = TokenTransferOptions & SignedMultiSigOptions;\n\n/**\n * Generates an unsigned Stacks token transfer transaction\n *\n * Returns a Stacks token transfer transaction.\n *\n * @param {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedSTXTokenTransfer(\n  txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    memo: '',\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n\n  let authorization: Authorization | null = null;\n  let spendingCondition: SpendingCondition | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    const hashMode = options.useNonSequentialMultiSig\n      ? AddressHashMode.SerializeP2SHNonSequential\n      : AddressHashMode.SerializeP2SH;\n\n    const publicKeys = options.address\n      ? sortPublicKeysForAddress(\n          options.publicKeys,\n          options.numSignatures,\n          hashMode,\n          createAddress(options.address).hash160\n        )\n      : options.publicKeys;\n\n    spendingCondition = createMultiSigSpendingCondition(\n      hashMode,\n      options.numSignatures,\n      publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    undefined, // no post conditions on STX transfers (see SIP-005)\n    undefined, // no post conditions on STX transfers (see SIP-005)\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a signed Stacks token transfer transaction\n *\n * Returns a signed Stacks token transfer transaction.\n *\n * @param {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {StacksTransaction}\n */\nexport async function makeSTXTokenTransfer(\n  txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    // single-sig\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    // multi-sig\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n\n    mutatingSignAppendMultiSig(\n      transaction,\n      txOptions.publicKeys.slice(),\n      txOptions.signerKeys,\n      txOptions.address\n    );\n\n    return transaction;\n  }\n}\n\n/**\n * Contract deploy transaction options\n */\nexport interface BaseContractDeployOptions {\n  clarityVersion?: ClarityVersion;\n  contractName: string;\n  /** the Clarity code to be deployed */\n  codeBody: string;\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractDeployOptions extends BaseContractDeployOptions {\n  /** a hex string of the public key of the transaction sender */\n  publicKey: string;\n}\n\nexport interface SignedContractDeployOptions extends BaseContractDeployOptions {\n  senderKey: string;\n}\n\n/** @deprecated Use {@link SignedContractDeployOptions} or {@link UnsignedContractDeployOptions} instead. */\nexport interface ContractDeployOptions extends SignedContractDeployOptions {}\n\nexport type UnsignedMultiSigContractDeployOptions = BaseContractDeployOptions &\n  UnsignedMultiSigOptions;\n\nexport type SignedMultiSigContractDeployOptions = BaseContractDeployOptions & SignedMultiSigOptions;\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract deploy\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractDeploy(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (\n    transaction.payload.payloadType !== PayloadType.SmartContract &&\n    transaction.payload.payloadType !== PayloadType.VersionedSmartContract\n  ) {\n    throw new Error(\n      `Contract deploy fee estimation only possible with ${\n        PayloadType[PayloadType.SmartContract]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates a Clarity smart contract deploy transaction\n *\n * @param {SignedContractDeployOptions | SignedMultiSigContractDeployOptions} txOptions - an options object for the contract deploy\n *\n * Returns a signed Stacks smart contract deploy transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractDeploy(\n  txOptions: SignedContractDeployOptions | SignedMultiSigContractDeployOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    // single-sig\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractDeploy({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    // multi-sig\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractDeploy(options);\n\n    mutatingSignAppendMultiSig(\n      transaction,\n      txOptions.publicKeys.slice(),\n      txOptions.signerKeys,\n      txOptions.address\n    );\n\n    return transaction;\n  }\n}\n\nexport async function makeUnsignedContractDeploy(\n  txOptions: UnsignedContractDeployOptions | UnsignedMultiSigContractDeployOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n    clarityVersion: ClarityVersion.Clarity2,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createSmartContractPayload(\n    options.contractName,\n    options.codeBody,\n    options.clarityVersion\n  );\n\n  let authorization: Authorization | null = null;\n\n  let spendingCondition: SpendingCondition | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    const hashMode = options.useNonSequentialMultiSig\n      ? AddressHashMode.SerializeP2SHNonSequential\n      : AddressHashMode.SerializeP2SH;\n\n    const publicKeys = options.address\n      ? sortPublicKeysForAddress(\n          options.publicKeys,\n          options.numSignatures,\n          hashMode,\n          createAddress(options.address).hash160\n        )\n      : options.publicKeys;\n\n    spendingCondition = createMultiSigSpendingCondition(\n      hashMode,\n      options.numSignatures,\n      publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Contract function call transaction options\n */\nexport interface ContractCallOptions {\n  /** the Stacks address of the contract */\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  feeEstimateApiUrl?: string;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the Stacks blockchain network that will ultimately be used to broadcast this transaction */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true to validate that the supplied function args match those specified in\n   * the published contract */\n  validateWithAbi?: boolean | ClarityAbi;\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractCallOptions extends ContractCallOptions {\n  publicKey: string;\n}\n\nexport interface SignedContractCallOptions extends ContractCallOptions {\n  senderKey: string;\n}\n\nexport type UnsignedMultiSigContractCallOptions = ContractCallOptions & UnsignedMultiSigOptions;\n\nexport type SignedMultiSigContractCallOptions = ContractCallOptions & SignedMultiSigOptions;\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract function call\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractFunctionCall(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(\n      `Contract call fee estimation only possible with ${\n        PayloadType[PayloadType.ContractCall]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract call fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates an unsigned Clarity smart contract function call transaction\n *\n * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call\n *\n * @returns {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedContractCall(\n  txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createContractCallPayload(\n    options.contractAddress,\n    options.contractName,\n    options.functionName,\n    options.functionArgs\n  );\n\n  if (options?.validateWithAbi) {\n    let abi: ClarityAbi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition: SpendingCondition | null = null;\n  let authorization: Authorization | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    const hashMode = options.useNonSequentialMultiSig\n      ? AddressHashMode.SerializeP2SHNonSequential\n      : AddressHashMode.SerializeP2SH;\n\n    const publicKeys = options.address\n      ? sortPublicKeysForAddress(\n          options.publicKeys,\n          options.numSignatures,\n          hashMode,\n          createAddress(options.address).hash160\n        )\n      : options.publicKeys;\n\n    spendingCondition = createMultiSigSpendingCondition(\n      hashMode,\n      options.numSignatures,\n      publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a Clarity smart contract function call transaction\n *\n * @param {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call\n *\n * Returns a signed Stacks smart contract function call transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractCall(\n  txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    // single-sig\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    // multi-sig\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n\n    mutatingSignAppendMultiSig(\n      transaction,\n      txOptions.publicKeys.slice(),\n      txOptions.signerKeys,\n      txOptions.address\n    );\n\n    return transaction;\n  }\n}\n\n/**\n * Generates a STX post condition with a standard principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens (denoted in micro-STX)\n */\nexport function makeStandardSTXPostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\n\n/**\n * Generates a STX post condition with a contract principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address of the contract\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens (denoted in micro-STX)\n *\n * @return {STXPostCondition}\n */\nexport function makeContractSTXPostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount\n  );\n}\n\n/**\n * Generates a fungible token post condition with a standard principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens (in their respective base unit)\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeStandardFungiblePostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a fungible token post condition with a contract principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens (in their respective base unit)\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeContractFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a standard principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param {String} address - the c32check address\n * @param {FungibleConditionCode} conditionCode - the condition code\n * @param {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param {ClarityValue} assetId - asset identifier of the nft instance (typically a uint/buffer/string)\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeStandardNonFungiblePostCondition(\n  address: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetId: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    assetInfo,\n    assetId\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a contract principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param {String} address - the c32check address\n * @param {String} contractName - the name of the contract\n * @param {FungibleConditionCode} conditionCode - the condition code\n * @param {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param {ClarityValue} assetId - asset identifier of the nft instance (typically a uint/buffer/string)\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeContractNonFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetId: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    assetInfo,\n    assetId\n  );\n}\n\n/**\n * Read only function options\n *\n * @param {String} contractAddress - the c32check address of the contract\n * @param {String} contractName - the contract name\n * @param {String} functionName - name of the function to be called\n * @param {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param {String} senderAddress - the c32check address of the sender\n */\n\nexport interface ReadOnlyFunctionOptions {\n  contractName: string;\n  contractAddress: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** the network that the contract which contains the function is deployed to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** address of the sender */\n  senderAddress: string;\n}\n\n/**\n * Calls a function as read-only from a contract interface\n * It is not necessary that the function is defined as read-only in the contract\n *\n * @param {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object\n *\n * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.\n *\n * @return {ClarityValue}\n */\nexport async function callReadOnlyFunction(\n  readOnlyFunctionOptions: ReadOnlyFunctionOptions\n): Promise<ClarityValue> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n\n  const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n\n  const args = functionArgs.map(arg => cvToHex(arg));\n\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args,\n  });\n\n  const response = await network.fetchFn(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\n\nexport interface GetContractMapEntryOptions {\n  /** the contracts address */\n  contractAddress: string;\n  /** the contracts name */\n  contractName: string;\n  /** the map name */\n  mapName: string;\n  /** key to lookup in the map */\n  mapKey: ClarityValue;\n  /** the network that has the contract */\n  network?: StacksNetworkName | StacksNetwork;\n}\n\n/**\n * Fetch data from a contract data map.\n * @param getContractMapEntryOptions - the options object\n * @returns\n * Promise that resolves to a ClarityValue if the operation succeeds.\n * Resolves to NoneCV if the map does not contain the given key, if the map does not exist, or if the contract prinicipal does not exist\n */\nexport async function getContractMapEntry<T extends ClarityValue = ClarityValue>(\n  getContractMapEntryOptions: GetContractMapEntryOptions\n): Promise<T | NoneCV> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n  const { contractAddress, contractName, mapName, mapKey, network } = Object.assign(\n    defaultOptions,\n    getContractMapEntryOptions\n  );\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);\n\n  const serializedKeyBytes = serializeCV(mapKey);\n  const serializedKeyHex = '0x' + bytesToHex(serializedKeyBytes);\n\n  const fetchOptions: RequestInit = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n    },\n    body: JSON.stringify(serializedKeyHex), // endpoint expects a JSON string atom (quote wrapped string)\n  };\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const responseBody = await response.text();\n  const responseJson: { data?: string } = JSON.parse(responseBody);\n  if (!responseJson.data) {\n    throw new Error(\n      `Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the response: \"${responseBody}\"`\n    );\n  }\n  let deserializedCv: T;\n  try {\n    deserializedCv = deserializeCV<T>(responseJson.data);\n  } catch (error) {\n    throw new Error(`Error deserializing Clarity value \"${responseJson.data}\": ${error}`);\n  }\n  return deserializedCv;\n}\n\n/**\n * Sponsored transaction options\n */\nexport interface SponsorOptionsOpts {\n  /** the origin-signed transaction */\n  transaction: StacksTransaction;\n  /** the sponsor's private key */\n  sponsorPrivateKey: string;\n  /** the transaction fee amount to sponsor */\n  fee?: IntegerType;\n  /** the nonce of the sponsor account */\n  sponsorNonce?: IntegerType;\n  /** the hashmode of the sponsor's address */\n  sponsorAddressHashmode?: AddressHashMode;\n  /** the Stacks blockchain network that this transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n}\n\n/**\n * Constructs and signs a sponsored transaction as the sponsor\n *\n * @param {SponsorOptionsOpts} sponsorOptions - the sponsor options object\n *\n * Returns a signed sponsored transaction.\n *\n * @return {ClarityValue}\n */\nexport async function sponsorTransaction(\n  sponsorOptions: SponsorOptionsOpts\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: 0 as IntegerType,\n    sponsorNonce: 0 as IntegerType,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH as SingleSigHashMode,\n    network:\n      sponsorOptions.transaction.version === TransactionVersion.Mainnet\n        ? new StacksMainnet()\n        : new StacksTestnet(),\n  };\n\n  const options = Object.assign(defaultOptions, sponsorOptions);\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.VersionedSmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]\n            .fee;\n        } catch (e) {\n          throw e;\n        }\n        break;\n      default:\n        throw new Error(\n          `Sponsored transactions not supported for transaction type ${\n            PayloadType[options.transaction.payload.payloadType]\n          }`\n        );\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(\n    options.sponsorAddressHashmode,\n    publicKeyToString(sponsorPubKey),\n    options.sponsorNonce,\n    options.fee\n  );\n\n  options.transaction.setSponsor(sponsorSpendingCondition);\n\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(\n    options.transaction,\n    sponsorSpendingCondition\n  );\n  signer.signSponsor(privKey);\n\n  return signer.transaction;\n}\n\n/**\n * Estimates transaction byte length\n * Context:\n * 1) Multi-sig transaction byte length increases by adding signatures\n *    which causes the incorrect fee estimation because the fee value is set while creating unsigned transaction\n * 2) Single-sig transaction byte length remain same due to empty message signature which allocates the space for signature\n * @param {transaction} - StacksTransaction object to be estimated\n * @return {number} Estimated transaction byte length\n */\nexport function estimateTransactionByteLength(transaction: StacksTransaction): number {\n  const hashMode = transaction.auth.spendingCondition.hashMode;\n  // List of Multi-sig transaction hash modes\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n\n  // Check if its a Multi-sig transaction\n  if (multiSigHashModes.includes(hashMode)) {\n    const multiSigSpendingCondition: MultiSigSpendingCondition = transaction.auth\n      .spendingCondition as MultiSigSpendingCondition;\n\n    // Find number of existing signatures if the transaction is signed or partially signed\n    const existingSignatures = multiSigSpendingCondition.fields.filter(\n      field => field.contents.type === StacksMessageType.MessageSignature\n    ).length; // existingSignatures will be 0 if its a unsigned transaction\n\n    // Estimate total signature bytes size required for this multi-sig transaction\n    // Formula: totalSignatureLength = (signaturesRequired - existingSignatures) * (SIG_LEN_BYTES + 1 byte of type of signature)\n    const totalSignatureLength =\n      (multiSigSpendingCondition.signaturesRequired - existingSignatures) *\n      (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    // Single-sig transaction\n    // Signature space already allocated by empty message signature\n    return transaction.serialize().byteLength;\n  }\n}\n\n/**\n * Estimates the fee using {@link estimateTransfer} as a fallback if\n * {@link estimateTransaction} does not get an estimation due to the\n * {@link NoEstimateAvailableError} error.\n */\nexport async function estimateTransactionFeeWithFallback(\n  transaction: StacksTransaction,\n  network: StacksNetwork\n): Promise<bigint | number> {\n  try {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;\n  } catch (error) {\n    if (error instanceof NoEstimateAvailableError) {\n      return await estimateTransferUnsafe(transaction, network);\n    }\n    throw error;\n  }\n}\n\n/** @internal multi-sig signing re-use */\nfunction mutatingSignAppendMultiSig(\n  /** **Warning:** method mutates `transaction` */\n  transaction: StacksTransaction,\n  publicKeys: string[],\n  signerKeys: string[],\n  address?: string\n) {\n  if (isSingleSig(transaction.auth.spendingCondition)) {\n    throw new Error('Transaction is not a multi-sig transaction');\n  }\n\n  const signer = new TransactionSigner(transaction);\n\n  const pubs = address\n    ? sortPublicKeysForAddress(\n        publicKeys,\n        transaction.auth.spendingCondition.signaturesRequired,\n        transaction.auth.spendingCondition.hashMode,\n        createAddress(address).hash160\n      )\n    : publicKeys;\n\n  // sign in order of public keys\n  for (const publicKey of pubs) {\n    const signerKey = signerKeys.find(key => bytesToHex(pubKeyfromPrivKey(key).data) === publicKey);\n    if (signerKey) {\n      // either sign and append message signature (which allows for recovering the public key)\n      signer.signOrigin(createStacksPrivateKey(signerKey));\n    } else {\n      // or append the public key (which did not sign here)\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(publicKey)));\n    }\n  }\n}\n\n/** @internal Get the matching public-keys array for a multi-sig address */\nfunction sortPublicKeysForAddress(\n  publicKeys: string[],\n  numSigs: number,\n  hashMode: MultiSigHashMode,\n  hash: string\n): string[] {\n  // unsorted\n  const hashUnsorted = addressFromPublicKeys(\n    0 as any, // only used for hash, so version doesn't matter\n    hashMode,\n    numSigs,\n    publicKeys.map(createStacksPublicKey)\n  ).hash160;\n\n  if (hashUnsorted === hash) return publicKeys;\n\n  // sorted\n  const publicKeysSorted = publicKeys.slice().sort();\n  const hashSorted = addressFromPublicKeys(\n    0 as any, // only used for hash, so version doesn't matter\n    hashMode,\n    numSigs,\n    publicKeysSorted.map(createStacksPublicKey)\n  ).hash160;\n\n  if (hashSorted === hash) return publicKeysSorted;\n\n  throw new Error('Failed to find matching multi-sig address given public-keys.');\n}\n", "import { hexToBytes, utf8ToBytes } from '@stacks/common';\nimport {\n  ClarityType,\n  ClarityValue,\n  bufferCV,\n  bufferCVFromString,\n  contractPrincipalCV,\n  falseCV,\n  getCVTypeString,\n  intCV,\n  noneCV,\n  someCV,\n  standardPrincipalCV,\n  trueCV,\n  uintCV,\n} from './clarity';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\nimport { NotImplementedError } from './errors';\nimport { ContractCallPayload } from './payload';\nimport { cloneDeep } from './utils';\n\n// From https://github.com/blockstack/stacks-blockchain-sidecar/blob/master/src/event-stream/contract-abi.ts\n\nexport type ClarityAbiTypeBuffer = { buffer: { length: number } };\nexport type ClarityAbiTypeStringAscii = { 'string-ascii': { length: number } };\nexport type ClarityAbiTypeStringUtf8 = { 'string-utf8': { length: number } };\nexport type ClarityAbiTypeResponse = { response: { ok: ClarityAbiType; error: ClarityAbiType } };\nexport type ClarityAbiTypeOptional = { optional: ClarityAbiType };\nexport type ClarityAbiTypeTuple = { tuple: { name: string; type: ClarityAbiType }[] };\nexport type ClarityAbiTypeList = { list: { type: ClarityAbiType; length: number } };\n\nexport type ClarityAbiTypeUInt128 = 'uint128';\nexport type ClarityAbiTypeInt128 = 'int128';\nexport type ClarityAbiTypeBool = 'bool';\nexport type ClarityAbiTypePrincipal = 'principal';\nexport type ClarityAbiTypeTraitReference = 'trait_reference';\nexport type ClarityAbiTypeNone = 'none';\n\nexport type ClarityAbiTypePrimitive =\n  | ClarityAbiTypeUInt128\n  | ClarityAbiTypeInt128\n  | ClarityAbiTypeBool\n  | ClarityAbiTypePrincipal\n  | ClarityAbiTypeTraitReference\n  | ClarityAbiTypeNone;\n\nexport type ClarityAbiType =\n  | ClarityAbiTypePrimitive\n  | ClarityAbiTypeBuffer\n  | ClarityAbiTypeResponse\n  | ClarityAbiTypeOptional\n  | ClarityAbiTypeTuple\n  | ClarityAbiTypeList\n  | ClarityAbiTypeStringAscii\n  | ClarityAbiTypeStringUtf8\n  | ClarityAbiTypeTraitReference;\n\nexport enum ClarityAbiTypeId {\n  ClarityAbiTypeUInt128 = 1,\n  ClarityAbiTypeInt128 = 2,\n  ClarityAbiTypeBool = 3,\n  ClarityAbiTypePrincipal = 4,\n  ClarityAbiTypeNone = 5,\n  ClarityAbiTypeBuffer = 6,\n  ClarityAbiTypeResponse = 7,\n  ClarityAbiTypeOptional = 8,\n  ClarityAbiTypeTuple = 9,\n  ClarityAbiTypeList = 10,\n  ClarityAbiTypeStringAscii = 11,\n  ClarityAbiTypeStringUtf8 = 12,\n  ClarityAbiTypeTraitReference = 13,\n}\n\nexport const isClarityAbiPrimitive = (val: ClarityAbiType): val is ClarityAbiTypePrimitive =>\n  typeof val === 'string';\nexport const isClarityAbiBuffer = (val: ClarityAbiType): val is ClarityAbiTypeBuffer =>\n  (val as ClarityAbiTypeBuffer).buffer !== undefined;\nexport const isClarityAbiStringAscii = (val: ClarityAbiType): val is ClarityAbiTypeStringAscii =>\n  (val as ClarityAbiTypeStringAscii)['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = (val: ClarityAbiType): val is ClarityAbiTypeStringUtf8 =>\n  (val as ClarityAbiTypeStringUtf8)['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = (val: ClarityAbiType): val is ClarityAbiTypeResponse =>\n  (val as ClarityAbiTypeResponse).response !== undefined;\nexport const isClarityAbiOptional = (val: ClarityAbiType): val is ClarityAbiTypeOptional =>\n  (val as ClarityAbiTypeOptional).optional !== undefined;\nexport const isClarityAbiTuple = (val: ClarityAbiType): val is ClarityAbiTypeTuple =>\n  (val as ClarityAbiTypeTuple).tuple !== undefined;\nexport const isClarityAbiList = (val: ClarityAbiType): val is ClarityAbiTypeList =>\n  (val as ClarityAbiTypeList).list !== undefined;\n\nexport type ClarityAbiTypeUnion =\n  | { id: ClarityAbiTypeId.ClarityAbiTypeUInt128; type: ClarityAbiTypeUInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeInt128; type: ClarityAbiTypeInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBool; type: ClarityAbiTypeBool }\n  | { id: ClarityAbiTypeId.ClarityAbiTypePrincipal; type: ClarityAbiTypePrincipal }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference; type: ClarityAbiTypeTraitReference }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeNone; type: ClarityAbiTypeNone }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBuffer; type: ClarityAbiTypeBuffer }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeResponse; type: ClarityAbiTypeResponse }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeOptional; type: ClarityAbiTypeOptional }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTuple; type: ClarityAbiTypeTuple }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeList; type: ClarityAbiTypeList }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii; type: ClarityAbiTypeStringAscii }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8; type: ClarityAbiTypeStringUtf8 };\n\nexport function getTypeUnion(val: ClarityAbiType): ClarityAbiTypeUnion {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'uint128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };\n    } else if (val === 'int128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };\n    } else if (val === 'bool') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };\n    } else if (val === 'principal') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };\n    } else if (val === 'trait_reference') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };\n    } else if (val === 'none') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };\n    } else {\n      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n    }\n  } else if (isClarityAbiBuffer(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };\n  } else if (isClarityAbiResponse(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };\n  } else if (isClarityAbiOptional(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };\n  } else if (isClarityAbiTuple(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };\n  } else if (isClarityAbiList(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };\n  } else if (isClarityAbiStringAscii(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };\n  } else if (isClarityAbiStringUtf8(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };\n  } else {\n    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n  }\n}\n\n/**\n * Convert a string to a Clarity value based on the ABI type.\n *\n * Currently does NOT support some nested Clarity ABI types:\n * - ClarityAbiTypeResponse\n * - ClarityAbiTypeTuple\n * - ClarityAbiTypeList\n */\nexport function encodeAbiClarityValue(\n  value: string,\n  type: ClarityAbiType | ClarityAbiTypeUnion\n): ClarityValue {\n  const union = (type as ClarityAbiTypeUnion).id\n    ? (type as ClarityAbiTypeUnion)\n    : getTypeUnion(type as ClarityAbiType);\n  switch (union.id) {\n    case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n      return uintCV(value);\n    case ClarityAbiTypeId.ClarityAbiTypeInt128:\n      return intCV(value);\n    case ClarityAbiTypeId.ClarityAbiTypeBool:\n      if (value === 'false' || value === '0') return falseCV();\n      else if (value === 'true' || value === '1') return trueCV();\n      else throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(value)}`);\n    case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n      if (value.includes('.')) {\n        const [addr, name] = value.split('.');\n        return contractPrincipalCV(addr, name);\n      } else {\n        return standardPrincipalCV(value);\n      }\n    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n      const [addr, name] = value.split('.');\n      return contractPrincipalCV(addr, name);\n    case ClarityAbiTypeId.ClarityAbiTypeNone:\n      return noneCV();\n    case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n      return bufferCV(hexToBytes(value));\n    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n      return stringAsciiCV(value);\n    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n      return stringUtf8CV(value);\n    case ClarityAbiTypeId.ClarityAbiTypeOptional:\n      return someCV(encodeAbiClarityValue(value, union.type.optional));\n    case ClarityAbiTypeId.ClarityAbiTypeResponse:\n    case ClarityAbiTypeId.ClarityAbiTypeTuple:\n    case ClarityAbiTypeId.ClarityAbiTypeList:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    default:\n      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n  }\n}\n\n/** @deprecated due to a breaking bug for the buffer encoding case, this was fixed and renamed to {@link clarityAbiStringToCV} */\nexport function encodeClarityValue(type: ClarityAbiType, value: string): ClarityValue;\nexport function encodeClarityValue(type: ClarityAbiTypeUnion, value: string): ClarityValue;\nexport function encodeClarityValue(\n  type: ClarityAbiTypeUnion | ClarityAbiType,\n  value: string\n): ClarityValue {\n  const union = (type as ClarityAbiTypeUnion).id\n    ? (type as ClarityAbiTypeUnion)\n    : getTypeUnion(type as ClarityAbiType);\n\n  if (union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer) {\n    return bufferCV(utf8ToBytes(value)); // legacy behavior\n  }\n\n  return encodeAbiClarityValue(value, union);\n}\n\nexport function getTypeString(val: ClarityAbiType): string {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'int128') {\n      return 'int';\n    } else if (val === 'uint128') {\n      return 'uint';\n    }\n    return val;\n  } else if (isClarityAbiBuffer(val)) {\n    return `(buff ${val.buffer.length})`;\n  } else if (isClarityAbiStringAscii(val)) {\n    return `(string-ascii ${val['string-ascii'].length})`;\n  } else if (isClarityAbiStringUtf8(val)) {\n    return `(string-utf8 ${val['string-utf8'].length})`;\n  } else if (isClarityAbiResponse(val)) {\n    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n  } else if (isClarityAbiOptional(val)) {\n    return `(optional ${getTypeString(val.optional)})`;\n  } else if (isClarityAbiTuple(val)) {\n    return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n  } else if (isClarityAbiList(val)) {\n    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n  } else {\n    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n  }\n}\n\nexport interface ClarityAbiFunction {\n  name: string;\n  access: 'private' | 'public' | 'read_only';\n  args: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  outputs: {\n    type: ClarityAbiType;\n  };\n}\n\nexport function abiFunctionToString(func: ClarityAbiFunction): string {\n  const access = func.access === 'read_only' ? 'read-only' : func.access;\n  return `(define-${access} (${func.name} ${func.args\n    .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)\n    .join(' ')}))`;\n}\n\nexport interface ClarityAbiVariable {\n  name: string;\n  access: 'variable' | 'constant';\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbiMap {\n  name: string;\n  key: ClarityAbiType;\n  value: ClarityAbiType;\n}\n\nexport interface ClarityAbiTypeFungibleToken {\n  name: string;\n}\n\nexport interface ClarityAbiTypeNonFungibleToken {\n  name: string;\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbi {\n  functions: ClarityAbiFunction[];\n  variables: ClarityAbiVariable[];\n  maps: ClarityAbiMap[];\n  fungible_tokens: ClarityAbiTypeFungibleToken[];\n  non_fungible_tokens: ClarityAbiTypeNonFungibleToken[];\n}\n\nfunction matchType(cv: ClarityValue, abiType: ClarityAbiType): boolean {\n  const union = getTypeUnion(abiType);\n\n  switch (cv.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n    case ClarityType.Int:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n    case ClarityType.UInt:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n    case ClarityType.Buffer:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&\n        union.type.buffer.length >= cv.buffer.length\n      );\n    case ClarityType.StringASCII:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&\n        union.type['string-ascii'].length >= cv.data.length\n      );\n    case ClarityType.StringUTF8:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&\n        union.type['string-utf8'].length >= cv.data.length\n      );\n    case ClarityType.OptionalNone:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional\n      );\n    case ClarityType.OptionalSome:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&\n        matchType(cv.value, union.type.optional)\n      );\n    case ClarityType.ResponseErr:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.error)\n      );\n    case ClarityType.ResponseOk:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.ok)\n      );\n    case ClarityType.PrincipalContract:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference\n      );\n    case ClarityType.PrincipalStandard:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n    case ClarityType.List:\n      return (\n        union.id == ClarityAbiTypeId.ClarityAbiTypeList &&\n        union.type.list.length >= cv.list.length &&\n        cv.list.every(val => matchType(val, union.type.list.type))\n      );\n    case ClarityType.Tuple:\n      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n        const tuple = cloneDeep(cv.data);\n        for (let i = 0; i < union.type.tuple.length; i++) {\n          const abiTupleEntry = union.type.tuple[i];\n          const key = abiTupleEntry.name;\n          const val = tuple[key];\n\n          // if key exists in cv tuple, check if its type matches the abi\n          // return false if key doesn't exist\n          if (val) {\n            if (!matchType(val, abiTupleEntry.type)) {\n              return false;\n            }\n            delete tuple[key];\n          } else {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\n/**\n * Validates a contract-call payload with a contract ABI\n *\n * @param {ContractCallPayload} payload - a contract-call payload\n * @param {ClarityAbi} abi - a contract ABI\n *\n * @returns {boolean} true if the payloads functionArgs type check against those in the ABI\n */\nexport function validateContractCall(payload: ContractCallPayload, abi: ClarityAbi): boolean {\n  const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n  if (filtered.length === 1) {\n    const abiFunc = filtered[0];\n    const abiArgs = abiFunc.args;\n\n    if (payload.functionArgs.length !== abiArgs.length) {\n      throw new Error(\n        `Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`\n      );\n    }\n\n    for (let i = 0; i < payload.functionArgs.length; i++) {\n      const payloadArg = payload.functionArgs[i];\n      const abiArg = abiArgs[i];\n\n      if (!matchType(payloadArg, abiArg.type)) {\n        const argNum = i + 1;\n        throw new Error(\n          `Clarity function \\`${\n            payload.functionName.content\n          }\\` expects argument ${argNum} to be of type ${getTypeString(\n            abiArg.type\n          )}, not ${getCVTypeString(payloadArg)}`\n        );\n      }\n    }\n\n    return true;\n  } else if (filtered.length === 0) {\n    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n  } else {\n    throw new Error(\n      `Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`\n    );\n  }\n}\n\n/**\n * Convert string input to Clarity value based on contract ABI data. Only handles Clarity\n * primitives and buffers. Responses, optionals, tuples and lists are not supported.\n *\n * @param {string} input - string to be parsed into Clarity value\n * @param {ClarityAbiType} type - the contract function argument object\n *\n * @returns {ClarityValue} returns a Clarity value\n */\nexport function parseToCV(input: string, type: ClarityAbiType): ClarityValue {\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(input);\n    } else if (type === 'int128') {\n      return intCV(input);\n    } else if (type === 'bool') {\n      if (input.toLowerCase() === 'true') {\n        return trueCV();\n      } else if (input.toLowerCase() === 'false') {\n        return falseCV();\n      } else {\n        throw new Error(`Invalid bool value: ${input}`);\n      }\n    } else if (type === 'principal') {\n      if (input.includes('.')) {\n        const [address, contractName] = input.split('.');\n        return contractPrincipalCV(address, contractName);\n      } else {\n        return standardPrincipalCV(input);\n      }\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    const inputLength = utf8ToBytes(input).byteLength;\n    if (inputLength > type.buffer.length) {\n      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n    }\n    return bufferCVFromString(input);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n", "import { IntegerType, intToBigInt } from '@stacks/common';\nimport { ClarityValue } from './clarity';\nimport {\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  PostConditionType,\n  StacksMessageType,\n} from './constants';\nimport {\n  AssetInfo,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n  PostConditionPrincipal,\n  STXPostCondition,\n  parseAssetInfoString,\n  parsePrincipalString,\n} from './postcondition-types';\n\nexport function createSTXPostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.STX,\n    principal,\n    conditionCode,\n    amount: intToBigInt(amount, false),\n  };\n}\n\nexport function createFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.Fungible,\n    principal,\n    conditionCode,\n    amount: intToBigInt(amount, false),\n    assetInfo,\n  };\n}\n\nexport function createNonFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.NonFungible,\n    principal,\n    conditionCode,\n    assetInfo,\n    assetName,\n  };\n}\n", "import { StacksTransaction } from './transaction';\nimport { StacksPrivateKey, StacksPublicKey } from './keys';\nimport {\n  isNonSequentialMultiSig,\n  isSequentialMultiSig,\n  isSingleSig,\n  nextVerification,\n  SpendingConditionOpts,\n} from './authorization';\nimport { cloneDeep } from './utils';\nimport { AddressHashMode, AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\n\n// todo: get rid of signer and combine with transaction class? could reduce code and complexity by calculating sighash newly each sign and append.\nexport class TransactionSigner {\n  transaction: StacksTransaction;\n  sigHash: string;\n  originDone: boolean;\n  checkOversign: boolean;\n  checkOverlap: boolean;\n\n  constructor(transaction: StacksTransaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n\n    // If multi-sig spending condition exists, iterate over\n    // auth fields and reconstruct sigHash\n    const spendingCondition = transaction.auth.spendingCondition;\n    if (spendingCondition && !isSingleSig(spendingCondition)) {\n      if (\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('SpendingCondition has more signatures than are expected');\n      }\n\n      spendingCondition.fields.forEach(field => {\n        if (field.contents.type !== StacksMessageType.MessageSignature) return;\n\n        const signature = field.contents;\n        const nextVerify = nextVerification(\n          this.sigHash,\n          transaction.auth.authType,\n          spendingCondition.fee,\n          spendingCondition.nonce,\n          PubKeyEncoding.Compressed, // always compressed for multisig\n          signature\n        );\n\n        if (!isNonSequentialMultiSig(spendingCondition.hashMode)) {\n          this.sigHash = nextVerify.nextSigHash;\n        }\n      });\n    }\n  }\n\n  static createSponsorSigner(\n    transaction: StacksTransaction,\n    spendingCondition: SpendingConditionOpts\n  ) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n\n    const tx: StacksTransaction = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n\n  signOrigin(privateKey: StacksPrivateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    const spendingCondition = this.transaction.auth.spendingCondition;\n    if (\n      spendingCondition.hashMode === AddressHashMode.SerializeP2SH ||\n      spendingCondition.hashMode === AddressHashMode.SerializeP2WSH\n    ) {\n      // only check oversign on legacy multisig modes\n      if (\n        this.checkOversign &&\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n\n    if (\n      isSingleSig(this.transaction.auth.spendingCondition) ||\n      isSequentialMultiSig(this.transaction.auth.spendingCondition.hashMode)\n    ) {\n      this.sigHash = nextSighash;\n    }\n  }\n\n  appendOrigin(publicKey: StacksPublicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    this.transaction.appendPubkey(publicKey);\n  }\n\n  signSponsor(privateKey: StacksPrivateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.authType !== AuthType.Sponsored) {\n      throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n    }\n\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n\n  getTxInComplete(): StacksTransaction {\n    return cloneDeep(this.transaction);\n  }\n\n  resume(transaction: StacksTransaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n}\n", "import {\n  bytesToHex,\n  concatArray,\n  hexToBytes,\n  IntegerType,\n  intToBigInt,\n  PRIVATE_KEY_COMPRESSED_LENGTH,\n  writeUInt32BE,\n} from '@stacks/common';\nimport {\n  Authorization,\n  deserializeAuthorization,\n  intoInitialSighashAuth,\n  isSingleSig,\n  nextSignature,\n  serializeAuthorization,\n  setFee,\n  setNonce,\n  setSponsor,\n  setSponsorNonce,\n  SpendingConditionOpts,\n  verifyOrigin,\n} from './authorization';\nimport { BytesReader } from './bytesReader';\nimport {\n  AnchorMode,\n  anchorModeFromNameOrValue,\n  AnchorModeName,\n  AuthType,\n  ChainID,\n  DEFAULT_CHAIN_ID,\n  PayloadType,\n  PostConditionMode,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\nimport { SerializationError, SigningError } from './errors';\nimport { isCompressed, StacksPrivateKey, StacksPublicKey } from './keys';\nimport { deserializePayload, Payload, PayloadInput, serializePayload } from './payload';\nimport { createTransactionAuthField } from './signature';\nimport { createLPList, deserializeLPList, LengthPrefixedList, serializeLPList } from './types';\nimport { cloneDeep, txidFromData } from './utils';\n\nexport class StacksTransaction {\n  version: TransactionVersion;\n  chainId: ChainID;\n  auth: Authorization;\n  anchorMode: AnchorMode;\n  payload: Payload;\n  postConditionMode: PostConditionMode;\n  postConditions: LengthPrefixedList;\n\n  constructor(\n    version: TransactionVersion,\n    auth: Authorization,\n    payload: PayloadInput,\n    postConditions?: LengthPrefixedList,\n    postConditionMode?: PostConditionMode,\n    anchorMode?: AnchorModeName | AnchorMode,\n    chainId?: ChainID\n  ) {\n    this.version = version;\n    this.auth = auth;\n    if ('amount' in payload) {\n      this.payload = {\n        ...payload,\n        amount: intToBigInt(payload.amount, false),\n      };\n    } else {\n      this.payload = payload;\n    }\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\n    this.postConditions = postConditions ?? createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorModeFromNameOrValue(anchorMode);\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.CoinbaseToAltRecipient:\n        case PayloadType.NakamotoCoinbase:\n        case PayloadType.PoisonMicroblock:\n        case PayloadType.TenureChange:\n          this.anchorMode = AnchorMode.OnChainOnly;\n          break;\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.VersionedSmartContract:\n        case PayloadType.TokenTransfer:\n          this.anchorMode = AnchorMode.Any;\n          break;\n      }\n    }\n  }\n\n  /** @deprecated Does NOT mutate transaction, but rather returns the hash of the transaction with a cleared initial authorization */\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  /** @deprecated Alias of `.signBegin()` */\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyOrigin(): string {\n    return verifyOrigin(this.auth, this.verifyBegin());\n  }\n\n  signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n\n  signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.authType === AuthType.Sponsored) {\n      return this.signAndAppend(\n        this.auth.sponsorSpendingCondition,\n        sigHash,\n        AuthType.Sponsored,\n        privateKey\n      );\n    } else {\n      throw new Error('\"auth.sponsorSpendingCondition\" is undefined');\n    }\n  }\n\n  appendPubkey(publicKey: StacksPublicKey) {\n    const cond = this.auth.spendingCondition;\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          publicKey\n        )\n      );\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n\n  // todo: this could be static?\n  /** **Warning**: method mutates the `condition` param */\n  signAndAppend(\n    /** `condition` is mutated by this method */\n    condition: SpendingConditionOpts,\n    curSigHash: string,\n    authType: AuthType,\n    privateKey: StacksPrivateKey\n  ): string {\n    const { nextSig, nextSigHash } = nextSignature(\n      curSigHash,\n      authType,\n      condition.fee,\n      condition.nonce,\n      privateKey\n    );\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      condition.fields.push(\n        createTransactionAuthField(\n          privateKey.data.byteLength === PRIVATE_KEY_COMPRESSED_LENGTH\n            ? PubKeyEncoding.Compressed\n            : PubKeyEncoding.Uncompressed,\n          nextSig\n        )\n      );\n    }\n\n    return nextSigHash;\n  }\n\n  txid(): string {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingConditionOpts) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsor(this.auth, sponsorSpendingCondition);\n  }\n\n  /**\n   * Set the total fee to be paid for this transaction\n   *\n   * @param fee - the fee amount in microstacks\n   */\n  setFee(amount: IntegerType) {\n    this.auth = setFee(this.auth, amount);\n  }\n\n  /**\n   * Set the transaction nonce\n   *\n   * @param nonce - the nonce value\n   */\n  setNonce(nonce: IntegerType) {\n    this.auth = setNonce(this.auth, nonce);\n  }\n\n  /**\n   * Set the transaction sponsor nonce\n   *\n   * @param nonce - the sponsor nonce value\n   */\n  setSponsorNonce(nonce: IntegerType) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsorNonce(this.auth, nonce);\n  }\n\n  serialize(): Uint8Array {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n\n    const bytesArray = [];\n\n    bytesArray.push(this.version);\n    const chainIdBytes = new Uint8Array(4);\n    writeUInt32BE(chainIdBytes, this.chainId, 0);\n    bytesArray.push(chainIdBytes);\n    bytesArray.push(serializeAuthorization(this.auth));\n    bytesArray.push(this.anchorMode);\n    bytesArray.push(this.postConditionMode);\n    bytesArray.push(serializeLPList(this.postConditions));\n    bytesArray.push(serializePayload(this.payload));\n\n    return concatArray(bytesArray);\n  }\n}\n\n/**\n * @param tx hex string or bytes of serialized transaction\n */\nexport function deserializeTransaction(tx: string | Uint8Array | BytesReader) {\n  let bytesReader: BytesReader; // todo: add readerFrom method\n  if (typeof tx === 'string') {\n    if (tx.slice(0, 2).toLowerCase() === '0x') {\n      bytesReader = new BytesReader(hexToBytes(tx.slice(2)));\n    } else {\n      bytesReader = new BytesReader(hexToBytes(tx));\n    }\n  } else if (tx instanceof Uint8Array) {\n    bytesReader = new BytesReader(tx);\n  } else {\n    bytesReader = tx;\n  }\n  const version = bytesReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bytesReader.readUInt32BE();\n  const auth = deserializeAuthorization(bytesReader);\n  const anchorMode = bytesReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bytesReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bytesReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bytesReader);\n\n  return new StacksTransaction(\n    version,\n    auth,\n    payload,\n    postConditions,\n    postConditionMode,\n    anchorMode,\n    chainId\n  );\n}\n\n/**\n * Alias for `transaction.serialize()`\n *\n * Serializes a transaction to bytes.\n *\n * @example\n * ```ts\n * import { makeSTXTokenTransfer, serializeTransaction } from '@stacks/transactions';\n *\n * const transaction = makeSTXTokenTransfer({ ... });\n * const bytes = serializeTransaction(transaction);\n * ```\n */\nexport function serializeTransaction(transaction: StacksTransaction): Uint8Array {\n  // todo: refactor to hex instead of bytes for `next` release\n  return transaction.serialize();\n}\n\n/**\n * Serializes a transaction to a hex string.\n *\n * @example\n * ```ts\n * import { makeSTXTokenTransfer, transactionToHex } from '@stacks/transactions';\n *\n * const transaction = makeSTXTokenTransfer({ ... });\n * const hex = transactionToHex(transaction);\n * ```\n */\nexport function transactionToHex(transaction: StacksTransaction): string {\n  return bytesToHex(transaction.serialize());\n}\n", "import { asciiToBytes, hexToBytes, utf8ToBytes } from '@stacks/common';\nimport {\n  boolCV,\n  bufferCV,\n  contractPrincipalCV,\n  deserializeCV,\n  intCV,\n  listCV,\n  noneCV,\n  responseErrorCV,\n  responseOkCV,\n  serializeCV,\n  someCV,\n  standardPrincipalCV,\n  stringAsciiCV,\n  stringUtf8CV,\n  tupleCV,\n  uintCV,\n} from './clarity';\n\nexport { prettyPrint, stringify } from './clarity/prettyPrint';\nexport { parse } from './clarity/parser';\n\n// todo: https://github.com/hirosystems/clarinet/issues/786\n\n// Primitives //////////////////////////////////////////////////////////////////\n/**\n * `Cl.bool` — Creates a Clarity boolean type, represented as a JS object\n *\n * Alias for {@link boolCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.bool(true);\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const bool = boolCV;\n/**\n * `Cl.int` — Creates a Clarity `int` type, represented as a JS object\n *\n * Alias for {@link intCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.int(-100);\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const int = intCV;\n/**\n * `Cl.uInt` — Creates a Clarity `uint` type, represented as a JS object\n *\n * Alias for {@link uintCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.uint(100);\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const uint = uintCV;\n\n/**\n * `Cl.principal` — Creates a Clarity principal type, represented as a JS object\n * @param address - A Stacks address (optionally with a contract name in the string)\n *\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.principal('ST000000000000000000002AMW42H');\n * Cl.principal('ST000000000000000000002AMW42H.asset');\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport function principal(address: string) {\n  const [addr, name] = address.split('.');\n  return name ? contractPrincipalCV(addr, name) : standardPrincipalCV(addr);\n}\n/**\n * `Cl.address` — Creates a Clarity principal type, represented as a JS object\n * @param address - A Stacks address (optionally with a contract name in the string)\n *\n * Alias for {@link principal | `Cl.principal`}\n *\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.address('ST000000000000000000002AMW42H');\n * Cl.address('ST000000000000000000002AMW42H.asset');\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const address = principal;\n/**\n * `Cl.contractPrincipal` — Creates a Clarity contract `principal` type, represented as a JS object\n *\n * Alias for {@link contractPrincipalCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.contractPrincipal('ST000000000000000000002AMW42H', 'asset');\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const contractPrincipal = contractPrincipalCV;\n/**\n * `Cl.standardPrincipal` — Creates a Clarity standard `principal` type, represented as a JS object\n *\n * Alias for {@link standardPrincipalCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.standardPrincipal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6');\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const standardPrincipal = standardPrincipalCV;\n// todo: add .principal method that detects `.` inside string for both standard and contract principals\n\n// Sequences ///////////////////////////////////////////////////////////////////\n/**\n * `Cl.list` — Creates a Clarity `list` type, represented as a JS object\n *\n * Alias for {@link listCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.list([Cl.int(100), Cl.int(200)]);\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const list = listCV;\n/**\n * `Cl.stringAscii` — Creates a Clarity `string-ascii` type, represented as a JS object\n *\n * Alias for {@link stringAsciiCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.stringAscii('hello world');\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const stringAscii = stringAsciiCV;\n/**\n * `Cl.stringUtf8` — Creates a Clarity `string-utf8` type, represented as a JS object\n *\n * Alias for {@link stringUtf8CV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.stringUtf8('hello world');\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const stringUtf8 = stringUtf8CV;\n/**\n * `Cl.buffer` — Creates a Clarity `buffer` type, represented as a JS object\n *\n * Alias for {@link bufferCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.buffer(Uint8Array.from([0x01, 0x02, 0x03]));\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const buffer = bufferCV;\n/**\n * `Cl.bufferFromHex` — Converts bytes (from a hex string) to a Clarity `buffer` type, represented as a JS object\n * @param hex bytes encoded as a hex string\n * @returns input encoded as a {@link BufferCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.bufferFromHex('a1b2c3');\n * ```\n */\nexport const bufferFromHex = (hex: string) => bufferCV(hexToBytes(hex));\n/**\n * `Cl.bufferFromAscii` — Converts bytes (from an ASCII string) to a Clarity `buffer` type, represented as a JS object\n * @param hex bytes encoded as an ASCII string\n * @returns input encoded as a {@link BufferCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.bufferFromAscii('hello world');\n * ```\n */\nexport const bufferFromAscii = (ascii: string) => bufferCV(asciiToBytes(ascii));\n/**\n * `Cl.bufferFromUtf8` — Converts bytes (from an UTF-8 string) to a Clarity `buffer` type, represented as a JS object\n * @param hex bytes encoded as a UTF-8 string\n * @returns input encoded as a {@link BufferCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.bufferFromUtf8('hello world');\n * ```\n */\nexport const bufferFromUtf8 = (utf8: string) => bufferCV(utf8ToBytes(utf8));\n\n// Composites //////////////////////////////////////////////////////////////////\n/**\n * `Cl.none` — Creates a Clarity optional `none` type, represented as a JS object\n *\n * Alias for {@link noneCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.none();\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const none = noneCV;\n/**\n * `Cl.some` — Creates a Clarity optional `some` type, represented as a JS object\n *\n * Alias for {@link someCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.some(Cl.uint(100));\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const some = someCV;\n/**\n * `Cl.ok` — Creates a Clarity response `ok` type, represented as a JS object\n *\n * Alias for {@link responseOkCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.ok(Cl.uint(100));\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const ok = responseOkCV;\n/**\n * `Cl.error` — Creates a Clarity response `error` type, represented as a JS object\n *\n * Alias for {@link responseErrorCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.error(Cl.uint(9900));\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const error = responseErrorCV;\n/**\n * `Cl.tuple` — Creates a Clarity `tuple` type, represented as a JS object\n *\n * Alias for {@link tupleCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.tuple({\n *   a: Cl.uint(100),\n *   b: Cl.stringUtf8('hello world'),\n * })\n * ```\n * @see {@link serialize}, {@link deserialize}\n */\nexport const tuple = tupleCV;\n\n// Methods /////////////////////////////////////////////////////////////////////\n/**\n * `Cl.serialize` — Serializes a Clarity JS object to the equivalent hex-encoded representation\n *\n * Alias for {@link serializeCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.serialize(Cl.uint(100));\n * ```\n * @see {@link deserialize}\n */\nexport const serialize = serializeCV;\n/**\n * `Cl.deserialize` — Deserializes a hex string to the equivalent Clarity JS object\n *\n * Alias for {@link deserializeCV}\n * @example\n * ```\n * import { Cl } from '@stacks/transactions';\n * Cl.deserialize(\"0c00000001016103\");\n * ```\n * @see {@link serialize}\n */\nexport const deserialize = deserializeCV;\n\n// todo: add `deserializeReadable` methods that translates enums into name strings\n", "/*\n  Format Clarity Values into Clarity style readable strings\n  eg:\n  `Cl.uint(1)` => u1\n  `Cl.list(Cl.uint(1))` => (list u1)\n  `Cl.tuple({ id: u1 })` => { id: u1 }\n*/\n\nimport { bytesToHex } from '@stacks/common';\nimport { ClarityType, ClarityValue, ListCV, TupleCV, principalToString } from '.';\n\nfunction formatSpace(space: number, depth: number, end = false) {\n  if (!space) return ' ';\n  return `\\n${' '.repeat(space * (depth - (end ? 1 : 0)))}`;\n}\n\n/**\n * @description format List clarity values in clarity style strings\n * with the ability to prettify the result with line break end space indentation\n * @example\n * ```ts\n * formatList(Cl.list([Cl.uint(1)]))\n * // (list u1)\n *\n * formatList(Cl.list([Cl.uint(1)]), 2)\n * // (list\n * //   u1\n * // )\n * ```\n */\nfunction formatList(cv: ListCV, space: number, depth = 1): string {\n  if (cv.list.length === 0) return '(list)';\n\n  const spaceBefore = formatSpace(space, depth, false);\n  const endSpace = space ? formatSpace(space, depth, true) : '';\n\n  const items = cv.list.map(v => prettyPrintWithDepth(v, space, depth)).join(spaceBefore);\n\n  return `(list${spaceBefore}${items}${endSpace})`;\n}\n\n/**\n * @description format Tuple clarity values in clarity style strings\n * the keys are alphabetically sorted\n * with the ability to prettify the result with line break end space indentation\n * @example\n * ```ts\n * formatTuple(Cl.tuple({ id: Cl.uint(1), age: Cl.uint(20) }))\n * // { age: 20, id: u1 }\n *\n * formatTuple(Cl.tuple({ id: Cl.uint(1), age: Cl.uint(20) }, 2))\n * // {\n * //   age: 20,\n * //   id: u1\n * // }\n * ```\n */\nfunction formatTuple(cv: TupleCV, space: number, depth = 1): string {\n  if (Object.keys(cv.data).length === 0) return '{}';\n\n  const items: string[] = [];\n  for (const [key, value] of Object.entries(cv.data)) {\n    items.push(`${key}: ${prettyPrintWithDepth(value, space, depth)}`);\n  }\n\n  const spaceBefore = formatSpace(space, depth, false);\n  const endSpace = formatSpace(space, depth, true);\n\n  return `{${spaceBefore}${items.sort().join(`,${spaceBefore}`)}${endSpace}}`;\n}\n\nfunction exhaustiveCheck(param: never): never {\n  throw new Error(`invalid clarity value type: ${param}`);\n}\n\n// the exported function should not expose the `depth` argument\nfunction prettyPrintWithDepth(cv: ClarityValue, space = 0, depth: number): string {\n  if (cv.type === ClarityType.BoolFalse) return 'false';\n  if (cv.type === ClarityType.BoolTrue) return 'true';\n\n  if (cv.type === ClarityType.Int) return cv.value.toString();\n  if (cv.type === ClarityType.UInt) return `u${cv.value.toString()}`;\n\n  if (cv.type === ClarityType.StringASCII) return `\"${cv.data}\"`;\n  if (cv.type === ClarityType.StringUTF8) return `u\"${cv.data}\"`;\n\n  if (cv.type === ClarityType.PrincipalContract) return `'${principalToString(cv)}`;\n  if (cv.type === ClarityType.PrincipalStandard) return `'${principalToString(cv)}`;\n\n  if (cv.type === ClarityType.Buffer) return `0x${bytesToHex(cv.buffer)}`;\n\n  if (cv.type === ClarityType.OptionalNone) return 'none';\n  if (cv.type === ClarityType.OptionalSome)\n    return `(some ${prettyPrintWithDepth(cv.value, space, depth)})`;\n\n  if (cv.type === ClarityType.ResponseOk)\n    return `(ok ${prettyPrintWithDepth(cv.value, space, depth)})`;\n  if (cv.type === ClarityType.ResponseErr)\n    return `(err ${prettyPrintWithDepth(cv.value, space, depth)})`;\n\n  if (cv.type === ClarityType.List) {\n    return formatList(cv, space, depth + 1);\n  }\n  if (cv.type === ClarityType.Tuple) {\n    return formatTuple(cv, space, depth + 1);\n  }\n\n  // make sure that we exhausted all ClarityTypes\n  exhaustiveCheck(cv);\n}\n\n/**\n * Format clarity values in clarity style strings with the ability to prettify\n * the result with line break end space indentation.\n * @param cv The Clarity Value to format\n * @param space The indentation size of the output string. There's no indentation and no line breaks if space = 0\n * @example\n * ```ts\n * prettyPrint(Cl.tuple({ id: Cl.uint(1), age: Cl.some(Cl.uint(42)) }))\n * // { age: (some u42), id: u1 }\n *\n * prettyPrint(Cl.tuple({ id: Cl.uint(1), age: Cl.some(Cl.uint(42)) }, 2))\n * // {\n * //   age: (some u42),\n * //   id: u1\n * // }\n * ```\n */\nexport function stringify(cv: ClarityValue, space = 0): string {\n  return prettyPrintWithDepth(cv, space, 0);\n}\n\n/** @deprecated alias for {@link Cl.stringify} */\nexport const prettyPrint = stringify;\n", "import { Cl, ClarityValue, TupleCV } from '..';\n\n// COMBINATOR TYPES\ntype Combinator = (str: string) => ParseResult;\n\ntype ParseResult = ParseSuccess | ParseFail;\n\ntype Capture = ClarityValue | string;\n\ninterface ParseSuccess {\n  success: true;\n  value: string;\n  rest: string;\n  capture?: Capture;\n}\n\ninterface ParseFail {\n  success: false;\n}\n\n// GENERAL COMBINATORS\nfunction regex(pattern: RegExp, map?: (value: string) => ClarityValue): Combinator {\n  return (s: string) => {\n    const match = s.match(pattern);\n    if (!match || match.index !== 0) return { success: false };\n    return {\n      success: true,\n      value: match[0],\n      rest: s.substring(match[0].length),\n      capture: map ? map(match[0]) : undefined,\n    };\n  };\n}\n\nfunction whitespace(): Combinator {\n  return regex(/\\s+/);\n}\n\nfunction lazy(c: () => Combinator): Combinator {\n  return (s: string) => c()(s);\n}\n\nfunction either(combinators: Combinator[]): Combinator {\n  return (s: string) => {\n    for (const c of combinators) {\n      const result = c(s);\n      if (result.success) return result;\n    }\n    return { success: false };\n  };\n}\n\nfunction entire(combinator: Combinator): Combinator {\n  return (s: string) => {\n    const result = combinator(s);\n    if (!result.success || result.rest) return { success: false };\n    return result;\n  };\n}\n\nfunction optional(c: Combinator): Combinator {\n  return (s: string) => {\n    const result = c(s);\n    if (result.success) return result;\n    return {\n      success: true,\n      value: '',\n      rest: s,\n    };\n  };\n}\n\nfunction sequence(\n  combinators: Combinator[],\n  reduce: (values: Capture[]) => Capture = v => v[0]\n): Combinator {\n  return (s: string) => {\n    let rest = s;\n    let value = '';\n    const captures: Capture[] = [];\n\n    for (const c of combinators) {\n      const result = c(rest);\n      if (!result.success) return { success: false };\n\n      rest = result.rest;\n      value += result.value;\n      if (result.capture) captures.push(result.capture);\n    }\n\n    return {\n      success: true,\n      value,\n      rest,\n      capture: reduce(captures),\n    };\n  };\n}\n\nfunction chain(\n  combinators: Combinator[],\n  reduce: (values: Capture[]) => Capture = v => v[0]\n): Combinator {\n  const joined = combinators.flatMap((combinator, index) =>\n    index === 0 ? [combinator] : [optional(whitespace()), combinator]\n  );\n  return sequence(joined, reduce);\n}\n\nfunction parens(combinator: Combinator): Combinator {\n  return chain([regex(/\\(/), combinator, regex(/\\)/)]);\n}\n\nfunction greedy(\n  min: number,\n  combinator: Combinator,\n  reduce: (values: Capture[]) => Capture = v => v[v.length - 1],\n  separator?: Combinator\n): Combinator {\n  return (s: string) => {\n    let rest = s;\n    let value = '';\n    const captures: Capture[] = [];\n\n    let count;\n    for (count = 0; ; count++) {\n      const result = combinator(rest);\n      if (!result.success) break;\n      rest = result.rest;\n      value += result.value;\n      if (result.capture) captures.push(result.capture);\n\n      if (separator) {\n        const sepResult = separator(rest);\n        if (!sepResult.success) {\n          count++; // count as matched but no trailing separator\n          break;\n        }\n        rest = sepResult.rest;\n        value += sepResult.value;\n      }\n    }\n\n    if (count < min) return { success: false };\n    return {\n      success: true,\n      value,\n      rest,\n      capture: reduce(captures),\n    };\n  };\n}\n\nfunction capture(combinator: Combinator, map?: (value: string) => Capture): Combinator {\n  return (s: string) => {\n    const result = combinator(s);\n    if (!result.success) return { success: false };\n    return {\n      success: true,\n      value: result.value,\n      rest: result.rest,\n      capture: map ? map(result.value) : result.value,\n    };\n  };\n}\n\n// CLARITY VALUE PARSERS\nfunction clInt(): Combinator {\n  return capture(regex(/\\-?[0-9]+/), v => Cl.int(parseInt(v)));\n}\n\nfunction clUint(): Combinator {\n  return sequence([regex(/u/), capture(regex(/[0-9]+/), v => Cl.uint(parseInt(v)))]);\n}\n\nfunction clBool(): Combinator {\n  return capture(regex(/true|false/), v => Cl.bool(v === 'true'));\n}\n\nfunction clPrincipal(): Combinator {\n  return sequence([\n    regex(/\\'/),\n    capture(\n      sequence([regex(/[A-Z0-9]+/), optional(sequence([regex(/\\./), regex(/[a-zA-Z0-9\\-]+/)]))]),\n      Cl.address\n    ),\n  ]);\n}\n\nfunction clBuffer(): Combinator {\n  return sequence([regex(/0x/), capture(regex(/[0-9a-fA-F]+/), Cl.bufferFromHex)]);\n}\n\n/** @ignore helper for string values, removes escaping and unescapes special characters */\nfunction unescape(input: string): string {\n  return input.replace(/\\\\\\\\/g, '\\\\').replace(/\\\\(.)/g, '$1');\n}\n\nfunction clAscii(): Combinator {\n  return sequence([\n    regex(/\"/),\n    capture(regex(/(\\\\.|[^\"])*/), t => Cl.stringAscii(unescape(t))),\n    regex(/\"/),\n  ]);\n}\n\nfunction clUtf8(): Combinator {\n  return sequence([\n    regex(/u\"/),\n    capture(regex(/(\\\\.|[^\"])*/), t => Cl.stringUtf8(unescape(t))),\n    regex(/\"/),\n  ]);\n}\n\nfunction clList(): Combinator {\n  return parens(\n    sequence([\n      regex(/list/),\n      greedy(0, sequence([whitespace(), clValue()]), c => Cl.list(c as ClarityValue[])),\n    ])\n  );\n}\n\nfunction clTuple(): Combinator {\n  const tupleCurly = chain([\n    regex(/\\{/),\n    greedy(\n      1,\n      // entries\n      sequence(\n        [\n          capture(regex(/[a-zA-Z][a-zA-Z0-9_]*/)), // key\n          regex(/\\s*\\:/),\n          whitespace(), // todo: can this be optional?\n          clValue(), // value\n        ],\n        ([k, v]) => Cl.tuple({ [k as string]: v as ClarityValue })\n      ),\n      c => Cl.tuple(Object.assign({}, ...c.map(t => (t as TupleCV).data))),\n      regex(/\\s*\\,\\s*/)\n    ),\n    regex(/\\}/),\n  ]);\n  const tupleFunction = parens(\n    sequence([\n      optional(whitespace()),\n      regex(/tuple/),\n      whitespace(),\n      greedy(\n        1,\n        parens(\n          // entries\n          sequence(\n            [\n              optional(whitespace()),\n              capture(regex(/[a-zA-Z][a-zA-Z0-9_]*/)), // key\n              whitespace(),\n              clValue(), // value\n              optional(whitespace()),\n            ],\n            ([k, v]) => Cl.tuple({ [k as string]: v as ClarityValue })\n          )\n        ),\n        c => Cl.tuple(Object.assign({}, ...c.map(t => (t as TupleCV).data))),\n        whitespace()\n      ),\n    ])\n  );\n  return either([tupleCurly, tupleFunction]);\n}\n\nfunction clNone(): Combinator {\n  return capture(regex(/none/), Cl.none);\n}\n\nfunction clSome(): Combinator {\n  return parens(\n    sequence([regex(/some/), whitespace(), clValue()], c => Cl.some(c[0] as ClarityValue))\n  );\n}\n\nfunction clOk(): Combinator {\n  return parens(sequence([regex(/ok/), whitespace(), clValue()], c => Cl.ok(c[0] as ClarityValue)));\n}\n\nfunction clErr(): Combinator {\n  return parens(\n    sequence([regex(/err/), whitespace(), clValue()], c => Cl.error(c[0] as ClarityValue))\n  );\n}\n\nfunction clValue(map: (combinator: Combinator) => Combinator = v => v) {\n  return either(\n    [\n      clBuffer,\n      clAscii,\n      clUtf8,\n      clInt,\n      clUint,\n      clBool,\n      clPrincipal,\n      clList,\n      clTuple,\n      clNone,\n      clSome,\n      clOk,\n      clErr,\n    ]\n      .map(lazy)\n      .map(map)\n  );\n}\n\n/**\n * Parse a piece of string text as Clarity value syntax.\n * Supports all Clarity value types (primitives, sequences, composite types).\n *\n * @example\n * ```\n * const repr = Cl.parse(\"u4\");\n * const repr = Cl.parse(`\"hello\"`);\n * const repr = Cl.parse('(tuple (a 1) (b 2))');\n * ```\n */\nexport function parse(clarityValueString: string): ClarityValue {\n  const result = clValue(entire)(clarityValueString);\n  if (!result.success || !result.capture) throw 'Parse error'; // todo: we can add better error messages and add position tracking\n  return result.capture as ClarityValue;\n}\n", "import { IntegerType } from '@stacks/common';\nimport {\n  makeContractFungiblePostCondition,\n  makeContractNonFungiblePostCondition,\n  makeContractSTXPostCondition,\n  makeStandardFungiblePostCondition,\n  makeStandardNonFungiblePostCondition,\n  makeStandardSTXPostCondition,\n} from './builders';\nimport { ClarityValue } from './clarity';\nimport { FungibleConditionCode, NonFungibleConditionCode } from './constants';\nimport { createAssetInfo, NonFungiblePostCondition } from './postcondition-types';\n\n/// `Pc.` Post Condition Builder\n//\n// This is a behavioral helper interface for constructing post conditions.\n//\n// The general pattern is:\n//   PRINCIPAL -> [AMOUNT] -> CODE -> ASSET\n//\n\n/**\n * An address string encoded as c32check\n */\ntype AddressString = string;\n\n/**\n * A contract identifier string given as `<address>.<contract-name>`\n */\ntype ContractIdString = `${string}.${string}`;\n\n/**\n * An asset identifier string given as `<contract-id>::<token-name>` aka `<contract-address>.<contract-name>::<token-name>`\n */\ntype NftString = `${ContractIdString}::${string}`;\n\n/**\n * ### `Pc.` Post Condition Builder\n * @beta Interface may be subject to change in future releases.\n * @param {AddressString | ContractIdString} principal The principal to check, which should/should-not be sending assets. A string in the format \"address\" or \"address.contractId\".\n * @returns A partial post condition builder, which can be chained into a final post condition.\n * @example\n * ```\n * import { Pc } from '@stacks/transactions';\n * Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6').willSendEq(10000).ustx();\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function principal(principal: AddressString | ContractIdString) {\n  if (isContractIdString(principal)) {\n    // `principal` is a ContractIdString here\n    const [address, name] = parseContractId(principal);\n    return new PartialPcWithPrincipal(address, name);\n  }\n\n  return new PartialPcWithPrincipal(principal, undefined);\n}\n\n/**\n * Not meant to be used directly. Start from `Pc.principal(…)` instead.\n */\nclass PartialPcWithPrincipal {\n  constructor(\n    private address: string,\n    private contractName?: string\n  ) {}\n\n  // todo: split FT and STX into separate methods? e.g. `willSendSTXEq` and `willSendFtEq`\n\n  /**\n   * ### Fungible Token Post Condition\n   * A post-condition sending tokens `FungibleConditionCode.Equal` (equal to) the given amount of uSTX or fungible-tokens.\n   * Finalize with the chained `.ustx()` or `.ft(…)` method.\n   * @example\n   * ```\n   * import { Pc } from '@stacks/transactions';\n   * Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6').willSendEq(100).stx();\n   * ```\n   */\n  willSendEq(amount: IntegerType) {\n    return new PartialPcFtWithCode(\n      this.address,\n      amount,\n      FungibleConditionCode.Equal,\n      this.contractName\n    );\n  }\n\n  /**\n   * ### Fungible Token Post Condition\n   * A post-condition sending tokens `FungibleConditionCode.LessEqual` (less-than or equal to) the given amount of uSTX or fungible-tokens.\n   * Finalize with the chained `.ustx()` or `.ft(…)` method.\n   * @example\n   * ```\n   * import { Pc } from '@stacks/transactions';\n   * Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6').willSendLte(100).stx();\n   * ```\n   */\n  willSendLte(amount: IntegerType) {\n    return new PartialPcFtWithCode(\n      this.address,\n      amount,\n      FungibleConditionCode.LessEqual,\n      this.contractName\n    );\n  }\n\n  /**\n   * ### Fungible Token Post Condition\n   * A post-condition sending tokens `FungibleConditionCode.Less` (less-than) the given amount of uSTX or fungible-tokens.\n   * Finalize with the chained `.ustx()` or `.ft(…)` method.\n   * @example\n   * ```\n   * import { Pc } from '@stacks/transactions';\n   * Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6').willSendLt(100).stx();\n   * ```\n   */\n  willSendLt(amount: IntegerType) {\n    return new PartialPcFtWithCode(\n      this.address,\n      amount,\n      FungibleConditionCode.Less,\n      this.contractName\n    );\n  }\n\n  /**\n   * ### Fungible Token Post Condition\n   * A post-condition sending tokens `FungibleConditionCode.GreaterEqual` (greater-than or equal to) the given amount of uSTX or fungible-tokens.\n   * Finalize with the chained `.ustx()` or `.ft(…)` method.\n   * @example\n   * ```\n   * import { Pc } from '@stacks/transactions';\n   * Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6').willSendGte(100).stx();\n   * ```\n   */\n  willSendGte(amount: IntegerType) {\n    return new PartialPcFtWithCode(\n      this.address,\n      amount,\n      FungibleConditionCode.GreaterEqual,\n      this.contractName\n    );\n  }\n\n  /**\n   * ### Fungible Token Post Condition\n   * A post-condition sending tokens `FungibleConditionCode.Greater` (greater-than) the given amount of uSTX or fungible-tokens.\n   * Finalize with the chained `.ustx()` or `.ft(…)` method.\n   * @example\n   * ```\n   * import { Pc } from '@stacks/transactions';\n   * Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6').willSendGt(100).stx();\n   * ```\n   */\n  willSendGt(amount: IntegerType) {\n    return new PartialPcFtWithCode(\n      this.address,\n      amount,\n      FungibleConditionCode.Greater,\n      this.contractName\n    );\n  }\n\n  /**\n   * ### NFT Post Condition\n   * A post-condition which `NonFungibleConditionCode.Sends` an NFT.\n   * Finalize with the chained `.nft(…)` method.\n   * @example\n   * ```\n   * import { Pc } from '@stacks/transactions';\n   * Pc.principal('STB4…K6.nft-contract').willSendAsset().nft('STB4…K6.super-nft::super', uintCV(1));\n   * ```\n   */\n  willSendAsset() {\n    return new PartialPcNftWithCode(\n      this.address,\n      NonFungibleConditionCode.Sends,\n      this.contractName\n    );\n  }\n\n  /**\n   * ### NFT Post Condition\n   * A post-condition which `NonFungibleConditionCode.DoesNotSend` an NFT.\n   * Finalize with the chained `.nft(…)` method.\n   * @example\n   * ```\n   * import { Pc } from '@stacks/transactions';\n   * Pc.principal('STB4…K6.nft-contract').willNotSendAsset().nft('STB4…K6.super-nft::super', uintCV(1));\n   * ```\n   */\n  willNotSendAsset() {\n    return new PartialPcNftWithCode(\n      this.address,\n      NonFungibleConditionCode.DoesNotSend,\n      this.contractName\n    );\n  }\n}\n\n/**\n * Not meant to be used directly. Start from `Pc.principal(…)` instead.\n */\nclass PartialPcFtWithCode {\n  constructor(\n    private address: string,\n    private amount: IntegerType,\n    private code: FungibleConditionCode,\n    private contractName?: string\n  ) {}\n\n  /**\n   * ### STX Post Condition\n   * ⚠ Amount of STX is denoted in uSTX (micro-STX)\n   */\n  ustx() {\n    // todo: rename to `uSTX`?\n    if (this.contractName) {\n      return makeContractSTXPostCondition(this.address, this.contractName, this.code, this.amount);\n    }\n    return makeStandardSTXPostCondition(this.address, this.code, this.amount);\n  }\n\n  /**\n   * ### Fungible Token Post Condition\n   * ⚠ Amount of fungible tokens is denoted in the smallest unit of the token\n   */\n  ft(contractId: ContractIdString, tokenName: string) {\n    const [address, name] = parseContractId(contractId);\n    if (this.contractName) {\n      return makeContractFungiblePostCondition(\n        this.address,\n        this.contractName,\n        this.code,\n        this.amount,\n        createAssetInfo(address, name, tokenName)\n      );\n    }\n    return makeStandardFungiblePostCondition(\n      this.address,\n      this.code,\n      this.amount,\n      createAssetInfo(address, name, tokenName)\n    );\n  }\n}\n\n/**\n * Not meant to be used directly. Start from `Pc.principal(…)` instead.\n */\nclass PartialPcNftWithCode {\n  constructor(\n    private principal: string,\n    private code: NonFungibleConditionCode,\n    private contractName?: string\n  ) {}\n\n  /**\n   * ### Non-Fungible Token Post Condition\n   * @param assetName - The name of the NFT asset. Formatted as `<contract-address>.<contract-name>::<token-name>`.\n   * @param assetId - The asset identifier of the NFT. A Clarity value defining the single NFT instance.\n   */\n  nft(assetName: NftString, assetId: ClarityValue): NonFungiblePostCondition;\n  /**\n   * ### Non-Fungible Token Post Condition\n   * @param contractId - The contract identifier of the NFT. Formatted as `<contract-address>.<contract-name>`.\n   * @param tokenName - The name of the NFT asset.\n   * @param assetId - The asset identifier of the NFT. A Clarity value defining the single NFT instance.\n   */\n  nft(\n    contractId: ContractIdString,\n    tokenName: string,\n    assetId: ClarityValue\n  ): NonFungiblePostCondition;\n  nft(...args: [any, any] | [any, any, any]): NonFungiblePostCondition {\n    const { contractAddress, contractName, tokenName, assetId } = getNftArgs(\n      ...(args as [any, any, any])\n    );\n\n    if (this.contractName) {\n      return makeContractNonFungiblePostCondition(\n        this.principal,\n        this.contractName,\n        this.code,\n        createAssetInfo(contractAddress, contractName, tokenName),\n        assetId\n      );\n    }\n\n    return makeStandardNonFungiblePostCondition(\n      this.principal,\n      this.code,\n      createAssetInfo(contractAddress, contractName, tokenName),\n      assetId\n    );\n  }\n}\n\n/** @internal */\nfunction parseContractId(contractId: ContractIdString) {\n  const [address, name] = contractId.split('.');\n  if (!address || !name) throw new Error(`Invalid contract identifier: ${contractId}`);\n  return [address, name];\n}\n\n/** @internal */\nfunction parseNft(nftAssetName: NftString) {\n  const [principal, tokenName] = nftAssetName.split('::') as [ContractIdString, string];\n  if (!principal || !tokenName)\n    throw new Error(`Invalid fully-qualified nft asset name: ${nftAssetName}`);\n  const [address, name] = parseContractId(principal);\n  return { contractAddress: address, contractName: name, tokenName };\n}\n\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nfunction isContractIdString(value: AddressString | ContractIdString): value is ContractIdString {\n  return value.includes('.');\n}\n\n/**\n * Helper method for `PartialPcNftWithCode.nft` to parse the arguments.\n * @internal\n */\nfunction getNftArgs(\n  assetName: NftString,\n  assetId: ClarityValue\n): { contractAddress: string; contractName: string; tokenName: string; assetId: ClarityValue };\nfunction getNftArgs(\n  contractId: ContractIdString,\n  tokenName: string,\n  assetId: ClarityValue\n): { contractAddress: string; contractName: string; tokenName: string; assetId: ClarityValue };\nfunction getNftArgs(...args: [any, any] | [any, any, any]): {\n  contractAddress: string;\n  contractName: string;\n  tokenName: string;\n  assetId: ClarityValue;\n} {\n  if (args.length === 2) {\n    const [assetName, assetId] = args;\n    return { ...parseNft(assetName), assetId };\n  }\n\n  // args.length === 3\n  const [contractId, tokenName, assetId] = args;\n  const [address, name] = parseContractId(contractId);\n  return { contractAddress: address, contractName: name, tokenName, assetId };\n}\n", "import { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, concatBytes, utf8ToBytes } from '@stacks/common';\n\nimport { ClarityType, ClarityValue, serializeCV } from './clarity';\nimport { StacksMessageType } from './constants';\nimport { signMessageHashRsv, StacksPrivateKey } from './keys';\nimport { StructuredDataSignature } from './message-types';\n\n// Refer to SIP018 https://github.com/stacksgov/sips/\n// > asciiToBytes('SIP018')\nexport const STRUCTURED_DATA_PREFIX = new Uint8Array([0x53, 0x49, 0x50, 0x30, 0x31, 0x38]);\n\nexport function hashStructuredData(structuredData: ClarityValue): Uint8Array {\n  return sha256(serializeCV(structuredData));\n}\n\nconst hash256BytesLength = 32;\n\nfunction isDomain(value: ClarityValue): boolean {\n  if (value.type !== ClarityType.Tuple) return false;\n  // Check that the tuple has at least 'name', 'version' and 'chain-id'\n  if (!['name', 'version', 'chain-id'].every(key => key in value.data)) return false;\n  // Check each key is of the right type\n  if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII))\n    return false;\n\n  if (value.data['chain-id'].type !== ClarityType.UInt) return false;\n  return true;\n}\n\nexport function encodeStructuredData({\n  message,\n  domain,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n}): Uint8Array {\n  const structuredDataHash: Uint8Array = hashStructuredData(message);\n  if (!isDomain(domain)) {\n    throw new Error(\n      \"domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt\"\n    );\n  }\n  const domainHash: Uint8Array = hashStructuredData(domain);\n\n  return concatBytes(STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash);\n}\n\nexport type DecodedStructuredData = {\n  domainHash: Uint8Array;\n  messageHash: Uint8Array;\n};\n\nexport function decodeStructuredDataSignature(\n  signature: string | Uint8Array\n): DecodedStructuredData {\n  const encodedMessageBytes: Uint8Array =\n    typeof signature === 'string' ? utf8ToBytes(signature) : signature;\n  const domainHash = encodedMessageBytes.slice(\n    STRUCTURED_DATA_PREFIX.length,\n    STRUCTURED_DATA_PREFIX.length + hash256BytesLength\n  );\n  const messageHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  return {\n    domainHash,\n    messageHash,\n  };\n}\n\n/**\n * Signs a structured message (ClarityValue) and a domain (ClarityValue) using a private key.\n * The resulting signature along with the original message can be verified using {@link verifyMessageSignature}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signStructuredData({\n  message,\n  domain,\n  privateKey,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n  privateKey: StacksPrivateKey;\n}): StructuredDataSignature {\n  const structuredDataHash: string = bytesToHex(sha256(encodeStructuredData({ message, domain })));\n\n  const { data } = signMessageHashRsv({\n    messageHash: structuredDataHash,\n    privateKey,\n  });\n  return {\n    data,\n    type: StacksMessageType.StructuredDataSignature,\n  };\n}\n"],
  "mappings": "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",
  "names": ["error", "ChainID", "TransactionVersion", "PeerNetworkID", "ChainID", "StacksMessageType", "PayloadType", "ClarityVersion", "AnchorMode", "TransactionVersion", "PostConditionMode", "PostConditionType", "AuthType", "AddressHashMode", "AddressVersion", "PubKeyEncoding", "FungibleConditionCode", "NonFungibleConditionCode", "PostConditionPrincipalID", "AssetType", "TxRejectedReason", "import_c32check", "TransactionVersion", "address", "import_c32check", "address", "ClarityType", "principal", "address", "bool", "buffer", "import_c32check", "TransactionVersion", "getPublicKey", "TenureChangeCause", "smartContractName", "codeBody", "recipient", "AuthFieldType", "address", "principal", "list", "lodashCloneDeep", "regex", "getPublicKey", "verify", "import_c32check", "ClarityAbiTypeId", "addr", "name", "tuple", "address", "principal", "TransactionVersion", "address", "error", "TransactionVersion", "getPublicKey", "address", "principal", "principal", "address", "assetId"]
}
